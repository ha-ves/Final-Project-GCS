/* This file is automatically generated. Any changes made to it may be overwritten. */

using System;
using System.IO;
using System.Collections.Generic;

namespace MavLinkNet
{

    /// <summary>
    /// Micro air vehicle / autopilot classes. This identifies the individual model.
    /// </summary>
    public enum MavAutopilot { 

        /// <summary> Generic autopilot, full support for everything </summary>
        Generic = 0, 

        /// <summary> Reserved for future use. </summary>
        Reserved = 1, 

        /// <summary> SLUGS autopilot, http://slugsuav.soe.ucsc.edu </summary>
        Slugs = 2, 

        /// <summary> ArduPilot - Plane/Copter/Rover/Sub/Tracker, https://ardupilot.org </summary>
        Ardupilotmega = 3, 

        /// <summary> OpenPilot, http://openpilot.org </summary>
        Openpilot = 4, 

        /// <summary> Generic autopilot only supporting simple waypoints </summary>
        GenericWaypointsOnly = 5, 

        /// <summary> Generic autopilot supporting waypoints and other simple navigation commands </summary>
        GenericWaypointsAndSimpleNavigationOnly = 6, 

        /// <summary> Generic autopilot supporting the full mission command set </summary>
        GenericMissionFull = 7, 

        /// <summary> No valid autopilot, e.g. a GCS or other MAVLink component </summary>
        Invalid = 8, 

        /// <summary> PPZ UAV - http://nongnu.org/paparazzi </summary>
        Ppz = 9, 

        /// <summary> UAV Dev Board </summary>
        Udb = 10, 

        /// <summary> FlexiPilot </summary>
        Fp = 11, 

        /// <summary> PX4 Autopilot - http://px4.io/ </summary>
        Px4 = 12, 

        /// <summary> SMACCMPilot - http://smaccmpilot.org </summary>
        Smaccmpilot = 13, 

        /// <summary> AutoQuad -- http://autoquad.org </summary>
        Autoquad = 14, 

        /// <summary> Armazila -- http://armazila.com </summary>
        Armazila = 15, 

        /// <summary> Aerob -- http://aerob.ru </summary>
        Aerob = 16, 

        /// <summary> ASLUAV autopilot -- http://www.asl.ethz.ch </summary>
        Asluav = 17, 

        /// <summary> SmartAP Autopilot - http://sky-drones.com </summary>
        Smartap = 18, 

        /// <summary> AirRails - http://uaventure.com </summary>
        Airrails = 19, 

        /// <summary> Fusion Reflex - https://fusion.engineering </summary>
        Reflex = 20 };

    /// <summary>
    /// MAVLINK component type reported in HEARTBEAT message. Flight controllers must report the type of the vehicle on which they are mounted (e.g. MAV_TYPE_OCTOROTOR). All other components must report a value appropriate for their type (e.g. a camera must use MAV_TYPE_CAMERA).
    /// </summary>
    public enum MavType { 

        /// <summary> Generic micro air vehicle </summary>
        Generic = 0, 

        /// <summary> Fixed wing aircraft. </summary>
        FixedWing = 1, 

        /// <summary> Quadrotor </summary>
        Quadrotor = 2, 

        /// <summary> Coaxial helicopter </summary>
        Coaxial = 3, 

        /// <summary> Normal helicopter with tail rotor. </summary>
        Helicopter = 4, 

        /// <summary> Ground installation </summary>
        AntennaTracker = 5, 

        /// <summary> Operator control unit / ground control station </summary>
        Gcs = 6, 

        /// <summary> Airship, controlled </summary>
        Airship = 7, 

        /// <summary> Free balloon, uncontrolled </summary>
        FreeBalloon = 8, 

        /// <summary> Rocket </summary>
        Rocket = 9, 

        /// <summary> Ground rover </summary>
        GroundRover = 10, 

        /// <summary> Surface vessel, boat, ship </summary>
        SurfaceBoat = 11, 

        /// <summary> Submarine </summary>
        Submarine = 12, 

        /// <summary> Hexarotor </summary>
        Hexarotor = 13, 

        /// <summary> Octorotor </summary>
        Octorotor = 14, 

        /// <summary> Tricopter </summary>
        Tricopter = 15, 

        /// <summary> Flapping wing </summary>
        FlappingWing = 16, 

        /// <summary> Kite </summary>
        Kite = 17, 

        /// <summary> Onboard companion controller </summary>
        OnboardController = 18, 

        /// <summary> Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter. </summary>
        VtolDuorotor = 19, 

        /// <summary> Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter. </summary>
        VtolQuadrotor = 20, 

        /// <summary> Tiltrotor VTOL </summary>
        VtolTiltrotor = 21, 

        /// <summary> VTOL reserved 2 </summary>
        VtolReserved2 = 22, 

        /// <summary> VTOL reserved 3 </summary>
        VtolReserved3 = 23, 

        /// <summary> VTOL reserved 4 </summary>
        VtolReserved4 = 24, 

        /// <summary> VTOL reserved 5 </summary>
        VtolReserved5 = 25, 

        /// <summary> Gimbal </summary>
        Gimbal = 26, 

        /// <summary> ADSB system </summary>
        Adsb = 27, 

        /// <summary> Steerable, nonrigid airfoil </summary>
        Parafoil = 28, 

        /// <summary> Dodecarotor </summary>
        Dodecarotor = 29, 

        /// <summary> Camera </summary>
        Camera = 30, 

        /// <summary> Charging station </summary>
        ChargingStation = 31, 

        /// <summary> FLARM collision avoidance system </summary>
        Flarm = 32, 

        /// <summary> Servo </summary>
        Servo = 33, 

        /// <summary> Open Drone ID. See https://mavlink.io/en/services/opendroneid.html. </summary>
        Odid = 34, 

        /// <summary> Decarotor </summary>
        Decarotor = 35, 

        /// <summary> Battery </summary>
        Battery = 36, 

        /// <summary> Parachute </summary>
        Parachute = 37 };

    /// <summary>
    /// These flags encode the MAV mode.
    /// </summary>
    public enum MavModeFlag { 

        /// <summary> 0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM shall be used instead. The flag can still be used to report the armed state. </summary>
        SafetyArmed = 128, 

        /// <summary> 0b01000000 remote control input is enabled. </summary>
        ManualInputEnabled = 64, 

        /// <summary> 0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software is full operational. </summary>
        HilEnabled = 32, 

        /// <summary> 0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further control inputs to move around. </summary>
        StabilizeEnabled = 16, 

        /// <summary> 0b00001000 guided mode enabled, system flies waypoints / mission items. </summary>
        GuidedEnabled = 8, 

        /// <summary> 0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not, depends on the actual implementation. </summary>
        AutoEnabled = 4, 

        /// <summary> 0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations. </summary>
        TestEnabled = 2, 

        /// <summary> 0b00000001 Reserved for future use. </summary>
        CustomModeEnabled = 1 };

    /// <summary>
    /// These values encode the bit positions of the decode position. These values can be used to read the value of a flag bit by combining the base_mode variable with AND with the flag position value. The result will be either 0 or 1, depending on if the flag is set or not.
    /// </summary>
    public enum MavModeFlagDecodePosition { 

        /// <summary> First bit:  10000000 </summary>
        Safety = 128, 

        /// <summary> Second bit: 01000000 </summary>
        Manual = 64, 

        /// <summary> Third bit:  00100000 </summary>
        Hil = 32, 

        /// <summary> Fourth bit: 00010000 </summary>
        Stabilize = 16, 

        /// <summary> Fifth bit:  00001000 </summary>
        Guided = 8, 

        /// <summary> Sixth bit:   00000100 </summary>
        Auto = 4, 

        /// <summary> Seventh bit: 00000010 </summary>
        Test = 2, 

        /// <summary> Eighth bit: 00000001 </summary>
        CustomMode = 1 };

    public enum MavState { 

        /// <summary> Uninitialized system, state is unknown. </summary>
        Uninit = 0, 

        /// <summary> System is booting up. </summary>
        Boot = 1, 

        /// <summary> System is calibrating and not flight-ready. </summary>
        Calibrating = 2, 

        /// <summary> System is grounded and on standby. It can be launched any time. </summary>
        Standby = 3, 

        /// <summary> System is active and might be already airborne. Motors are engaged. </summary>
        Active = 4, 

        /// <summary> System is in a non-normal flight mode. It can however still navigate. </summary>
        Critical = 5, 

        /// <summary> System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in mayday and going down. </summary>
        Emergency = 6, 

        /// <summary> System just initialized its power-down sequence, will shut down now. </summary>
        Poweroff = 7, 

        /// <summary> System is terminating itself. </summary>
        FlightTermination = 8 };

    /// <summary>
    /// Component ids (values) for the different types and instances of onboard hardware/software that might make up a MAVLink system (autopilot, cameras, servos, GPS systems, avoidance systems etc.).       Components must use the appropriate ID in their source address when sending messages. Components can also use IDs to determine if they are the intended recipient of an incoming message. The MAV_COMP_ID_ALL value is used to indicate messages that must be processed by all components.       When creating new entries, components that can have multiple instances (e.g. cameras, servos etc.) should be allocated sequential values. An appropriate number of values should be left free after these components to allow the number of instances to be expanded.
    /// </summary>
    public enum MavComponent { 

        /// <summary> Target id (target_component) used to broadcast messages to all components of the receiving system. Components should attempt to process messages with this component ID and forward to components on any other interfaces. Note: This is not a valid *source* component id for a message. </summary>
        MavCompIdAll = 0, 

        /// <summary> System flight controller component ('autopilot'). Only one autopilot is expected in a particular system. </summary>
        MavCompIdAutopilot1 = 1, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser1 = 25, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser2 = 26, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser3 = 27, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser4 = 28, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser5 = 29, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser6 = 30, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser7 = 31, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser8 = 32, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser9 = 33, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser10 = 34, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser11 = 35, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser12 = 36, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser13 = 37, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser14 = 38, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser15 = 39, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser16 = 40, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser17 = 41, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser18 = 42, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser19 = 43, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser20 = 44, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser21 = 45, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser22 = 46, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser23 = 47, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser24 = 48, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser25 = 49, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser26 = 50, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser27 = 51, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser28 = 52, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser29 = 53, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser30 = 54, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser31 = 55, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser32 = 56, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser33 = 57, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser34 = 58, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser35 = 59, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser36 = 60, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser37 = 61, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser38 = 62, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser39 = 63, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser40 = 64, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser41 = 65, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser42 = 66, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser43 = 67, 

        /// <summary> Telemetry radio (e.g. SiK radio, or other component that emits RADIO_STATUS messages). </summary>
        MavCompIdTelemetryRadio = 68, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser45 = 69, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser46 = 70, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser47 = 71, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser48 = 72, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser49 = 73, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser50 = 74, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser51 = 75, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser52 = 76, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser53 = 77, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser54 = 78, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser55 = 79, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser56 = 80, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser57 = 81, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser58 = 82, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser59 = 83, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser60 = 84, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser61 = 85, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser62 = 86, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser63 = 87, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser64 = 88, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser65 = 89, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser66 = 90, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser67 = 91, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser68 = 92, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser69 = 93, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser70 = 94, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser71 = 95, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser72 = 96, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser73 = 97, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser74 = 98, 

        /// <summary> Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network. </summary>
        MavCompIdUser75 = 99, 

        /// <summary> Camera #1. </summary>
        MavCompIdCamera = 100, 

        /// <summary> Camera #2. </summary>
        MavCompIdCamera2 = 101, 

        /// <summary> Camera #3. </summary>
        MavCompIdCamera3 = 102, 

        /// <summary> Camera #4. </summary>
        MavCompIdCamera4 = 103, 

        /// <summary> Camera #5. </summary>
        MavCompIdCamera5 = 104, 

        /// <summary> Camera #6. </summary>
        MavCompIdCamera6 = 105, 

        /// <summary> Servo #1. </summary>
        MavCompIdServo1 = 140, 

        /// <summary> Servo #2. </summary>
        MavCompIdServo2 = 141, 

        /// <summary> Servo #3. </summary>
        MavCompIdServo3 = 142, 

        /// <summary> Servo #4. </summary>
        MavCompIdServo4 = 143, 

        /// <summary> Servo #5. </summary>
        MavCompIdServo5 = 144, 

        /// <summary> Servo #6. </summary>
        MavCompIdServo6 = 145, 

        /// <summary> Servo #7. </summary>
        MavCompIdServo7 = 146, 

        /// <summary> Servo #8. </summary>
        MavCompIdServo8 = 147, 

        /// <summary> Servo #9. </summary>
        MavCompIdServo9 = 148, 

        /// <summary> Servo #10. </summary>
        MavCompIdServo10 = 149, 

        /// <summary> Servo #11. </summary>
        MavCompIdServo11 = 150, 

        /// <summary> Servo #12. </summary>
        MavCompIdServo12 = 151, 

        /// <summary> Servo #13. </summary>
        MavCompIdServo13 = 152, 

        /// <summary> Servo #14. </summary>
        MavCompIdServo14 = 153, 

        /// <summary> Gimbal #1. </summary>
        MavCompIdGimbal = 154, 

        /// <summary> Logging component. </summary>
        MavCompIdLog = 155, 

        /// <summary> Automatic Dependent Surveillance-Broadcast (ADS-B) component. </summary>
        MavCompIdAdsb = 156, 

        /// <summary> On Screen Display (OSD) devices for video links. </summary>
        MavCompIdOsd = 157, 

        /// <summary> Generic autopilot peripheral component ID. Meant for devices that do not implement the parameter microservice. </summary>
        MavCompIdPeripheral = 158, 

        /// <summary> Gimbal ID for QX1. </summary>
        MavCompIdQx1Gimbal = 159, 

        /// <summary> FLARM collision alert component. </summary>
        MavCompIdFlarm = 160, 

        /// <summary> Parachute component. </summary>
        MavCompIdParachute = 161, 

        /// <summary> Gimbal #2. </summary>
        MavCompIdGimbal2 = 171, 

        /// <summary> Gimbal #3. </summary>
        MavCompIdGimbal3 = 172, 

        /// <summary> Gimbal #4 </summary>
        MavCompIdGimbal4 = 173, 

        /// <summary> Gimbal #5. </summary>
        MavCompIdGimbal5 = 174, 

        /// <summary> Gimbal #6. </summary>
        MavCompIdGimbal6 = 175, 

        /// <summary> Battery #1. </summary>
        MavCompIdBattery = 180, 

        /// <summary> Battery #2. </summary>
        MavCompIdBattery2 = 181, 

        /// <summary> Component that can generate/supply a mission flight plan (e.g. GCS or developer API). </summary>
        MavCompIdMissionplanner = 190, 

        /// <summary> Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on. </summary>
        MavCompIdOnboardComputer = 191, 

        /// <summary> Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on. </summary>
        MavCompIdOnboardComputer2 = 192, 

        /// <summary> Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on. </summary>
        MavCompIdOnboardComputer3 = 193, 

        /// <summary> Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on. </summary>
        MavCompIdOnboardComputer4 = 194, 

        /// <summary> Component that finds an optimal path between points based on a certain constraint (e.g. minimum snap, shortest path, cost, etc.). </summary>
        MavCompIdPathplanner = 195, 

        /// <summary> Component that plans a collision free path between two points. </summary>
        MavCompIdObstacleAvoidance = 196, 

        /// <summary> Component that provides position estimates using VIO techniques. </summary>
        MavCompIdVisualInertialOdometry = 197, 

        /// <summary> Component that manages pairing of vehicle and GCS. </summary>
        MavCompIdPairingManager = 198, 

        /// <summary> Inertial Measurement Unit (IMU) #1. </summary>
        MavCompIdImu = 200, 

        /// <summary> Inertial Measurement Unit (IMU) #2. </summary>
        MavCompIdImu2 = 201, 

        /// <summary> Inertial Measurement Unit (IMU) #3. </summary>
        MavCompIdImu3 = 202, 

        /// <summary> GPS #1. </summary>
        MavCompIdGps = 220, 

        /// <summary> GPS #2. </summary>
        MavCompIdGps2 = 221, 

        /// <summary> Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet). </summary>
        MavCompIdOdidTxrx1 = 236, 

        /// <summary> Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet). </summary>
        MavCompIdOdidTxrx2 = 237, 

        /// <summary> Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet). </summary>
        MavCompIdOdidTxrx3 = 238, 

        /// <summary> Component to bridge MAVLink to UDP (i.e. from a UART). </summary>
        MavCompIdUdpBridge = 240, 

        /// <summary> Component to bridge to UART (i.e. from UDP). </summary>
        MavCompIdUartBridge = 241, 

        /// <summary> Component handling TUNNEL messages (e.g. vendor specific GUI of a component). </summary>
        MavCompIdTunnelNode = 242, 

        /// <summary> Component for handling system messages (e.g. to ARM, takeoff, etc.). </summary>
        MavCompIdSystemControl = 250 };

    /// <summary>
    /// These values define the type of firmware release.  These values indicate the first version or release of this type.  For example the first alpha release would be 64, the second would be 65.
    /// </summary>
    public enum FirmwareVersionType { 

        /// <summary> development release </summary>
        Dev = 0, 

        /// <summary> alpha release </summary>
        Alpha = 64, 

        /// <summary> beta release </summary>
        Beta = 128, 

        /// <summary> release candidate </summary>
        Rc = 192, 

        /// <summary> official stable release </summary>
        Official = 255 };

    /// <summary>
    /// Flags to report failure cases over the high latency telemtry.
    /// </summary>
    public enum HlFailureFlag { 

        /// <summary> GPS failure. </summary>
        Gps = 1, 

        /// <summary> Differential pressure sensor failure. </summary>
        DifferentialPressure = 2, 

        /// <summary> Absolute pressure sensor failure. </summary>
        AbsolutePressure = 4, 

        /// <summary> Accelerometer sensor failure. </summary>
        _3dAccel = 8, 

        /// <summary> Gyroscope sensor failure. </summary>
        _3dGyro = 16, 

        /// <summary> Magnetometer sensor failure. </summary>
        _3dMag = 32, 

        /// <summary> Terrain subsystem failure. </summary>
        Terrain = 64, 

        /// <summary> Battery failure/critical low battery. </summary>
        Battery = 128, 

        /// <summary> RC receiver failure/no rc connection. </summary>
        RcReceiver = 256, 

        /// <summary> Offboard link failure. </summary>
        OffboardLink = 512, 

        /// <summary> Engine failure. </summary>
        Engine = 1024, 

        /// <summary> Geofence violation. </summary>
        Geofence = 2048, 

        /// <summary> Estimator failure, for example measurement rejection or large variances. </summary>
        Estimator = 4096, 

        /// <summary> Mission failure. </summary>
        Mission = 8192 };

    /// <summary>
    /// Actions that may be specified in MAV_CMD_OVERRIDE_GOTO to override mission execution.
    /// </summary>
    public enum MavGoto { 

        /// <summary> Hold at the current position. </summary>
        DoHold = 0, 

        /// <summary> Continue with the next item in mission execution. </summary>
        DoContinue = 1, 

        /// <summary> Hold at the current position of the system </summary>
        HoldAtCurrentPosition = 2, 

        /// <summary> Hold at the position specified in the parameters of the DO_HOLD action </summary>
        HoldAtSpecifiedPosition = 3 };

    /// <summary>
    /// These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it                simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override.
    /// </summary>
    public enum MavMode { 

        /// <summary> System is not ready to fly, booting, calibrating, etc. No flag is set. </summary>
        Preflight = 0, 

        /// <summary> System is allowed to be active, under assisted RC control. </summary>
        StabilizeDisarmed = 80, 

        /// <summary> System is allowed to be active, under assisted RC control. </summary>
        StabilizeArmed = 208, 

        /// <summary> System is allowed to be active, under manual (RC) control, no stabilization </summary>
        ManualDisarmed = 64, 

        /// <summary> System is allowed to be active, under manual (RC) control, no stabilization </summary>
        ManualArmed = 192, 

        /// <summary> System is allowed to be active, under autonomous control, manual setpoint </summary>
        GuidedDisarmed = 88, 

        /// <summary> System is allowed to be active, under autonomous control, manual setpoint </summary>
        GuidedArmed = 216, 

        /// <summary> System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints) </summary>
        AutoDisarmed = 92, 

        /// <summary> System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints) </summary>
        AutoArmed = 220, 

        /// <summary> UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only. </summary>
        TestDisarmed = 66, 

        /// <summary> UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only. </summary>
        TestArmed = 194 };

    /// <summary>
    /// These encode the sensors whose status is sent as part of the SYS_STATUS message.
    /// </summary>
    public enum MavSysStatusSensor { 

        /// <summary> 0x01 3D gyro </summary>
        _3dGyro = 1, 

        /// <summary> 0x02 3D accelerometer </summary>
        _3dAccel = 2, 

        /// <summary> 0x04 3D magnetometer </summary>
        _3dMag = 4, 

        /// <summary> 0x08 absolute pressure </summary>
        AbsolutePressure = 8, 

        /// <summary> 0x10 differential pressure </summary>
        DifferentialPressure = 16, 

        /// <summary> 0x20 GPS </summary>
        Gps = 32, 

        /// <summary> 0x40 optical flow </summary>
        OpticalFlow = 64, 

        /// <summary> 0x80 computer vision position </summary>
        VisionPosition = 128, 

        /// <summary> 0x100 laser based position </summary>
        LaserPosition = 256, 

        /// <summary> 0x200 external ground truth (Vicon or Leica) </summary>
        ExternalGroundTruth = 512, 

        /// <summary> 0x400 3D angular rate control </summary>
        AngularRateControl = 1024, 

        /// <summary> 0x800 attitude stabilization </summary>
        AttitudeStabilization = 2048, 

        /// <summary> 0x1000 yaw position </summary>
        YawPosition = 4096, 

        /// <summary> 0x2000 z/altitude control </summary>
        ZAltitudeControl = 8192, 

        /// <summary> 0x4000 x/y position control </summary>
        XyPositionControl = 16384, 

        /// <summary> 0x8000 motor outputs / control </summary>
        MotorOutputs = 32768, 

        /// <summary> 0x10000 rc receiver </summary>
        RcReceiver = 65536, 

        /// <summary> 0x20000 2nd 3D gyro </summary>
        _3dGyro2 = 131072, 

        /// <summary> 0x40000 2nd 3D accelerometer </summary>
        _3dAccel2 = 262144, 

        /// <summary> 0x80000 2nd 3D magnetometer </summary>
        _3dMag2 = 524288, 

        /// <summary> 0x100000 geofence </summary>
        MavSysStatusGeofence = 1048576, 

        /// <summary> 0x200000 AHRS subsystem health </summary>
        MavSysStatusAhrs = 2097152, 

        /// <summary> 0x400000 Terrain subsystem health </summary>
        MavSysStatusTerrain = 4194304, 

        /// <summary> 0x800000 Motors are reversed </summary>
        MavSysStatusReverseMotor = 8388608, 

        /// <summary> 0x1000000 Logging </summary>
        MavSysStatusLogging = 16777216, 

        /// <summary> 0x2000000 Battery </summary>
        Battery = 33554432, 

        /// <summary> 0x4000000 Proximity </summary>
        Proximity = 67108864, 

        /// <summary> 0x8000000 Satellite Communication  </summary>
        Satcom = 134217728, 

        /// <summary> 0x10000000 pre-arm check status. Always healthy when armed </summary>
        MavSysStatusPrearmCheck = 268435456, 

        /// <summary> 0x20000000 Avoidance/collision prevention </summary>
        MavSysStatusObstacleAvoidance = 536870912, 

        /// <summary> 0x40000000 propulsion (actuator, esc, motor or propellor) </summary>
        Propulsion = 1073741824 };

    /// <summary>
    /// Co-ordinate frames used by MAVLink. Not all frames are supported by all commands, messages, or vehicles.              Global frames use the following naming conventions:       - `GLOBAL`: Global co-ordinate frame with WGS84 latitude/longitude and altitude positive over mean sea level (MSL) by default.          The following modifiers may be used with `GLOBAL`:         - `RELATIVE_ALT`: Altitude is relative to the vehicle home position rather than MSL         - `TERRAIN_ALT`: Altitude is relative to ground level rather than MSL         - `INT`: Latitude/longitude (in degrees) are scaled by multiplying by 1E7          Local frames use the following naming conventions:       - `LOCAL`: Origin of local frame is fixed relative to earth. Unless otherwise specified this origin is the origin of the vehicle position-estimator ('EKF').       - `BODY`: Origin of local frame travels with the vehicle. NOTE, `BODY` does NOT indicate alignment of frame axis with vehicle attitude.       - `OFFSET`: Deprecated synonym for `BODY` (origin travels with the vehicle). Not to be used for new frames.        Some deprecated frames do not follow these conventions (e.g. MAV_FRAME_BODY_NED and MAV_FRAME_BODY_OFFSET_NED).  
    /// </summary>
    public enum MavFrame { 

        /// <summary> Global (WGS84) coordinate frame + MSL altitude. First value / x: latitude, second value / y: longitude, third value / z: positive altitude over mean sea level (MSL). </summary>
        Global = 0, 

        /// <summary> NED local tangent frame (x: North, y: East, z: Down) with origin fixed relative to earth. </summary>
        LocalNed = 1, 

        /// <summary> NOT a coordinate frame, indicates a mission command. </summary>
        Mission = 2, 

        /// <summary> Global (WGS84) coordinate frame + altitude relative to the home position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude with 0 being at the altitude of the home location. </summary>
        GlobalRelativeAlt = 3, 

        /// <summary> ENU local tangent frame (x: East, y: North, z: Up) with origin fixed relative to earth. </summary>
        LocalEnu = 4, 

        /// <summary> Global (WGS84) coordinate frame (scaled) + MSL altitude. First value / x: latitude in degrees*1E7, second value / y: longitude in degrees*1E7, third value / z: positive altitude over mean sea level (MSL). </summary>
        GlobalInt = 5, 

        /// <summary> Global (WGS84) coordinate frame (scaled) + altitude relative to the home position. First value / x: latitude in degrees*1E7, second value / y: longitude in degrees*1E7, third value / z: positive altitude with 0 being at the altitude of the home location. </summary>
        GlobalRelativeAltInt = 6, 

        /// <summary> NED local tangent frame (x: North, y: East, z: Down) with origin that travels with the vehicle. </summary>
        LocalOffsetNed = 7, 

        /// <summary> Same as MAV_FRAME_LOCAL_NED when used to represent position values. Same as MAV_FRAME_BODY_FRD when used with velocity/accelaration values. </summary>
        BodyNed = 8, 

        /// <summary> This is the same as MAV_FRAME_BODY_FRD. </summary>
        BodyOffsetNed = 9, 

        /// <summary> Global (WGS84) coordinate frame with AGL altitude (at the waypoint coordinate). First value / x: latitude in degrees, second value / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level in terrain model. </summary>
        GlobalTerrainAlt = 10, 

        /// <summary> Global (WGS84) coordinate frame (scaled) with AGL altitude (at the waypoint coordinate). First value / x: latitude in degrees*1E7, second value / y: longitude in degrees*1E7, third value / z: positive altitude in meters with 0 being at ground level in terrain model. </summary>
        GlobalTerrainAltInt = 11, 

        /// <summary> FRD local tangent frame (x: Forward, y: Right, z: Down) with origin that travels with vehicle. The forward axis is aligned to the front of the vehicle in the horizontal plane. </summary>
        BodyFrd = 12, 

        /// <summary> MAV_FRAME_BODY_FLU - Body fixed frame of reference, Z-up (x: Forward, y: Left, z: Up). </summary>
        Reserved13 = 13, 

        /// <summary> MAV_FRAME_MOCAP_NED - Odometry local coordinate frame of data given by a motion capture system, Z-down (x: North, y: East, z: Down). </summary>
        Reserved14 = 14, 

        /// <summary> MAV_FRAME_MOCAP_ENU - Odometry local coordinate frame of data given by a motion capture system, Z-up (x: East, y: North, z: Up). </summary>
        Reserved15 = 15, 

        /// <summary> MAV_FRAME_VISION_NED - Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: North, y: East, z: Down). </summary>
        Reserved16 = 16, 

        /// <summary> MAV_FRAME_VISION_ENU - Odometry local coordinate frame of data given by a vision estimation system, Z-up (x: East, y: North, z: Up). </summary>
        Reserved17 = 17, 

        /// <summary> MAV_FRAME_ESTIM_NED - Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: North, y: East, z: Down). </summary>
        Reserved18 = 18, 

        /// <summary> MAV_FRAME_ESTIM_ENU - Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-up (x: East, y: North, z: Up). </summary>
        Reserved19 = 19, 

        /// <summary> FRD local tangent frame (x: Forward, y: Right, z: Down) with origin fixed relative to earth. The forward axis is aligned to the front of the vehicle in the horizontal plane. </summary>
        LocalFrd = 20, 

        /// <summary> FLU local tangent frame (x: Forward, y: Left, z: Up) with origin fixed relative to earth. The forward axis is aligned to the front of the vehicle in the horizontal plane. </summary>
        LocalFlu = 21 };

    public enum MavlinkDataStreamType { 

        /// <summary>  </summary>
        MavlinkDataStreamImgJpeg = 0, 

        /// <summary>  </summary>
        MavlinkDataStreamImgBmp = 1, 

        /// <summary>  </summary>
        MavlinkDataStreamImgRaw8u = 2, 

        /// <summary>  </summary>
        MavlinkDataStreamImgRaw32u = 3, 

        /// <summary>  </summary>
        MavlinkDataStreamImgPgm = 4, 

        /// <summary>  </summary>
        MavlinkDataStreamImgPng = 5 };

    /// <summary>
    /// Actions following geofence breach.
    /// </summary>
    public enum FenceAction { 

        /// <summary> Disable fenced mode. If used in a plan this would mean the next fence is disabled. </summary>
        None = 0, 

        /// <summary> Fly to geofence MAV_CMD_NAV_FENCE_RETURN_POINT in GUIDED mode. Note: This action is only supported by ArduPlane, and may not be supported in all versions. </summary>
        Guided = 1, 

        /// <summary> Report fence breach, but don't take action </summary>
        Report = 2, 

        /// <summary> Fly to geofence MAV_CMD_NAV_FENCE_RETURN_POINT with manual throttle control in GUIDED mode. Note: This action is only supported by ArduPlane, and may not be supported in all versions. </summary>
        GuidedThrPass = 3, 

        /// <summary> Return/RTL mode. </summary>
        Rtl = 4, 

        /// <summary> Hold at current location. </summary>
        Hold = 5, 

        /// <summary> Termination failsafe. Motors are shut down (some flight stacks may trigger other failsafe actions). </summary>
        Terminate = 6, 

        /// <summary> Land at current location. </summary>
        Land = 7 };

    public enum FenceBreach { 

        /// <summary> No last fence breach </summary>
        None = 0, 

        /// <summary> Breached minimum altitude </summary>
        Minalt = 1, 

        /// <summary> Breached maximum altitude </summary>
        Maxalt = 2, 

        /// <summary> Breached fence boundary </summary>
        Boundary = 3 };

    /// <summary>
    /// Actions being taken to mitigate/prevent fence breach
    /// </summary>
    public enum FenceMitigate { 

        /// <summary> Unknown </summary>
        Unknown = 0, 

        /// <summary> No actions being taken </summary>
        None = 1, 

        /// <summary> Velocity limiting active to prevent breach </summary>
        VelLimit = 2 };

    /// <summary>
    /// Enumeration of possible mount operation modes. This message is used by obsolete/deprecated gimbal messages.
    /// </summary>
    public enum MavMountMode { 

        /// <summary> Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization </summary>
        Retract = 0, 

        /// <summary> Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory. </summary>
        Neutral = 1, 

        /// <summary> Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization </summary>
        MavlinkTargeting = 2, 

        /// <summary> Load neutral position and start RC Roll,Pitch,Yaw control with stabilization </summary>
        RcTargeting = 3, 

        /// <summary> Load neutral position and start to point to Lat,Lon,Alt </summary>
        GpsPoint = 4, 

        /// <summary> Gimbal tracks system with specified system ID </summary>
        SysidTarget = 5, 

        /// <summary> Gimbal tracks home location </summary>
        HomeLocation = 6 };

    /// <summary>
    /// Gimbal device (low level) capability flags (bitmap)
    /// </summary>
    public enum GimbalDeviceCapFlags { 

        /// <summary> Gimbal device supports a retracted position </summary>
        HasRetract = 1, 

        /// <summary> Gimbal device supports a horizontal, forward looking position, stabilized </summary>
        HasNeutral = 2, 

        /// <summary> Gimbal device supports rotating around roll axis. </summary>
        HasRollAxis = 4, 

        /// <summary> Gimbal device supports to follow a roll angle relative to the vehicle </summary>
        HasRollFollow = 8, 

        /// <summary> Gimbal device supports locking to an roll angle (generally that's the default with roll stabilized) </summary>
        HasRollLock = 16, 

        /// <summary> Gimbal device supports rotating around pitch axis. </summary>
        HasPitchAxis = 32, 

        /// <summary> Gimbal device supports to follow a pitch angle relative to the vehicle </summary>
        HasPitchFollow = 64, 

        /// <summary> Gimbal device supports locking to an pitch angle (generally that's the default with pitch stabilized) </summary>
        HasPitchLock = 128, 

        /// <summary> Gimbal device supports rotating around yaw axis. </summary>
        HasYawAxis = 256, 

        /// <summary> Gimbal device supports to follow a yaw angle relative to the vehicle (generally that's the default) </summary>
        HasYawFollow = 512, 

        /// <summary> Gimbal device supports locking to an absolute heading (often this is an option available) </summary>
        HasYawLock = 1024, 

        /// <summary> Gimbal device supports yawing/panning infinetely (e.g. using slip disk). </summary>
        SupportsInfiniteYaw = 2048 };

    /// <summary>
    /// Gimbal manager high level capability flags (bitmap). The first 16 bits are identical to the GIMBAL_DEVICE_CAP_FLAGS. However, the gimbal manager does not need to copy the flags from the gimbal but can also enhance the capabilities and thus add flags.
    /// </summary>
    public enum GimbalManagerCapFlags { 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT. </summary>
        HasRetract = 1, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_NEUTRAL. </summary>
        HasNeutral = 2, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_AXIS. </summary>
        HasRollAxis = 4, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_FOLLOW. </summary>
        HasRollFollow = 8, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_LOCK. </summary>
        HasRollLock = 16, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_AXIS. </summary>
        HasPitchAxis = 32, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_FOLLOW. </summary>
        HasPitchFollow = 64, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_LOCK. </summary>
        HasPitchLock = 128, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_AXIS. </summary>
        HasYawAxis = 256, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_FOLLOW. </summary>
        HasYawFollow = 512, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_LOCK. </summary>
        HasYawLock = 1024, 

        /// <summary> Based on GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_INFINITE_YAW. </summary>
        SupportsInfiniteYaw = 2048, 

        /// <summary> Gimbal manager supports to point to a local position. </summary>
        CanPointLocationLocal = 65536, 

        /// <summary> Gimbal manager supports to point to a global latitude, longitude, altitude position. </summary>
        CanPointLocationGlobal = 131072 };

    /// <summary>
    /// Flags for gimbal device (lower level) operation.
    /// </summary>
    public enum GimbalDeviceFlags { 

        /// <summary> Set to retracted safe position (no stabilization), takes presedence over all other flags. </summary>
        Retract = 1, 

        /// <summary> Set to neutral position (horizontal, forward looking, with stabiliziation), takes presedence over all other flags except RETRACT. </summary>
        Neutral = 2, 

        /// <summary> Lock roll angle to absolute angle relative to horizon (not relative to drone). This is generally the default with a stabilizing gimbal. </summary>
        RollLock = 4, 

        /// <summary> Lock pitch angle to absolute angle relative to horizon (not relative to drone). This is generally the default. </summary>
        PitchLock = 8, 

        /// <summary> Lock yaw angle to absolute angle relative to North (not relative to drone). If this flag is set, the quaternion is in the Earth frame with the x-axis pointing North (yaw absolute). If this flag is not set, the quaternion frame is in the Earth frame rotated so that the x-axis is pointing forward (yaw relative to vehicle). </summary>
        YawLock = 16 };

    /// <summary>
    /// Flags for high level gimbal manager operation The first 16 bits are identical to the GIMBAL_DEVICE_FLAGS.
    /// </summary>
    public enum GimbalManagerFlags { 

        /// <summary> Based on GIMBAL_DEVICE_FLAGS_RETRACT </summary>
        Retract = 1, 

        /// <summary> Based on GIMBAL_DEVICE_FLAGS_NEUTRAL </summary>
        Neutral = 2, 

        /// <summary> Based on GIMBAL_DEVICE_FLAGS_ROLL_LOCK </summary>
        RollLock = 4, 

        /// <summary> Based on GIMBAL_DEVICE_FLAGS_PITCH_LOCK </summary>
        PitchLock = 8, 

        /// <summary> Based on GIMBAL_DEVICE_FLAGS_YAW_LOCK </summary>
        YawLock = 16 };

    /// <summary>
    /// Gimbal device (low level) error flags (bitmap, 0 means no error)
    /// </summary>
    public enum GimbalDeviceErrorFlags { 

        /// <summary> Gimbal device is limited by hardware roll limit. </summary>
        AtRollLimit = 1, 

        /// <summary> Gimbal device is limited by hardware pitch limit. </summary>
        AtPitchLimit = 2, 

        /// <summary> Gimbal device is limited by hardware yaw limit. </summary>
        AtYawLimit = 4, 

        /// <summary> There is an error with the gimbal encoders. </summary>
        EncoderError = 8, 

        /// <summary> There is an error with the gimbal power source. </summary>
        PowerError = 16, 

        /// <summary> There is an error with the gimbal motor's. </summary>
        MotorError = 32, 

        /// <summary> There is an error with the gimbal's software. </summary>
        SoftwareError = 64, 

        /// <summary> There is an error with the gimbal's communication. </summary>
        CommsError = 128, 

        /// <summary> Gimbal is currently calibrating. </summary>
        CalibrationRunning = 256 };

    /// <summary>
    /// Gripper actions.
    /// </summary>
    public enum GripperActions { 

        /// <summary> Gripper release cargo. </summary>
        GripperActionRelease = 0, 

        /// <summary> Gripper grab onto cargo. </summary>
        GripperActionGrab = 1 };

    /// <summary>
    /// Winch actions.
    /// </summary>
    public enum WinchActions { 

        /// <summary> Relax winch. </summary>
        WinchRelaxed = 0, 

        /// <summary> Wind or unwind specified length of cable, optionally using specified rate. </summary>
        WinchRelativeLengthControl = 1, 

        /// <summary> Wind or unwind cable at specified rate. </summary>
        WinchRateControl = 2 };

    /// <summary>
    /// Generalized UAVCAN node health
    /// </summary>
    public enum UavcanNodeHealth { 

        /// <summary> The node is functioning properly. </summary>
        Ok = 0, 

        /// <summary> A critical parameter went out of range or the node has encountered a minor failure. </summary>
        Warning = 1, 

        /// <summary> The node has encountered a major failure. </summary>
        Error = 2, 

        /// <summary> The node has suffered a fatal malfunction. </summary>
        Critical = 3 };

    /// <summary>
    /// Generalized UAVCAN node mode
    /// </summary>
    public enum UavcanNodeMode { 

        /// <summary> The node is performing its primary functions. </summary>
        Operational = 0, 

        /// <summary> The node is initializing; this mode is entered immediately after startup. </summary>
        Initialization = 1, 

        /// <summary> The node is under maintenance. </summary>
        Maintenance = 2, 

        /// <summary> The node is in the process of updating its software. </summary>
        SoftwareUpdate = 3, 

        /// <summary> The node is no longer available online. </summary>
        Offline = 7 };

    /// <summary>
    /// Indicates the ESC connection type.
    /// </summary>
    public enum EscConnectionType { 

        /// <summary> Traditional PPM ESC. </summary>
        Ppm = 0, 

        /// <summary> Serial Bus connected ESC. </summary>
        Serial = 1, 

        /// <summary> One Shot PPM ESC. </summary>
        Oneshot = 2, 

        /// <summary> I2C ESC. </summary>
        I2c = 3, 

        /// <summary> CAN-Bus ESC. </summary>
        Can = 4, 

        /// <summary> DShot ESC. </summary>
        Dshot = 5 };

    /// <summary>
    /// Flags to report ESC failures.
    /// </summary>
    public enum EscFailureFlags { 

        /// <summary> No ESC failure. </summary>
        EscFailureNone = 0, 

        /// <summary> Over current failure. </summary>
        EscFailureOverCurrent = 1, 

        /// <summary> Over voltage failure. </summary>
        EscFailureOverVoltage = 2, 

        /// <summary> Over temperature failure. </summary>
        EscFailureOverTemperature = 4, 

        /// <summary> Over RPM failure. </summary>
        EscFailureOverRpm = 8, 

        /// <summary> Inconsistent command failure i.e. out of bounds. </summary>
        EscFailureInconsistentCmd = 16, 

        /// <summary> Motor stuck failure. </summary>
        EscFailureMotorStuck = 32, 

        /// <summary> Generic ESC failure. </summary>
        EscFailureGeneric = 64 };

    /// <summary>
    /// Flags to indicate the status of camera storage.
    /// </summary>
    public enum StorageStatus { 

        /// <summary> Storage is missing (no microSD card loaded for example.) </summary>
        Empty = 0, 

        /// <summary> Storage present but unformatted. </summary>
        Unformatted = 1, 

        /// <summary> Storage present and ready. </summary>
        Ready = 2, 

        /// <summary> Camera does not supply storage status information. Capacity information in STORAGE_INFORMATION fields will be ignored. </summary>
        NotSupported = 3 };

    /// <summary>
    /// Flags to indicate the type of storage.
    /// </summary>
    public enum StorageType { 

        /// <summary> Storage type is not known. </summary>
        Unknown = 0, 

        /// <summary> Storage type is USB device. </summary>
        UsbStick = 1, 

        /// <summary> Storage type is SD card. </summary>
        Sd = 2, 

        /// <summary> Storage type is microSD card. </summary>
        Microsd = 3, 

        /// <summary> Storage type is CFast. </summary>
        Cf = 4, 

        /// <summary> Storage type is CFexpress. </summary>
        Cfe = 5, 

        /// <summary> Storage type is XQD. </summary>
        Xqd = 6, 

        /// <summary> Storage type is HD mass storage type. </summary>
        Hd = 7, 

        /// <summary> Storage type is other, not listed type. </summary>
        Other = 254 };

    /// <summary>
    /// Flags to indicate usage for a particular storage (see `STORAGE_INFORMATION.storage_usage` and `MAV_CMD_SET_STORAGE_USAGE`).
    /// </summary>
    public enum StorageUsageFlag { 

        /// <summary> Always set to 1 (indicates `STORAGE_INFORMATION.storage_usage` is supported). </summary>
        Set = 1, 

        /// <summary> Storage for saving photos. </summary>
        Photo = 2, 

        /// <summary> Storage for saving videos. </summary>
        Video = 4, 

        /// <summary> Storage for saving logs. </summary>
        Logs = 8 };

    /// <summary>
    /// Yaw behaviour during orbit flight.
    /// </summary>
    public enum OrbitYawBehaviour { 

        /// <summary> Vehicle front points to the center (default). </summary>
        HoldFrontToCircleCenter = 0, 

        /// <summary> Vehicle front holds heading when message received. </summary>
        HoldInitialHeading = 1, 

        /// <summary> Yaw uncontrolled. </summary>
        Uncontrolled = 2, 

        /// <summary> Vehicle front follows flight path (tangential to circle). </summary>
        HoldFrontTangentToCircle = 3, 

        /// <summary> Yaw controlled by RC input. </summary>
        RcControlled = 4 };

    /// <summary>
    /// Possible responses from a WIFI_CONFIG_AP message.
    /// </summary>
    public enum WifiConfigApResponse { 

        /// <summary> Undefined response. Likely an indicative of a system that doesn't support this request. </summary>
        Undefined = 0, 

        /// <summary> Changes accepted. </summary>
        Accepted = 1, 

        /// <summary> Changes rejected. </summary>
        Rejected = 2, 

        /// <summary> Invalid Mode. </summary>
        ModeError = 3, 

        /// <summary> Invalid SSID. </summary>
        SsidError = 4, 

        /// <summary> Invalid Password. </summary>
        PasswordError = 5 };

    /// <summary>
    /// Possible responses from a CELLULAR_CONFIG message.
    /// </summary>
    public enum CellularConfigResponse { 

        /// <summary> Changes accepted. </summary>
        Accepted = 0, 

        /// <summary> Invalid APN. </summary>
        ApnError = 1, 

        /// <summary> Invalid PIN. </summary>
        PinError = 2, 

        /// <summary> Changes rejected. </summary>
        Rejected = 3, 

        /// <summary> PUK is required to unblock SIM card. </summary>
        CellularConfigBlockedPukRequired = 4 };

    /// <summary>
    /// WiFi Mode.
    /// </summary>
    public enum WifiConfigApMode { 

        /// <summary> WiFi mode is undefined. </summary>
        Undefined = 0, 

        /// <summary> WiFi configured as an access point. </summary>
        Ap = 1, 

        /// <summary> WiFi configured as a station connected to an existing local WiFi network. </summary>
        Station = 2, 

        /// <summary> WiFi disabled. </summary>
        Disabled = 3 };

    /// <summary>
    /// Supported component metadata types. These are used in the 'general' metadata file returned by COMPONENT_INFORMATION to provide information about supported metadata types. The types are not used directly in MAVLink messages.
    /// </summary>
    public enum CompMetadataType { 

        /// <summary> General information about the component. General metadata includes information about other COMP_METADATA_TYPEs supported by the component. This type must be supported and must be downloadable from vehicle. </summary>
        General = 0, 

        /// <summary> Parameter meta data. </summary>
        Parameter = 1, 

        /// <summary> Meta data that specifies which commands and command parameters the vehicle supports. (WIP) </summary>
        Commands = 2, 

        /// <summary> Meta data that specifies external non-MAVLink peripherals. </summary>
        Peripherals = 3, 

        /// <summary> Meta data for the events interface. </summary>
        Events = 4 };

    /// <summary>
    /// Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data. NaN and INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current yaw or latitude rather than a specific value). See https://mavlink.io/en/guide/xml_schema.html#MAV_CMD for information about the structure of the MAV_CMD entries
    /// </summary>
    public enum MavCmd { 

        /// <summary> Navigate to waypoint. </summary>
        NavWaypoint = 16, 

        /// <summary> Loiter around this waypoint an unlimited amount of time </summary>
        NavLoiterUnlim = 17, 

        /// <summary> Loiter around this waypoint for X turns </summary>
        NavLoiterTurns = 18, 

        /// <summary> Loiter at the specified latitude, longitude and altitude for a certain amount of time. Multicopter vehicles stop at the point (within a vehicle-specific acceptance radius). Forward-only moving vehicles (e.g. fixed-wing) circle the point with the specified radius/direction. If the Heading Required parameter (2) is non-zero forward moving aircraft will only leave the loiter circle once heading towards the next waypoint. </summary>
        NavLoiterTime = 19, 

        /// <summary> Return to launch location </summary>
        NavReturnToLaunch = 20, 

        /// <summary> Land at location. </summary>
        NavLand = 21, 

        /// <summary> Takeoff from ground / hand. Vehicles that support multiple takeoff modes (e.g. VTOL quadplane) should take off using the currently configured mode. </summary>
        NavTakeoff = 22, 

        /// <summary> Land at local position (local frame only) </summary>
        NavLandLocal = 23, 

        /// <summary> Takeoff from local position (local frame only) </summary>
        NavTakeoffLocal = 24, 

        /// <summary> Vehicle following, i.e. this waypoint represents the position of a moving vehicle </summary>
        NavFollow = 25, 

        /// <summary> Continue on the current course and climb/descend to specified altitude.  When the altitude is reached continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached. </summary>
        NavContinueAndChangeAlt = 30, 

        /// <summary> Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.  Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached. Additionally, if the Heading Required parameter is non-zero the aircraft will not leave the loiter until heading toward the next waypoint. </summary>
        NavLoiterToAlt = 31, 

        /// <summary> Begin following a target </summary>
        DoFollow = 32, 

        /// <summary> Reposition the MAV after a follow target command has been sent </summary>
        DoFollowReposition = 33, 

        /// <summary> Start orbiting on the circumference of a circle defined by the parameters. Setting values to NaN/INT32_MAX (as appropriate) results in using defaults. </summary>
        DoOrbit = 34, 

        /// <summary> Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. </summary>
        NavRoi = 80, 

        /// <summary> Control autonomous path planning on the MAV. </summary>
        NavPathplanning = 81, 

        /// <summary> Navigate to waypoint using a spline path. </summary>
        NavSplineWaypoint = 82, 

        /// <summary> Takeoff from ground using VTOL mode, and transition to forward flight with specified heading. The command should be ignored by vehicles that dont support both VTOL and fixed-wing flight (multicopters, boats,etc.). </summary>
        NavVtolTakeoff = 84, 

        /// <summary> Land using VTOL mode </summary>
        NavVtolLand = 85, 

        /// <summary> hand control over to an external controller </summary>
        NavGuidedEnable = 92, 

        /// <summary> Delay the next navigation command a number of seconds or until a specified time </summary>
        NavDelay = 93, 

        /// <summary> Descend and place payload. Vehicle moves to specified location, descends until it detects a hanging payload has reached the ground, and then releases the payload. If ground is not detected before the reaching the maximum descent value (param1), the command will complete without releasing the payload. </summary>
        NavPayloadPlace = 94, 

        /// <summary> NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeration </summary>
        NavLast = 95, 

        /// <summary> Delay mission state machine. </summary>
        ConditionDelay = 112, 

        /// <summary> Ascend/descend to target altitude at specified rate. Delay mission state machine until desired altitude reached. </summary>
        ConditionChangeAlt = 113, 

        /// <summary> Delay mission state machine until within desired distance of next NAV point. </summary>
        ConditionDistance = 114, 

        /// <summary> Reach a certain target angle. </summary>
        ConditionYaw = 115, 

        /// <summary> NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeration </summary>
        ConditionLast = 159, 

        /// <summary> Set system mode. </summary>
        DoSetMode = 176, 

        /// <summary> Jump to the desired command in the mission list.  Repeat this action only the specified number of times </summary>
        DoJump = 177, 

        /// <summary> Change speed and/or throttle set points. </summary>
        DoChangeSpeed = 178, 

        /// <summary> Changes the home location either to the current location or a specified location. </summary>
        DoSetHome = 179, 

        /// <summary> Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value of the parameter. </summary>
        DoSetParameter = 180, 

        /// <summary> Set a relay to a condition. </summary>
        DoSetRelay = 181, 

        /// <summary> Cycle a relay on and off for a desired number of cycles with a desired period. </summary>
        DoRepeatRelay = 182, 

        /// <summary> Set a servo to a desired PWM value. </summary>
        DoSetServo = 183, 

        /// <summary> Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period. </summary>
        DoRepeatServo = 184, 

        /// <summary> Terminate flight immediately </summary>
        DoFlighttermination = 185, 

        /// <summary> Change altitude set point. </summary>
        DoChangeAltitude = 186, 

        /// <summary> Sets actuators (e.g. servos) to a desired value. The actuator numbers are mapped to specific outputs (e.g. on any MAIN or AUX PWM or UAVCAN) using a flight-stack specific mechanism (i.e. a parameter). </summary>
        DoSetActuator = 187, 

        /// <summary> Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will be used. The Latitude/Longitude is optional, and may be set to 0 if not needed. If specified then it will be used to help find the closest landing sequence. </summary>
        DoLandStart = 189, 

        /// <summary> Mission command to perform a landing from a rally point. </summary>
        DoRallyLand = 190, 

        /// <summary> Mission command to safely abort an autonomous landing. </summary>
        DoGoAround = 191, 

        /// <summary> Reposition the vehicle to a specific WGS84 global position. </summary>
        DoReposition = 192, 

        /// <summary> If in a GPS controlled position mode, hold the current position or continue. </summary>
        DoPauseContinue = 193, 

        /// <summary> Set moving direction to forward or reverse. </summary>
        DoSetReverse = 194, 

        /// <summary> Sets the region of interest (ROI) to a location. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal is not to react to this message. </summary>
        DoSetRoiLocation = 195, 

        /// <summary> Sets the region of interest (ROI) to be toward next waypoint, with optional pitch/roll/yaw offset. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message. </summary>
        DoSetRoiWpnextOffset = 196, 

        /// <summary> Cancels any previous ROI command returning the vehicle/sensors to default flight characteristics. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message. After this command the gimbal manager should go back to manual input if available, and otherwise assume a neutral position. </summary>
        DoSetRoiNone = 197, 

        /// <summary> Mount tracks system with specified system ID. Determination of target vehicle position may be done with GLOBAL_POSITION_INT or any other means. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message. </summary>
        DoSetRoiSysid = 198, 

        /// <summary> Control onboard camera system. </summary>
        DoControlVideo = 200, 

        /// <summary> Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. </summary>
        DoSetRoi = 201, 

        /// <summary> Configure digital camera. This is a fallback message for systems that have not yet implemented PARAM_EXT_XXX messages and camera definition files (see https://mavlink.io/en/services/camera_def.html ). </summary>
        DoDigicamConfigure = 202, 

        /// <summary> Control digital camera. This is a fallback message for systems that have not yet implemented PARAM_EXT_XXX messages and camera definition files (see https://mavlink.io/en/services/camera_def.html ). </summary>
        DoDigicamControl = 203, 

        /// <summary> Mission command to configure a camera or antenna mount </summary>
        DoMountConfigure = 204, 

        /// <summary> Mission command to control a camera or antenna mount </summary>
        DoMountControl = 205, 

        /// <summary> Mission command to set camera trigger distance for this flight. The camera is triggered each time this distance is exceeded. This command can also be used to set the shutter integration time for the camera. </summary>
        DoSetCamTriggDist = 206, 

        /// <summary> Mission command to enable the geofence </summary>
        DoFenceEnable = 207, 

        /// <summary> Mission item/command to release a parachute or enable/disable auto release. </summary>
        DoParachute = 208, 

        /// <summary> Command to perform motor test. </summary>
        DoMotorTest = 209, 

        /// <summary> Change to/from inverted flight. </summary>
        DoInvertedFlight = 210, 

        /// <summary> Mission command to operate a gripper. </summary>
        DoGripper = 211, 

        /// <summary> Enable/disable autotune. </summary>
        DoAutotuneEnable = 212, 

        /// <summary> Sets a desired vehicle turn angle and speed change. </summary>
        NavSetYawSpeed = 213, 

        /// <summary> Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is triggered each time this interval expires. This command can also be used to set the shutter integration time for the camera. </summary>
        DoSetCamTriggInterval = 214, 

        /// <summary> Mission command to control a camera or antenna mount, using a quaternion as reference. </summary>
        DoMountControlQuat = 220, 

        /// <summary> set id of master controller </summary>
        DoGuidedMaster = 221, 

        /// <summary> Set limits for external control </summary>
        DoGuidedLimits = 222, 

        /// <summary> Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine state. It is intended for vehicles with internal combustion engines </summary>
        DoEngineControl = 223, 

        /// <summary> Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between). </summary>
        DoSetMissionCurrent = 224, 

        /// <summary> NOP - This command is only used to mark the upper limit of the DO commands in the enumeration </summary>
        DoLast = 240, 

        /// <summary> Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature Calibration, only one sensor should be set in a single message and all others should be zero. </summary>
        PreflightCalibration = 241, 

        /// <summary> Set sensor offsets. This command will be only accepted if in pre-flight mode. </summary>
        PreflightSetSensorOffsets = 242, 

        /// <summary> Trigger UAVCAN configuration (actuator ID assignment and direction mapping). Note that this maps to the legacy UAVCAN v0 function UAVCAN_ENUMERATE, which is intended to be executed just once during initial vehicle configuration (it is not a normal pre-flight command and has been poorly named). </summary>
        PreflightUavcan = 243, 

        /// <summary> Request storage of different parameter values and logs. This command will be only accepted if in pre-flight mode. </summary>
        PreflightStorage = 245, 

        /// <summary> Request the reboot or shutdown of system components. </summary>
        PreflightRebootShutdown = 246, 

        /// <summary> Override current mission with command to pause mission, pause mission and move to position, continue/resume mission. When param 1 indicates that the mission is paused (MAV_GOTO_DO_HOLD), param 2 defines whether it holds in place or moves to another position. </summary>
        OverrideGoto = 252, 

        /// <summary> Mission command to set a Camera Auto Mount Pivoting Oblique Survey (Replaces CAM_TRIGG_DIST for this purpose). The camera is triggered each time this distance is exceeded, then the mount moves to the next position. Params 4~6 set-up the angle limits and number of positions for oblique survey, where mount-enabled vehicles automatically roll the camera between shots to emulate an oblique camera setup (providing an increased HFOV). This command can also be used to set the shutter integration time for the camera. </summary>
        ObliqueSurvey = 260, 

        /// <summary> start running a mission </summary>
        MissionStart = 300, 

        /// <summary> Arms / Disarms a component </summary>
        ComponentArmDisarm = 400, 

        /// <summary> Instructs system to run pre-arm checks. This command should return MAV_RESULT_TEMPORARILY_REJECTED in the case the system is armed, otherwise MAV_RESULT_ACCEPTED. Note that the return value from executing this command does not indicate whether the vehicle is armable or not, just whether the system has successfully run/is currently running the checks.  The result of the checks is reflected in the SYS_STATUS message. </summary>
        RunPrearmChecks = 401, 

        /// <summary> Turns illuminators ON/OFF. An illuminator is a light source that is used for lighting up dark areas external to the sytstem: e.g. a torch or searchlight (as opposed to a light source for illuminating the system itself, e.g. an indicator light). </summary>
        IlluminatorOnOff = 405, 

        /// <summary> Request the home position from the vehicle. </summary>
        GetHomePosition = 410, 

        /// <summary> Inject artificial failure for testing purposes. Note that autopilots should implement an additional protection before accepting this command such as a specific param setting. </summary>
        InjectFailure = 420, 

        /// <summary> Starts receiver pairing. </summary>
        StartRxPair = 500, 

        /// <summary> Request the interval between messages for a particular MAVLink message ID. The receiver should ACK the command and then emit its response in a MESSAGE_INTERVAL message. </summary>
        GetMessageInterval = 510, 

        /// <summary> Set the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREAM. </summary>
        SetMessageInterval = 511, 

        /// <summary> Request the target system(s) emit a single instance of a specified message (i.e. a 'one-shot' version of MAV_CMD_SET_MESSAGE_INTERVAL). </summary>
        RequestMessage = 512, 

        /// <summary> Request MAVLink protocol version compatibility. All receivers should ACK the command and then emit their capabilities in an PROTOCOL_VERSION message </summary>
        RequestProtocolVersion = 519, 

        /// <summary> Request autopilot capabilities. The receiver should ACK the command and then emit its capabilities in an AUTOPILOT_VERSION message </summary>
        RequestAutopilotCapabilities = 520, 

        /// <summary> Request camera information (CAMERA_INFORMATION). </summary>
        RequestCameraInformation = 521, 

        /// <summary> Request camera settings (CAMERA_SETTINGS). </summary>
        RequestCameraSettings = 522, 

        /// <summary> Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a specific component's storage. </summary>
        RequestStorageInformation = 525, 

        /// <summary> Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the command's target_component to target a specific component's storage. </summary>
        StorageFormat = 526, 

        /// <summary> Request camera capture status (CAMERA_CAPTURE_STATUS) </summary>
        RequestCameraCaptureStatus = 527, 

        /// <summary> Request flight information (FLIGHT_INFORMATION) </summary>
        RequestFlightInformation = 528, 

        /// <summary> Reset all camera settings to Factory Default </summary>
        ResetCameraSettings = 529, 

        /// <summary> Set camera running mode. Use NaN for reserved values. GCS will send a MAV_CMD_REQUEST_VIDEO_STREAM_STATUS command after a mode change if the camera supports video streaming. </summary>
        SetCameraMode = 530, 

        /// <summary> Set camera zoom. Camera must respond with a CAMERA_SETTINGS message (on success). </summary>
        SetCameraZoom = 531, 

        /// <summary> Set camera focus. Camera must respond with a CAMERA_SETTINGS message (on success). </summary>
        SetCameraFocus = 532, 

        /// <summary> Set that a particular storage is the preferred location for saving photos, videos, and/or other media (e.g. to set that an SD card is used for storing videos).           There can only be one preferred save location for each particular media type: setting a media usage flag will clear/reset that same flag if set on any other storage.           If no flag is set the system should use its default storage.           A target system can choose to always use default storage, in which case it should ACK the command with MAV_RESULT_UNSUPPORTED.           A target system can choose to not allow a particular storage to be set as preferred storage, in which case it should ACK the command with MAV_RESULT_DENIED. </summary>
        SetStorageUsage = 533, 

        /// <summary> Tagged jump target. Can be jumped to with MAV_CMD_DO_JUMP_TAG. </summary>
        JumpTag = 600, 

        /// <summary> Jump to the matching tag in the mission list. Repeat this action for the specified number of times. A mission should contain a single matching tag for each jump. If this is not the case then a jump to a missing tag should complete the mission, and a jump where there are multiple matching tags should always select the one with the lowest mission sequence number. </summary>
        DoJumpTag = 601, 

        /// <summary> High level setpoint to be sent to a gimbal manager to set a gimbal attitude. It is possible to set combinations of the values below. E.g. an angle as well as a desired angular rate can be used to get to this angle at a certain angular rate, or an angular rate only will result in continuous turning. NaN is to be used to signal unset. Note: a gimbal is never to react to this command but only the gimbal manager. </summary>
        DoGimbalManagerPitchyaw = 1000, 

        /// <summary> Gimbal configuration to set which sysid/compid is in primary and secondary control. </summary>
        DoGimbalManagerConfigure = 1001, 

        /// <summary> Start image capture sequence. Sends CAMERA_IMAGE_CAPTURED after each capture. Use NaN for reserved values. </summary>
        ImageStartCapture = 2000, 

        /// <summary> Stop image capture sequence Use NaN for reserved values. </summary>
        ImageStopCapture = 2001, 

        /// <summary> Re-request a CAMERA_IMAGE_CAPTURED message. </summary>
        RequestCameraImageCapture = 2002, 

        /// <summary> Enable or disable on-board camera triggering system. </summary>
        DoTriggerControl = 2003, 

        /// <summary> If the camera supports point visual tracking (CAMERA_CAP_FLAGS_HAS_TRACKING_POINT is set), this command allows to initiate the tracking. </summary>
        CameraTrackPoint = 2004, 

        /// <summary> If the camera supports rectangle visual tracking (CAMERA_CAP_FLAGS_HAS_TRACKING_RECTANGLE is set), this command allows to initiate the tracking. </summary>
        CameraTrackRectangle = 2005, 

        /// <summary> Stops ongoing tracking. </summary>
        CameraStopTracking = 2010, 

        /// <summary> Starts video capture (recording). </summary>
        VideoStartCapture = 2500, 

        /// <summary> Stop the current video capture (recording). </summary>
        VideoStopCapture = 2501, 

        /// <summary> Start video streaming </summary>
        VideoStartStreaming = 2502, 

        /// <summary> Stop the given video stream </summary>
        VideoStopStreaming = 2503, 

        /// <summary> Request video stream information (VIDEO_STREAM_INFORMATION) </summary>
        RequestVideoStreamInformation = 2504, 

        /// <summary> Request video stream status (VIDEO_STREAM_STATUS) </summary>
        RequestVideoStreamStatus = 2505, 

        /// <summary> Request to start streaming logging data over MAVLink (see also LOGGING_DATA message) </summary>
        LoggingStart = 2510, 

        /// <summary> Request to stop streaming log data over MAVLink </summary>
        LoggingStop = 2511, 

        /// <summary>  </summary>
        AirframeConfiguration = 2520, 

        /// <summary> Request to start/stop transmitting over the high latency telemetry </summary>
        ControlHighLatency = 2600, 

        /// <summary> Create a panorama at the current position </summary>
        PanoramaCreate = 2800, 

        /// <summary> Request VTOL transition </summary>
        DoVtolTransition = 3000, 

        /// <summary> Request authorization to arm the vehicle to a external entity, the arm authorizer is responsible to request all data that is needs from the vehicle before authorize or deny the request. If approved the progress of command_ack message should be set with period of time that this authorization is valid in seconds or in case it was denied it should be set with one of the reasons in ARM_AUTH_DENIED_REASON.          </summary>
        ArmAuthorizationRequest = 3001, 

        /// <summary> This command sets the submode to standard guided when vehicle is in guided mode. The vehicle holds position and altitude and the user can input the desired velocities along all three axes.                    </summary>
        SetGuidedSubmodeStandard = 4000, 

        /// <summary> This command sets submode circle when vehicle is in guided mode. Vehicle flies along a circle facing the center of the circle. The user can input the velocity along the circle and change the radius. If no input is given the vehicle will hold position.                    </summary>
        SetGuidedSubmodeCircle = 4001, 

        /// <summary> Delay mission state machine until gate has been reached. </summary>
        ConditionGate = 4501, 

        /// <summary> Fence return point (there can only be one such point in a geofence definition). If rally points are supported they should be used instead. </summary>
        NavFenceReturnPoint = 5000, 

        /// <summary> Fence vertex for an inclusion polygon (the polygon must not be self-intersecting). The vehicle must stay within this area. Minimum of 3 vertices required.          </summary>
        NavFencePolygonVertexInclusion = 5001, 

        /// <summary> Fence vertex for an exclusion polygon (the polygon must not be self-intersecting). The vehicle must stay outside this area. Minimum of 3 vertices required.          </summary>
        NavFencePolygonVertexExclusion = 5002, 

        /// <summary> Circular fence area. The vehicle must stay inside this area.          </summary>
        NavFenceCircleInclusion = 5003, 

        /// <summary> Circular fence area. The vehicle must stay outside this area.          </summary>
        NavFenceCircleExclusion = 5004, 

        /// <summary> Rally point. You can have multiple rally points defined.          </summary>
        NavRallyPoint = 5100, 

        /// <summary> Commands the vehicle to respond with a sequence of messages UAVCAN_NODE_INFO, one message per every UAVCAN node that is online. Note that some of the response messages can be lost, which the receiver can detect easily by checking whether every received UAVCAN_NODE_STATUS has a matching message UAVCAN_NODE_INFO received earlier; if not, this command should be sent again in order to request re-transmission of the node information messages. </summary>
        UavcanGetNodeInfo = 5200, 

        /// <summary> Trigger the start of an ADSB-out IDENT. This should only be used when requested to do so by an Air Traffic Controller in controlled airspace. This starts the IDENT which is then typically held for 18 seconds by the hardware per the Mode A, C, and S transponder spec. </summary>
        DoAdsbOutIdent = 10001, 

        /// <summary> Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release position and velocity. </summary>
        PayloadPrepareDeploy = 30001, 

        /// <summary> Control the payload deployment. </summary>
        PayloadControlDeploy = 30002, 

        /// <summary> Magnetometer calibration based on provided known yaw. This allows for fast calibration using WMM field tables in the vehicle, given only the known yaw of the vehicle. If Latitude and longitude are both zero then use the current vehicle location. </summary>
        FixedMagCalYaw = 42006, 

        /// <summary> Command to operate winch. </summary>
        DoWinch = 42600, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser1 = 31000, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser2 = 31001, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser3 = 31002, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser4 = 31003, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser5 = 31004, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser1 = 31005, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser2 = 31006, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser3 = 31007, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser4 = 31008, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser5 = 31009, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User1 = 31010, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User2 = 31011, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User3 = 31012, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User4 = 31013, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User5 = 31014 };

    /// <summary>
    /// A data stream is not a fixed set of messages, but rather a      recommendation to the autopilot software. Individual autopilots may or may not obey      the recommended messages.
    /// </summary>
    public enum MavDataStream { 

        /// <summary> Enable all data streams </summary>
        All = 0, 

        /// <summary> Enable IMU_RAW, GPS_RAW, GPS_STATUS packets. </summary>
        RawSensors = 1, 

        /// <summary> Enable GPS_STATUS, CONTROL_STATUS, AUX_STATUS </summary>
        ExtendedStatus = 2, 

        /// <summary> Enable RC_CHANNELS_SCALED, RC_CHANNELS_RAW, SERVO_OUTPUT_RAW </summary>
        RcChannels = 3, 

        /// <summary> Enable ATTITUDE_CONTROLLER_OUTPUT, POSITION_CONTROLLER_OUTPUT, NAV_CONTROLLER_OUTPUT. </summary>
        RawController = 4, 

        /// <summary> Enable LOCAL_POSITION, GLOBAL_POSITION_INT messages. </summary>
        Position = 6, 

        /// <summary> Dependent on the autopilot </summary>
        Extra1 = 10, 

        /// <summary> Dependent on the autopilot </summary>
        Extra2 = 11, 

        /// <summary> Dependent on the autopilot </summary>
        Extra3 = 12 };

    /// <summary>
    /// The ROI (region of interest) for the vehicle. This can be                 be used by the vehicle for camera/vehicle attitude alignment (see                 MAV_CMD_NAV_ROI).
    /// </summary>
    public enum MavRoi { 

        /// <summary> No region of interest. </summary>
        None = 0, 

        /// <summary> Point toward next waypoint, with optional pitch/roll/yaw offset. </summary>
        Wpnext = 1, 

        /// <summary> Point toward given waypoint. </summary>
        Wpindex = 2, 

        /// <summary> Point toward fixed location. </summary>
        Location = 3, 

        /// <summary> Point toward of given id. </summary>
        Target = 4 };

    /// <summary>
    /// ACK / NACK / ERROR values as a result of MAV_CMDs and for mission item transmission.
    /// </summary>
    public enum MavCmdAck { 

        /// <summary> Command / mission item is ok. </summary>
        Ok = 0, 

        /// <summary> Generic error message if none of the other reasons fails or if no detailed error reporting is implemented. </summary>
        ErrFail = 1, 

        /// <summary> The system is refusing to accept this command from this source / communication partner. </summary>
        ErrAccessDenied = 2, 

        /// <summary> Command or mission item is not supported, other commands would be accepted. </summary>
        ErrNotSupported = 3, 

        /// <summary> The coordinate frame of this command / mission item is not supported. </summary>
        ErrCoordinateFrameNotSupported = 4, 

        /// <summary> The coordinate frame of this command is ok, but he coordinate values exceed the safety limits of this system. This is a generic error, please use the more specific error messages below if possible. </summary>
        ErrCoordinatesOutOfRange = 5, 

        /// <summary> The X or latitude value is out of range. </summary>
        ErrXLatOutOfRange = 6, 

        /// <summary> The Y or longitude value is out of range. </summary>
        ErrYLonOutOfRange = 7, 

        /// <summary> The Z or altitude value is out of range. </summary>
        ErrZAltOutOfRange = 8 };

    /// <summary>
    /// Specifies the datatype of a MAVLink parameter.
    /// </summary>
    public enum MavParamType { 

        /// <summary> 8-bit unsigned integer </summary>
        Uint8 = 1, 

        /// <summary> 8-bit signed integer </summary>
        Int8 = 2, 

        /// <summary> 16-bit unsigned integer </summary>
        Uint16 = 3, 

        /// <summary> 16-bit signed integer </summary>
        Int16 = 4, 

        /// <summary> 32-bit unsigned integer </summary>
        Uint32 = 5, 

        /// <summary> 32-bit signed integer </summary>
        Int32 = 6, 

        /// <summary> 64-bit unsigned integer </summary>
        Uint64 = 7, 

        /// <summary> 64-bit signed integer </summary>
        Int64 = 8, 

        /// <summary> 32-bit floating-point </summary>
        Real32 = 9, 

        /// <summary> 64-bit floating-point </summary>
        Real64 = 10 };

    /// <summary>
    /// Specifies the datatype of a MAVLink extended parameter.
    /// </summary>
    public enum MavParamExtType { 

        /// <summary> 8-bit unsigned integer </summary>
        Uint8 = 1, 

        /// <summary> 8-bit signed integer </summary>
        Int8 = 2, 

        /// <summary> 16-bit unsigned integer </summary>
        Uint16 = 3, 

        /// <summary> 16-bit signed integer </summary>
        Int16 = 4, 

        /// <summary> 32-bit unsigned integer </summary>
        Uint32 = 5, 

        /// <summary> 32-bit signed integer </summary>
        Int32 = 6, 

        /// <summary> 64-bit unsigned integer </summary>
        Uint64 = 7, 

        /// <summary> 64-bit signed integer </summary>
        Int64 = 8, 

        /// <summary> 32-bit floating-point </summary>
        Real32 = 9, 

        /// <summary> 64-bit floating-point </summary>
        Real64 = 10, 

        /// <summary> Custom Type </summary>
        Custom = 11 };

    /// <summary>
    /// Result from a MAVLink command (MAV_CMD)
    /// </summary>
    public enum MavResult { 

        /// <summary> Command is valid (is supported and has valid parameters), and was executed. </summary>
        Accepted = 0, 

        /// <summary> Command is valid, but cannot be executed at this time. This is used to indicate a problem that should be fixed just by waiting (e.g. a state machine is busy, can't arm because have not got GPS lock, etc.). Retrying later should work. </summary>
        TemporarilyRejected = 1, 

        /// <summary> Command is invalid (is supported but has invalid parameters). Retrying same command and parameters will not work. </summary>
        Denied = 2, 

        /// <summary> Command is not supported (unknown). </summary>
        Unsupported = 3, 

        /// <summary> Command is valid, but execution has failed. This is used to indicate any non-temporary or unexpected problem, i.e. any problem that must be fixed before the command can succeed/be retried. For example, attempting to write a file when out of memory, attempting to arm when sensors are not calibrated, etc. </summary>
        Failed = 4, 

        /// <summary> Command is valid and is being executed. This will be followed by further progress updates, i.e. the component may send further COMMAND_ACK messages with result MAV_RESULT_IN_PROGRESS (at a rate decided by the implementation), and must terminate by sending a COMMAND_ACK message with final result of the operation. The COMMAND_ACK.progress field can be used to indicate the progress of the operation. </summary>
        InProgress = 5, 

        /// <summary> Command has been cancelled (as a result of receiving a COMMAND_CANCEL message). </summary>
        Cancelled = 6 };

    /// <summary>
    /// Result of mission operation (in a MISSION_ACK message).
    /// </summary>
    public enum MavMissionResult { 

        /// <summary> mission accepted OK </summary>
        MavMissionAccepted = 0, 

        /// <summary> Generic error / not accepting mission commands at all right now. </summary>
        MavMissionError = 1, 

        /// <summary> Coordinate frame is not supported. </summary>
        MavMissionUnsupportedFrame = 2, 

        /// <summary> Command is not supported. </summary>
        MavMissionUnsupported = 3, 

        /// <summary> Mission items exceed storage space. </summary>
        MavMissionNoSpace = 4, 

        /// <summary> One of the parameters has an invalid value. </summary>
        MavMissionInvalid = 5, 

        /// <summary> param1 has an invalid value. </summary>
        MavMissionInvalidParam1 = 6, 

        /// <summary> param2 has an invalid value. </summary>
        MavMissionInvalidParam2 = 7, 

        /// <summary> param3 has an invalid value. </summary>
        MavMissionInvalidParam3 = 8, 

        /// <summary> param4 has an invalid value. </summary>
        MavMissionInvalidParam4 = 9, 

        /// <summary> x / param5 has an invalid value. </summary>
        MavMissionInvalidParam5X = 10, 

        /// <summary> y / param6 has an invalid value. </summary>
        MavMissionInvalidParam6Y = 11, 

        /// <summary> z / param7 has an invalid value. </summary>
        MavMissionInvalidParam7 = 12, 

        /// <summary> Mission item received out of sequence </summary>
        MavMissionInvalidSequence = 13, 

        /// <summary> Not accepting any mission commands from this communication partner. </summary>
        MavMissionDenied = 14, 

        /// <summary> Current mission operation cancelled (e.g. mission upload, mission download). </summary>
        MavMissionOperationCancelled = 15 };

    /// <summary>
    /// Indicates the severity level, generally used for status messages to indicate their relative urgency. Based on RFC-5424 using expanded definitions at: http://www.kiwisyslog.com/kb/info:-syslog-message-levels/.
    /// </summary>
    public enum MavSeverity { 

        /// <summary> System is unusable. This is a 'panic' condition. </summary>
        Emergency = 0, 

        /// <summary> Action should be taken immediately. Indicates error in non-critical systems. </summary>
        Alert = 1, 

        /// <summary> Action must be taken immediately. Indicates failure in a primary system. </summary>
        Critical = 2, 

        /// <summary> Indicates an error in secondary/redundant systems. </summary>
        Error = 3, 

        /// <summary> Indicates about a possible future error if this is not resolved within a given timeframe. Example would be a low battery warning. </summary>
        Warning = 4, 

        /// <summary> An unusual event has occurred, though not an error condition. This should be investigated for the root cause. </summary>
        Notice = 5, 

        /// <summary> Normal operational messages. Useful for logging. No action is required for these messages. </summary>
        Info = 6, 

        /// <summary> Useful non-operational messages that can assist in debugging. These should not occur during normal operation. </summary>
        Debug = 7 };

    /// <summary>
    /// Power supply status flags (bitmask)
    /// </summary>
    public enum MavPowerStatus { 

        /// <summary> main brick power supply valid </summary>
        BrickValid = 1, 

        /// <summary> main servo power supply valid for FMU </summary>
        ServoValid = 2, 

        /// <summary> USB power is connected </summary>
        UsbConnected = 4, 

        /// <summary> peripheral supply is in over-current state </summary>
        PeriphOvercurrent = 8, 

        /// <summary> hi-power peripheral supply is in over-current state </summary>
        PeriphHipowerOvercurrent = 16, 

        /// <summary> Power status has changed since boot </summary>
        Changed = 32 };

    /// <summary>
    /// SERIAL_CONTROL device types
    /// </summary>
    public enum SerialControlDev { 

        /// <summary> First telemetry port </summary>
        Telem1 = 0, 

        /// <summary> Second telemetry port </summary>
        Telem2 = 1, 

        /// <summary> First GPS port </summary>
        Gps1 = 2, 

        /// <summary> Second GPS port </summary>
        Gps2 = 3, 

        /// <summary> system shell </summary>
        Shell = 10, 

        /// <summary> SERIAL0 </summary>
        SerialControlSerial0 = 100, 

        /// <summary> SERIAL1 </summary>
        SerialControlSerial1 = 101, 

        /// <summary> SERIAL2 </summary>
        SerialControlSerial2 = 102, 

        /// <summary> SERIAL3 </summary>
        SerialControlSerial3 = 103, 

        /// <summary> SERIAL4 </summary>
        SerialControlSerial4 = 104, 

        /// <summary> SERIAL5 </summary>
        SerialControlSerial5 = 105, 

        /// <summary> SERIAL6 </summary>
        SerialControlSerial6 = 106, 

        /// <summary> SERIAL7 </summary>
        SerialControlSerial7 = 107, 

        /// <summary> SERIAL8 </summary>
        SerialControlSerial8 = 108, 

        /// <summary> SERIAL9 </summary>
        SerialControlSerial9 = 109 };

    /// <summary>
    /// SERIAL_CONTROL flags (bitmask)
    /// </summary>
    public enum SerialControlFlag { 

        /// <summary> Set if this is a reply </summary>
        Reply = 1, 

        /// <summary> Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message </summary>
        Respond = 2, 

        /// <summary> Set if access to the serial port should be removed from whatever driver is currently using it, giving exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without this flag set </summary>
        Exclusive = 4, 

        /// <summary> Block on writes to the serial port </summary>
        Blocking = 8, 

        /// <summary> Send multiple replies until port is drained </summary>
        Multi = 16 };

    /// <summary>
    /// Enumeration of distance sensor types
    /// </summary>
    public enum MavDistanceSensor { 

        /// <summary> Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units </summary>
        Laser = 0, 

        /// <summary> Ultrasound rangefinder, e.g. MaxBotix units </summary>
        Ultrasound = 1, 

        /// <summary> Infrared rangefinder, e.g. Sharp units </summary>
        Infrared = 2, 

        /// <summary> Radar type, e.g. uLanding units </summary>
        Radar = 3, 

        /// <summary> Broken or unknown type, e.g. analog units </summary>
        Unknown = 4 };

    /// <summary>
    /// Enumeration of sensor orientation, according to its rotations
    /// </summary>
    public enum MavSensorOrientation { 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 0 </summary>
        MavSensorRotationNone = 0, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 45 </summary>
        MavSensorRotationYaw45 = 1, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 90 </summary>
        MavSensorRotationYaw90 = 2, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 135 </summary>
        MavSensorRotationYaw135 = 3, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 180 </summary>
        MavSensorRotationYaw180 = 4, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 225 </summary>
        MavSensorRotationYaw225 = 5, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 270 </summary>
        MavSensorRotationYaw270 = 6, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 315 </summary>
        MavSensorRotationYaw315 = 7, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 0 </summary>
        MavSensorRotationRoll180 = 8, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 45 </summary>
        MavSensorRotationRoll180Yaw45 = 9, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 90 </summary>
        MavSensorRotationRoll180Yaw90 = 10, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 135 </summary>
        MavSensorRotationRoll180Yaw135 = 11, 

        /// <summary> Roll: 0, Pitch: 180, Yaw: 0 </summary>
        MavSensorRotationPitch180 = 12, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 225 </summary>
        MavSensorRotationRoll180Yaw225 = 13, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 270 </summary>
        MavSensorRotationRoll180Yaw270 = 14, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 315 </summary>
        MavSensorRotationRoll180Yaw315 = 15, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 0 </summary>
        MavSensorRotationRoll90 = 16, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 45 </summary>
        MavSensorRotationRoll90Yaw45 = 17, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 90 </summary>
        MavSensorRotationRoll90Yaw90 = 18, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 135 </summary>
        MavSensorRotationRoll90Yaw135 = 19, 

        /// <summary> Roll: 270, Pitch: 0, Yaw: 0 </summary>
        MavSensorRotationRoll270 = 20, 

        /// <summary> Roll: 270, Pitch: 0, Yaw: 45 </summary>
        MavSensorRotationRoll270Yaw45 = 21, 

        /// <summary> Roll: 270, Pitch: 0, Yaw: 90 </summary>
        MavSensorRotationRoll270Yaw90 = 22, 

        /// <summary> Roll: 270, Pitch: 0, Yaw: 135 </summary>
        MavSensorRotationRoll270Yaw135 = 23, 

        /// <summary> Roll: 0, Pitch: 90, Yaw: 0 </summary>
        MavSensorRotationPitch90 = 24, 

        /// <summary> Roll: 0, Pitch: 270, Yaw: 0 </summary>
        MavSensorRotationPitch270 = 25, 

        /// <summary> Roll: 0, Pitch: 180, Yaw: 90 </summary>
        MavSensorRotationPitch180Yaw90 = 26, 

        /// <summary> Roll: 0, Pitch: 180, Yaw: 270 </summary>
        MavSensorRotationPitch180Yaw270 = 27, 

        /// <summary> Roll: 90, Pitch: 90, Yaw: 0 </summary>
        MavSensorRotationRoll90Pitch90 = 28, 

        /// <summary> Roll: 180, Pitch: 90, Yaw: 0 </summary>
        MavSensorRotationRoll180Pitch90 = 29, 

        /// <summary> Roll: 270, Pitch: 90, Yaw: 0 </summary>
        MavSensorRotationRoll270Pitch90 = 30, 

        /// <summary> Roll: 90, Pitch: 180, Yaw: 0 </summary>
        MavSensorRotationRoll90Pitch180 = 31, 

        /// <summary> Roll: 270, Pitch: 180, Yaw: 0 </summary>
        MavSensorRotationRoll270Pitch180 = 32, 

        /// <summary> Roll: 90, Pitch: 270, Yaw: 0 </summary>
        MavSensorRotationRoll90Pitch270 = 33, 

        /// <summary> Roll: 180, Pitch: 270, Yaw: 0 </summary>
        MavSensorRotationRoll180Pitch270 = 34, 

        /// <summary> Roll: 270, Pitch: 270, Yaw: 0 </summary>
        MavSensorRotationRoll270Pitch270 = 35, 

        /// <summary> Roll: 90, Pitch: 180, Yaw: 90 </summary>
        MavSensorRotationRoll90Pitch180Yaw90 = 36, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 270 </summary>
        MavSensorRotationRoll90Yaw270 = 37, 

        /// <summary> Roll: 90, Pitch: 68, Yaw: 293 </summary>
        MavSensorRotationRoll90Pitch68Yaw293 = 38, 

        /// <summary> Pitch: 315 </summary>
        MavSensorRotationPitch315 = 39, 

        /// <summary> Roll: 90, Pitch: 315 </summary>
        MavSensorRotationRoll90Pitch315 = 40, 

        /// <summary> Custom orientation </summary>
        MavSensorRotationCustom = 100 };

    /// <summary>
    /// Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability.
    /// </summary>
    public enum MavProtocolCapability { 

        /// <summary> Autopilot supports MISSION float message type. </summary>
        MissionFloat = 1, 

        /// <summary> Autopilot supports the new param float message type. </summary>
        ParamFloat = 2, 

        /// <summary> Autopilot supports MISSION_ITEM_INT scaled integer message type. </summary>
        MissionInt = 4, 

        /// <summary> Autopilot supports COMMAND_INT scaled integer message type. </summary>
        CommandInt = 8, 

        /// <summary> Autopilot supports the new param union message type. </summary>
        ParamUnion = 16, 

        /// <summary> Autopilot supports the new FILE_TRANSFER_PROTOCOL message type. </summary>
        Ftp = 32, 

        /// <summary> Autopilot supports commanding attitude offboard. </summary>
        SetAttitudeTarget = 64, 

        /// <summary> Autopilot supports commanding position and velocity targets in local NED frame. </summary>
        SetPositionTargetLocalNed = 128, 

        /// <summary> Autopilot supports commanding position and velocity targets in global scaled integers. </summary>
        SetPositionTargetGlobalInt = 256, 

        /// <summary> Autopilot supports terrain protocol / data handling. </summary>
        Terrain = 512, 

        /// <summary> Autopilot supports direct actuator control. </summary>
        SetActuatorTarget = 1024, 

        /// <summary> Autopilot supports the flight termination command. </summary>
        FlightTermination = 2048, 

        /// <summary> Autopilot supports onboard compass calibration. </summary>
        CompassCalibration = 4096, 

        /// <summary> Autopilot supports MAVLink version 2. </summary>
        Mavlink2 = 8192, 

        /// <summary> Autopilot supports mission fence protocol. </summary>
        MissionFence = 16384, 

        /// <summary> Autopilot supports mission rally point protocol. </summary>
        MissionRally = 32768, 

        /// <summary> Autopilot supports the flight information protocol. </summary>
        FlightInformation = 65536 };

    /// <summary>
    /// Type of mission items being requested/sent in mission protocol.
    /// </summary>
    public enum MavMissionType { 

        /// <summary> Items are mission commands for main mission. </summary>
        Mission = 0, 

        /// <summary> Specifies GeoFence area(s). Items are MAV_CMD_NAV_FENCE_ GeoFence items. </summary>
        Fence = 1, 

        /// <summary> Specifies the rally points for the vehicle. Rally points are alternative RTL points. Items are MAV_CMD_NAV_RALLY_POINT rally point items. </summary>
        Rally = 2, 

        /// <summary> Only used in MISSION_CLEAR_ALL to clear all mission types. </summary>
        All = 255 };

    /// <summary>
    /// Enumeration of estimator types
    /// </summary>
    public enum MavEstimatorType { 

        /// <summary> Unknown type of the estimator. </summary>
        Unknown = 0, 

        /// <summary> This is a naive estimator without any real covariance feedback. </summary>
        Naive = 1, 

        /// <summary> Computer vision based estimate. Might be up to scale. </summary>
        Vision = 2, 

        /// <summary> Visual-inertial estimate. </summary>
        Vio = 3, 

        /// <summary> Plain GPS estimate. </summary>
        Gps = 4, 

        /// <summary> Estimator integrating GPS and inertial sensing. </summary>
        GpsIns = 5, 

        /// <summary> Estimate from external motion capturing system. </summary>
        Mocap = 6, 

        /// <summary> Estimator based on lidar sensor input. </summary>
        Lidar = 7, 

        /// <summary> Estimator on autopilot. </summary>
        Autopilot = 8 };

    /// <summary>
    /// Enumeration of battery types
    /// </summary>
    public enum MavBatteryType { 

        /// <summary> Not specified. </summary>
        Unknown = 0, 

        /// <summary> Lithium polymer battery </summary>
        Lipo = 1, 

        /// <summary> Lithium-iron-phosphate battery </summary>
        Life = 2, 

        /// <summary> Lithium-ION battery </summary>
        Lion = 3, 

        /// <summary> Nickel metal hydride battery </summary>
        Nimh = 4 };

    /// <summary>
    /// Enumeration of battery functions
    /// </summary>
    public enum MavBatteryFunction { 

        /// <summary> Battery function is unknown </summary>
        Unknown = 0, 

        /// <summary> Battery supports all flight systems </summary>
        All = 1, 

        /// <summary> Battery for the propulsion system </summary>
        Propulsion = 2, 

        /// <summary> Avionics battery </summary>
        Avionics = 3, 

        /// <summary> Payload battery </summary>
        MavBatteryTypePayload = 4 };

    /// <summary>
    /// Enumeration for battery charge states.
    /// </summary>
    public enum MavBatteryChargeState { 

        /// <summary> Low battery state is not provided </summary>
        Undefined = 0, 

        /// <summary> Battery is not in low state. Normal operation. </summary>
        Ok = 1, 

        /// <summary> Battery state is low, warn and monitor close. </summary>
        Low = 2, 

        /// <summary> Battery state is critical, return or abort immediately. </summary>
        Critical = 3, 

        /// <summary> Battery state is too low for ordinary abort sequence. Perform fastest possible emergency stop to prevent damage. </summary>
        Emergency = 4, 

        /// <summary> Battery failed, damage unavoidable. Possible causes (faults) are listed in MAV_BATTERY_FAULT. </summary>
        Failed = 5, 

        /// <summary> Battery is diagnosed to be defective or an error occurred, usage is discouraged / prohibited. Possible causes (faults) are listed in MAV_BATTERY_FAULT. </summary>
        Unhealthy = 6, 

        /// <summary> Battery is charging. </summary>
        Charging = 7 };

    /// <summary>
    /// Battery mode. Note, the normal operation mode (i.e. when flying) should be reported as MAV_BATTERY_MODE_UNKNOWN to allow message trimming in normal flight.
    /// </summary>
    public enum MavBatteryMode { 

        /// <summary> Battery mode not supported/unknown battery mode/normal operation. </summary>
        Unknown = 0, 

        /// <summary> Battery is auto discharging (towards storage level). </summary>
        AutoDischarging = 1, 

        /// <summary> Battery in hot-swap mode (current limited to prevent spikes that might damage sensitive electrical circuits). </summary>
        HotSwap = 2 };

    /// <summary>
    /// Smart battery supply status/fault flags (bitmask) for health indication. The battery must also report either MAV_BATTERY_CHARGE_STATE_FAILED or MAV_BATTERY_CHARGE_STATE_UNHEALTHY if any of these are set.
    /// </summary>
    public enum MavBatteryFault { 

        /// <summary> Battery has deep discharged. </summary>
        DeepDischarge = 1, 

        /// <summary> Voltage spikes. </summary>
        Spikes = 2, 

        /// <summary> One or more cells have failed. Battery should also report MAV_BATTERY_CHARGE_STATE_FAILE (and should not be used). </summary>
        CellFail = 4, 

        /// <summary> Over-current fault. </summary>
        OverCurrent = 8, 

        /// <summary> Over-temperature fault. </summary>
        OverTemperature = 16, 

        /// <summary> Under-temperature fault. </summary>
        UnderTemperature = 32, 

        /// <summary> Vehicle voltage is not compatible with this battery (batteries on same power rail should have similar voltage). </summary>
        IncompatibleVoltage = 64, 

        /// <summary> Battery firmware is not compatible with current autopilot firmware. </summary>
        IncompatibleFirmware = 128, 

        /// <summary> Battery is not compatible due to cell configuration (e.g. 5s1p when vehicle requires 6s). </summary>
        BatteryFaultIncompatibleCellsConfiguration = 256 };

    /// <summary>
    /// Flags to report status/failure cases for a power generator (used in GENERATOR_STATUS). Note that FAULTS are conditions that cause the generator to fail. Warnings are conditions that require attention before the next use (they indicate the system is not operating properly).
    /// </summary>
    public enum MavGeneratorStatusFlag { 

        /// <summary> Generator is off. </summary>
        Off = 1, 

        /// <summary> Generator is ready to start generating power. </summary>
        Ready = 2, 

        /// <summary> Generator is generating power. </summary>
        Generating = 4, 

        /// <summary> Generator is charging the batteries (generating enough power to charge and provide the load). </summary>
        Charging = 8, 

        /// <summary> Generator is operating at a reduced maximum power. </summary>
        ReducedPower = 16, 

        /// <summary> Generator is providing the maximum output. </summary>
        Maxpower = 32, 

        /// <summary> Generator is near the maximum operating temperature, cooling is insufficient. </summary>
        OvertempWarning = 64, 

        /// <summary> Generator hit the maximum operating temperature and shutdown. </summary>
        OvertempFault = 128, 

        /// <summary> Power electronics are near the maximum operating temperature, cooling is insufficient. </summary>
        ElectronicsOvertempWarning = 256, 

        /// <summary> Power electronics hit the maximum operating temperature and shutdown. </summary>
        ElectronicsOvertempFault = 512, 

        /// <summary> Power electronics experienced a fault and shutdown. </summary>
        ElectronicsFault = 1024, 

        /// <summary> The power source supplying the generator failed e.g. mechanical generator stopped, tether is no longer providing power, solar cell is in shade, hydrogen reaction no longer happening. </summary>
        PowersourceFault = 2048, 

        /// <summary> Generator controller having communication problems. </summary>
        CommunicationWarning = 4096, 

        /// <summary> Power electronic or generator cooling system error. </summary>
        CoolingWarning = 8192, 

        /// <summary> Generator controller power rail experienced a fault. </summary>
        PowerRailFault = 16384, 

        /// <summary> Generator controller exceeded the overcurrent threshold and shutdown to prevent damage. </summary>
        OvercurrentFault = 32768, 

        /// <summary> Generator controller detected a high current going into the batteries and shutdown to prevent battery damage. </summary>
        BatteryOverchargeCurrentFault = 65536, 

        /// <summary> Generator controller exceeded it's overvoltage threshold and shutdown to prevent it exceeding the voltage rating. </summary>
        OvervoltageFault = 131072, 

        /// <summary> Batteries are under voltage (generator will not start). </summary>
        BatteryUndervoltFault = 262144, 

        /// <summary> Generator start is inhibited by e.g. a safety switch. </summary>
        StartInhibited = 524288, 

        /// <summary> Generator requires maintenance. </summary>
        MaintenanceRequired = 1048576, 

        /// <summary> Generator is not ready to generate yet. </summary>
        WarmingUp = 2097152, 

        /// <summary> Generator is idle. </summary>
        Idle = 4194304 };

    /// <summary>
    /// Enumeration of VTOL states
    /// </summary>
    public enum MavVtolState { 

        /// <summary> MAV is not configured as VTOL </summary>
        Undefined = 0, 

        /// <summary> VTOL is in transition from multicopter to fixed-wing </summary>
        TransitionToFw = 1, 

        /// <summary> VTOL is in transition from fixed-wing to multicopter </summary>
        TransitionToMc = 2, 

        /// <summary> VTOL is in multicopter state </summary>
        Mc = 3, 

        /// <summary> VTOL is in fixed-wing state </summary>
        Fw = 4 };

    /// <summary>
    /// Enumeration of landed detector states
    /// </summary>
    public enum MavLandedState { 

        /// <summary> MAV landed state is unknown </summary>
        Undefined = 0, 

        /// <summary> MAV is landed (on ground) </summary>
        OnGround = 1, 

        /// <summary> MAV is in air </summary>
        InAir = 2, 

        /// <summary> MAV currently taking off </summary>
        Takeoff = 3, 

        /// <summary> MAV currently landing </summary>
        Landing = 4 };

    /// <summary>
    /// Enumeration of the ADSB altimeter types
    /// </summary>
    public enum AdsbAltitudeType { 

        /// <summary> Altitude reported from a Baro source using QNH reference </summary>
        PressureQnh = 0, 

        /// <summary> Altitude reported from a GNSS source </summary>
        Geometric = 1 };

    /// <summary>
    /// ADSB classification for the type of vehicle emitting the transponder signal
    /// </summary>
    public enum AdsbEmitterType { 

        /// <summary>  </summary>
        NoInfo = 0, 

        /// <summary>  </summary>
        Light = 1, 

        /// <summary>  </summary>
        Small = 2, 

        /// <summary>  </summary>
        Large = 3, 

        /// <summary>  </summary>
        HighVortexLarge = 4, 

        /// <summary>  </summary>
        Heavy = 5, 

        /// <summary>  </summary>
        HighlyManuv = 6, 

        /// <summary>  </summary>
        Rotocraft = 7, 

        /// <summary>  </summary>
        Unassigned = 8, 

        /// <summary>  </summary>
        Glider = 9, 

        /// <summary>  </summary>
        LighterAir = 10, 

        /// <summary>  </summary>
        Parachute = 11, 

        /// <summary>  </summary>
        UltraLight = 12, 

        /// <summary>  </summary>
        Unassigned2 = 13, 

        /// <summary>  </summary>
        Uav = 14, 

        /// <summary>  </summary>
        Space = 15, 

        /// <summary>  </summary>
        Unassgined3 = 16, 

        /// <summary>  </summary>
        EmergencySurface = 17, 

        /// <summary>  </summary>
        ServiceSurface = 18, 

        /// <summary>  </summary>
        PointObstacle = 19 };

    /// <summary>
    /// These flags indicate status such as data validity of each data source. Set = data valid
    /// </summary>
    public enum AdsbFlags { 

        /// <summary>  </summary>
        ValidCoords = 1, 

        /// <summary>  </summary>
        ValidAltitude = 2, 

        /// <summary>  </summary>
        ValidHeading = 4, 

        /// <summary>  </summary>
        ValidVelocity = 8, 

        /// <summary>  </summary>
        ValidCallsign = 16, 

        /// <summary>  </summary>
        ValidSquawk = 32, 

        /// <summary>  </summary>
        Simulated = 64, 

        /// <summary>  </summary>
        VerticalVelocityValid = 128, 

        /// <summary>  </summary>
        BaroValid = 256, 

        /// <summary>  </summary>
        SourceUat = 32768 };

    /// <summary>
    /// Bitmap of options for the MAV_CMD_DO_REPOSITION
    /// </summary>
    public enum MavDoRepositionFlags { 

        /// <summary> The aircraft should immediately transition into guided. This should not be set for follow me applications </summary>
        ChangeMode = 1 };

    /// <summary>
    /// Flags in ESTIMATOR_STATUS message
    /// </summary>
    public enum EstimatorStatusFlags { 

        /// <summary> True if the attitude estimate is good </summary>
        EstimatorAttitude = 1, 

        /// <summary> True if the horizontal velocity estimate is good </summary>
        EstimatorVelocityHoriz = 2, 

        /// <summary> True if the  vertical velocity estimate is good </summary>
        EstimatorVelocityVert = 4, 

        /// <summary> True if the horizontal position (relative) estimate is good </summary>
        EstimatorPosHorizRel = 8, 

        /// <summary> True if the horizontal position (absolute) estimate is good </summary>
        EstimatorPosHorizAbs = 16, 

        /// <summary> True if the vertical position (absolute) estimate is good </summary>
        EstimatorPosVertAbs = 32, 

        /// <summary> True if the vertical position (above ground) estimate is good </summary>
        EstimatorPosVertAgl = 64, 

        /// <summary> True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical flow) </summary>
        EstimatorConstPosMode = 128, 

        /// <summary> True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimate </summary>
        EstimatorPredPosHorizRel = 256, 

        /// <summary> True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimate </summary>
        EstimatorPredPosHorizAbs = 512, 

        /// <summary> True if the EKF has detected a GPS glitch </summary>
        EstimatorGpsGlitch = 1024, 

        /// <summary> True if the EKF has detected bad accelerometer data </summary>
        EstimatorAccelError = 2048 };

    /// <summary>
    /// Sequence that motors are tested when using MAV_CMD_DO_MOTOR_TEST.
    /// </summary>
    public enum MotorTestOrder { 

        /// <summary> Default autopilot motor test method. </summary>
        Default = 0, 

        /// <summary> Motor numbers are specified as their index in a predefined vehicle-specific sequence. </summary>
        Sequence = 1, 

        /// <summary> Motor numbers are specified as the output as labeled on the board. </summary>
        Board = 2 };

    /// <summary>
    /// Defines how throttle value is represented in MAV_CMD_DO_MOTOR_TEST.
    /// </summary>
    public enum MotorTestThrottleType { 

        /// <summary> Throttle as a percentage (0 ~ 100) </summary>
        MotorTestThrottlePercent = 0, 

        /// <summary> Throttle as an absolute PWM value (normally in range of 1000~2000). </summary>
        MotorTestThrottlePwm = 1, 

        /// <summary> Throttle pass-through from pilot's transmitter. </summary>
        MotorTestThrottlePilot = 2, 

        /// <summary> Per-motor compass calibration test. </summary>
        MotorTestCompassCal = 3 };

    public enum GpsInputIgnoreFlags { 

        /// <summary> ignore altitude field </summary>
        GpsInputIgnoreFlagAlt = 1, 

        /// <summary> ignore hdop field </summary>
        GpsInputIgnoreFlagHdop = 2, 

        /// <summary> ignore vdop field </summary>
        GpsInputIgnoreFlagVdop = 4, 

        /// <summary> ignore horizontal velocity field (vn and ve) </summary>
        GpsInputIgnoreFlagVelHoriz = 8, 

        /// <summary> ignore vertical velocity field (vd) </summary>
        GpsInputIgnoreFlagVelVert = 16, 

        /// <summary> ignore speed accuracy field </summary>
        GpsInputIgnoreFlagSpeedAccuracy = 32, 

        /// <summary> ignore horizontal accuracy field </summary>
        GpsInputIgnoreFlagHorizontalAccuracy = 64, 

        /// <summary> ignore vertical accuracy field </summary>
        GpsInputIgnoreFlagVerticalAccuracy = 128 };

    /// <summary>
    /// Possible actions an aircraft can take to avoid a collision.
    /// </summary>
    public enum MavCollisionAction { 

        /// <summary> Ignore any potential collisions </summary>
        None = 0, 

        /// <summary> Report potential collision </summary>
        Report = 1, 

        /// <summary> Ascend or Descend to avoid threat </summary>
        AscendOrDescend = 2, 

        /// <summary> Move horizontally to avoid threat </summary>
        MoveHorizontally = 3, 

        /// <summary> Aircraft to move perpendicular to the collision's velocity vector </summary>
        MovePerpendicular = 4, 

        /// <summary> Aircraft to fly directly back to its launch point </summary>
        Rtl = 5, 

        /// <summary> Aircraft to stop in place </summary>
        Hover = 6 };

    /// <summary>
    /// Aircraft-rated danger from this threat.
    /// </summary>
    public enum MavCollisionThreatLevel { 

        /// <summary> Not a threat </summary>
        None = 0, 

        /// <summary> Craft is mildly concerned about this threat </summary>
        Low = 1, 

        /// <summary> Craft is panicking, and may take actions to avoid threat </summary>
        High = 2 };

    /// <summary>
    /// Source of information about this collision.
    /// </summary>
    public enum MavCollisionSrc { 

        /// <summary> ID field references ADSB_VEHICLE packets </summary>
        Adsb = 0, 

        /// <summary> ID field references MAVLink SRC ID </summary>
        MavlinkGpsGlobalInt = 1 };

    /// <summary>
    /// Type of GPS fix
    /// </summary>
    public enum GpsFixType { 

        /// <summary> No GPS connected </summary>
        NoGps = 0, 

        /// <summary> No position information, GPS is connected </summary>
        NoFix = 1, 

        /// <summary> 2D position </summary>
        _2dFix = 2, 

        /// <summary> 3D position </summary>
        _3dFix = 3, 

        /// <summary> DGPS/SBAS aided 3D position </summary>
        Dgps = 4, 

        /// <summary> RTK float, 3D position </summary>
        RtkFloat = 5, 

        /// <summary> RTK Fixed, 3D position </summary>
        RtkFixed = 6, 

        /// <summary> Static fixed, typically used for base stations </summary>
        Static = 7, 

        /// <summary> PPP, 3D position. </summary>
        Ppp = 8 };

    /// <summary>
    /// RTK GPS baseline coordinate system, used for RTK corrections
    /// </summary>
    public enum RtkBaselineCoordinateSystem { 

        /// <summary> Earth-centered, Earth-fixed </summary>
        Ecef = 0, 

        /// <summary> RTK basestation centered, north, east, down </summary>
        Ned = 1 };

    /// <summary>
    /// Type of landing target
    /// </summary>
    public enum LandingTargetType { 

        /// <summary> Landing target signaled by light beacon (ex: IR-LOCK) </summary>
        LightBeacon = 0, 

        /// <summary> Landing target signaled by radio beacon (ex: ILS, NDB) </summary>
        RadioBeacon = 1, 

        /// <summary> Landing target represented by a fiducial marker (ex: ARTag) </summary>
        VisionFiducial = 2, 

        /// <summary> Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square) </summary>
        VisionOther = 3 };

    /// <summary>
    /// Direction of VTOL transition
    /// </summary>
    public enum VtolTransitionHeading { 

        /// <summary> Respect the heading configuration of the vehicle. </summary>
        VehicleDefault = 0, 

        /// <summary> Use the heading pointing towards the next waypoint. </summary>
        NextWaypoint = 1, 

        /// <summary> Use the heading on takeoff (while sitting on the ground). </summary>
        Takeoff = 2, 

        /// <summary> Use the specified heading in parameter 4. </summary>
        Specified = 3, 

        /// <summary> Use the current heading when reaching takeoff altitude (potentially facing the wind when weather-vaning is active). </summary>
        Any = 4 };

    /// <summary>
    /// Camera capability flags (Bitmap)
    /// </summary>
    public enum CameraCapFlags { 

        /// <summary> Camera is able to record video </summary>
        CaptureVideo = 1, 

        /// <summary> Camera is able to capture images </summary>
        CaptureImage = 2, 

        /// <summary> Camera has separate Video and Image/Photo modes (MAV_CMD_SET_CAMERA_MODE) </summary>
        HasModes = 4, 

        /// <summary> Camera can capture images while in video mode </summary>
        CanCaptureImageInVideoMode = 8, 

        /// <summary> Camera can capture videos while in Photo/Image mode </summary>
        CanCaptureVideoInImageMode = 16, 

        /// <summary> Camera has image survey mode (MAV_CMD_SET_CAMERA_MODE) </summary>
        HasImageSurveyMode = 32, 

        /// <summary> Camera has basic zoom control (MAV_CMD_SET_CAMERA_ZOOM) </summary>
        HasBasicZoom = 64, 

        /// <summary> Camera has basic focus control (MAV_CMD_SET_CAMERA_FOCUS) </summary>
        HasBasicFocus = 128, 

        /// <summary> Camera has video streaming capabilities (request VIDEO_STREAM_INFORMATION with MAV_CMD_REQUEST_MESSAGE for video streaming info) </summary>
        HasVideoStream = 256, 

        /// <summary> Camera supports tracking of a point on the camera view. </summary>
        HasTrackingPoint = 512, 

        /// <summary> Camera supports tracking of a selection rectangle on the camera view. </summary>
        HasTrackingRectangle = 1024, 

        /// <summary> Camera supports tracking geo status (CAMERA_TRACKING_GEO_STATUS). </summary>
        HasTrackingGeoStatus = 2048 };

    /// <summary>
    /// Stream status flags (Bitmap)
    /// </summary>
    public enum VideoStreamStatusFlags { 

        /// <summary> Stream is active (running) </summary>
        Running = 1, 

        /// <summary> Stream is thermal imaging </summary>
        Thermal = 2 };

    /// <summary>
    /// Video stream types
    /// </summary>
    public enum VideoStreamType { 

        /// <summary> Stream is RTSP </summary>
        Rtsp = 0, 

        /// <summary> Stream is RTP UDP (URI gives the port number) </summary>
        Rtpudp = 1, 

        /// <summary> Stream is MPEG on TCP </summary>
        TcpMpeg = 2, 

        /// <summary> Stream is h.264 on MPEG TS (URI gives the port number) </summary>
        MpegTsH264 = 3 };

    /// <summary>
    /// Camera tracking status flags
    /// </summary>
    public enum CameraTrackingStatusFlags { 

        /// <summary> Camera is not tracking </summary>
        Idle = 0, 

        /// <summary> Camera is tracking </summary>
        Active = 1, 

        /// <summary> Camera tracking in error state </summary>
        Error = 2 };

    /// <summary>
    /// Camera tracking modes
    /// </summary>
    public enum CameraTrackingMode { 

        /// <summary> Not tracking </summary>
        None = 0, 

        /// <summary> Target is a point </summary>
        Point = 1, 

        /// <summary> Target is a rectangle </summary>
        Rectangle = 2 };

    /// <summary>
    /// Camera tracking target data (shows where tracked target is within image)
    /// </summary>
    public enum CameraTrackingTargetData { 

        /// <summary> No target data </summary>
        None = 0, 

        /// <summary> Target data embedded in image data (proprietary) </summary>
        Embedded = 1, 

        /// <summary> Target data rendered in image </summary>
        Rendered = 2, 

        /// <summary> Target data within status message (Point or Rectangle) </summary>
        InStatus = 4 };

    /// <summary>
    /// Zoom types for MAV_CMD_SET_CAMERA_ZOOM
    /// </summary>
    public enum CameraZoomType { 

        /// <summary> Zoom one step increment (-1 for wide, 1 for tele) </summary>
        ZoomTypeStep = 0, 

        /// <summary> Continuous zoom up/down until stopped (-1 for wide, 1 for tele, 0 to stop zooming) </summary>
        ZoomTypeContinuous = 1, 

        /// <summary> Zoom value as proportion of full camera range (a value between 0.0 and 100.0) </summary>
        ZoomTypeRange = 2, 

        /// <summary> Zoom value/variable focal length in milimetres. Note that there is no message to get the valid zoom range of the camera, so this can type can only be used for cameras where the zoom range is known (implying that this cannot reliably be used in a GCS for an arbitrary camera) </summary>
        ZoomTypeFocalLength = 3 };

    /// <summary>
    /// Focus types for MAV_CMD_SET_CAMERA_FOCUS
    /// </summary>
    public enum SetFocusType { 

        /// <summary> Focus one step increment (-1 for focusing in, 1 for focusing out towards infinity). </summary>
        FocusTypeStep = 0, 

        /// <summary> Continuous focus up/down until stopped (-1 for focusing in, 1 for focusing out towards infinity, 0 to stop focusing) </summary>
        FocusTypeContinuous = 1, 

        /// <summary> Focus value as proportion of full camera focus range (a value between 0.0 and 100.0) </summary>
        FocusTypeRange = 2, 

        /// <summary> Focus value in metres. Note that there is no message to get the valid focus range of the camera, so this can type can only be used for cameras where the range is known (implying that this cannot reliably be used in a GCS for an arbitrary camera). </summary>
        FocusTypeMeters = 3 };

    /// <summary>
    /// Result from PARAM_EXT_SET message (or a PARAM_SET within a transaction).
    /// </summary>
    public enum ParamAck { 

        /// <summary> Parameter value ACCEPTED and SET </summary>
        Accepted = 0, 

        /// <summary> Parameter value UNKNOWN/UNSUPPORTED </summary>
        ValueUnsupported = 1, 

        /// <summary> Parameter failed to set </summary>
        Failed = 2, 

        /// <summary> Parameter value received but not yet set/accepted. A subsequent PARAM_ACK_TRANSACTION or PARAM_EXT_ACK with the final result will follow once operation is completed. This is returned immediately for parameters that take longer to set, indicating taht the the parameter was recieved and does not need to be resent. </summary>
        InProgress = 3 };

    /// <summary>
    /// Camera Modes.
    /// </summary>
    public enum CameraMode { 

        /// <summary> Camera is in image/photo capture mode. </summary>
        Image = 0, 

        /// <summary> Camera is in video capture mode. </summary>
        Video = 1, 

        /// <summary> Camera is in image survey capture mode. It allows for camera controller to do specific settings for surveys. </summary>
        ImageSurvey = 2 };

    public enum MavArmAuthDeniedReason { 

        /// <summary> Not a specific reason </summary>
        Generic = 0, 

        /// <summary> Authorizer will send the error as string to GCS </summary>
        None = 1, 

        /// <summary> At least one waypoint have a invalid value </summary>
        InvalidWaypoint = 2, 

        /// <summary> Timeout in the authorizer process(in case it depends on network) </summary>
        Timeout = 3, 

        /// <summary> Airspace of the mission in use by another vehicle, second result parameter can have the waypoint id that caused it to be denied. </summary>
        AirspaceInUse = 4, 

        /// <summary> Weather is not good to fly </summary>
        BadWeather = 5 };

    /// <summary>
    /// RC type
    /// </summary>
    public enum RcType { 

        /// <summary> Spektrum DSM2 </summary>
        SpektrumDsm2 = 0, 

        /// <summary> Spektrum DSMX </summary>
        SpektrumDsmx = 1 };

    /// <summary>
    /// Bitmap to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 9 is set the floats afx afy afz should be interpreted as force instead of acceleration.
    /// </summary>
    public enum PositionTargetTypemask { 

        /// <summary> Ignore position x </summary>
        XIgnore = 1, 

        /// <summary> Ignore position y </summary>
        YIgnore = 2, 

        /// <summary> Ignore position z </summary>
        ZIgnore = 4, 

        /// <summary> Ignore velocity x </summary>
        VxIgnore = 8, 

        /// <summary> Ignore velocity y </summary>
        VyIgnore = 16, 

        /// <summary> Ignore velocity z </summary>
        VzIgnore = 32, 

        /// <summary> Ignore acceleration x </summary>
        AxIgnore = 64, 

        /// <summary> Ignore acceleration y </summary>
        AyIgnore = 128, 

        /// <summary> Ignore acceleration z </summary>
        AzIgnore = 256, 

        /// <summary> Use force instead of acceleration </summary>
        ForceSet = 512, 

        /// <summary> Ignore yaw </summary>
        YawIgnore = 1024, 

        /// <summary> Ignore yaw rate </summary>
        YawRateIgnore = 2048 };

    /// <summary>
    /// Bitmap to indicate which dimensions should be ignored by the vehicle: a value of 0b00000000 indicates that none of the setpoint dimensions should be ignored.
    /// </summary>
    public enum AttitudeTargetTypemask { 

        /// <summary> Ignore body roll rate </summary>
        BodyRollRateIgnore = 1, 

        /// <summary> Ignore body pitch rate </summary>
        BodyPitchRateIgnore = 2, 

        /// <summary> Ignore body yaw rate </summary>
        BodyYawRateIgnore = 4, 

        /// <summary> Use 3D body thrust setpoint instead of throttle </summary>
        ThrustBodySet = 32, 

        /// <summary> Ignore throttle </summary>
        ThrottleIgnore = 64, 

        /// <summary> Ignore attitude </summary>
        AttitudeIgnore = 128 };

    /// <summary>
    /// Airborne status of UAS.
    /// </summary>
    public enum UtmFlightState { 

        /// <summary> The flight state can't be determined. </summary>
        Unknown = 1, 

        /// <summary> UAS on ground. </summary>
        Ground = 2, 

        /// <summary> UAS airborne. </summary>
        Airborne = 3, 

        /// <summary> UAS is in an emergency flight state. </summary>
        Emergency = 16, 

        /// <summary> UAS has no active controls. </summary>
        Noctrl = 32 };

    /// <summary>
    /// Flags for the global position report.
    /// </summary>
    public enum UtmDataAvailFlags { 

        /// <summary> The field time contains valid data. </summary>
        TimeValid = 1, 

        /// <summary> The field uas_id contains valid data. </summary>
        UasIdAvailable = 2, 

        /// <summary> The fields lat, lon and h_acc contain valid data. </summary>
        PositionAvailable = 4, 

        /// <summary> The fields alt and v_acc contain valid data. </summary>
        AltitudeAvailable = 8, 

        /// <summary> The field relative_alt contains valid data. </summary>
        RelativeAltitudeAvailable = 16, 

        /// <summary> The fields vx and vy contain valid data. </summary>
        HorizontalVeloAvailable = 32, 

        /// <summary> The field vz contains valid data. </summary>
        VerticalVeloAvailable = 64, 

        /// <summary> The fields next_lat, next_lon and next_alt contain valid data. </summary>
        NextWaypointAvailable = 128 };

    /// <summary>
    /// These flags encode the cellular network status
    /// </summary>
    public enum CellularStatusFlag { 

        /// <summary> State unknown or not reportable. </summary>
        Unknown = 0, 

        /// <summary> Modem is unusable </summary>
        Failed = 1, 

        /// <summary> Modem is being initialized </summary>
        Initializing = 2, 

        /// <summary> Modem is locked </summary>
        Locked = 3, 

        /// <summary> Modem is not enabled and is powered down </summary>
        Disabled = 4, 

        /// <summary> Modem is currently transitioning to the CELLULAR_STATUS_FLAG_DISABLED state </summary>
        Disabling = 5, 

        /// <summary> Modem is currently transitioning to the CELLULAR_STATUS_FLAG_ENABLED state </summary>
        Enabling = 6, 

        /// <summary> Modem is enabled and powered on but not registered with a network provider and not available for data connections </summary>
        Enabled = 7, 

        /// <summary> Modem is searching for a network provider to register </summary>
        Searching = 8, 

        /// <summary> Modem is registered with a network provider, and data connections and messaging may be available for use </summary>
        Registered = 9, 

        /// <summary> Modem is disconnecting and deactivating the last active packet data bearer. This state will not be entered if more than one packet data bearer is active and one of the active bearers is deactivated </summary>
        Disconnecting = 10, 

        /// <summary> Modem is activating and connecting the first packet data bearer. Subsequent bearer activations when another bearer is already active do not cause this state to be entered </summary>
        Connecting = 11, 

        /// <summary> One or more packet data bearers is active and connected </summary>
        Connected = 12 };

    /// <summary>
    /// These flags are used to diagnose the failure state of CELLULAR_STATUS
    /// </summary>
    public enum CellularNetworkFailedReason { 

        /// <summary> No error </summary>
        None = 0, 

        /// <summary> Error state is unknown </summary>
        Unknown = 1, 

        /// <summary> SIM is required for the modem but missing </summary>
        SimMissing = 2, 

        /// <summary> SIM is available, but not usuable for connection </summary>
        SimError = 3 };

    /// <summary>
    /// Cellular network radio type
    /// </summary>
    public enum CellularNetworkRadioType { 

        /// <summary>  </summary>
        None = 0, 

        /// <summary>  </summary>
        Gsm = 1, 

        /// <summary>  </summary>
        Cdma = 2, 

        /// <summary>  </summary>
        Wcdma = 3, 

        /// <summary>  </summary>
        Lte = 4 };

    /// <summary>
    /// Precision land modes (used in MAV_CMD_NAV_LAND).
    /// </summary>
    public enum PrecisionLandMode { 

        /// <summary> Normal (non-precision) landing. </summary>
        Disabled = 0, 

        /// <summary> Use precision landing if beacon detected when land command accepted, otherwise land normally. </summary>
        Opportunistic = 1, 

        /// <summary> Use precision landing, searching for beacon if not found when land command accepted (land normally if beacon cannot be found). </summary>
        Required = 2 };

    /// <summary>
    /// Parachute actions. Trigger release and enable/disable auto-release.
    /// </summary>
    public enum ParachuteAction { 

        /// <summary> Disable auto-release of parachute (i.e. release triggered by crash detectors). </summary>
        ParachuteDisable = 0, 

        /// <summary> Enable auto-release of parachute. </summary>
        ParachuteEnable = 1, 

        /// <summary> Release parachute and kill motors. </summary>
        ParachuteRelease = 2 };

    public enum MavTunnelPayloadType { 

        /// <summary> Encoding of payload unknown. </summary>
        Unknown = 0, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved0 = 200, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved1 = 201, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved2 = 202, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved3 = 203, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved4 = 204, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved5 = 205, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved6 = 206, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved7 = 207, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved8 = 208, 

        /// <summary> Registered for STorM32 gimbal controller. </summary>
        Storm32Reserved9 = 209 };

    public enum MavOdidIdType { 

        /// <summary> No type defined. </summary>
        None = 0, 

        /// <summary> Manufacturer Serial Number (ANSI/CTA-2063 format). </summary>
        SerialNumber = 1, 

        /// <summary> CAA (Civil Aviation Authority) registered ID. Format: [ICAO Country Code].[CAA Assigned ID]. </summary>
        CaaRegistrationId = 2, 

        /// <summary> UTM (Unmanned Traffic Management) assigned UUID (RFC4122). </summary>
        UtmAssignedUuid = 3, 

        /// <summary> A 20 byte ID for a specific flight/session. The exact ID type is indicated by the first byte of uas_id and these type values are managed by ICAO. </summary>
        SpecificSessionId = 4 };

    public enum MavOdidUaType { 

        /// <summary> No UA (Unmanned Aircraft) type defined. </summary>
        None = 0, 

        /// <summary> Aeroplane/Airplane. Fixed wing. </summary>
        Aeroplane = 1, 

        /// <summary> Helicopter or multirotor. </summary>
        HelicopterOrMultirotor = 2, 

        /// <summary> Gyroplane. </summary>
        Gyroplane = 3, 

        /// <summary> VTOL (Vertical Take-Off and Landing). Fixed wing aircraft that can take off vertically. </summary>
        HybridLift = 4, 

        /// <summary> Ornithopter. </summary>
        Ornithopter = 5, 

        /// <summary> Glider. </summary>
        Glider = 6, 

        /// <summary> Kite. </summary>
        Kite = 7, 

        /// <summary> Free Balloon. </summary>
        FreeBalloon = 8, 

        /// <summary> Captive Balloon. </summary>
        CaptiveBalloon = 9, 

        /// <summary> Airship. E.g. a blimp. </summary>
        Airship = 10, 

        /// <summary> Free Fall/Parachute (unpowered). </summary>
        FreeFallParachute = 11, 

        /// <summary> Rocket. </summary>
        Rocket = 12, 

        /// <summary> Tethered powered aircraft. </summary>
        TetheredPoweredAircraft = 13, 

        /// <summary> Ground Obstacle. </summary>
        GroundObstacle = 14, 

        /// <summary> Other type of aircraft not listed earlier. </summary>
        Other = 15 };

    public enum MavOdidStatus { 

        /// <summary> The status of the (UA) Unmanned Aircraft is undefined. </summary>
        Undeclared = 0, 

        /// <summary> The UA is on the ground. </summary>
        Ground = 1, 

        /// <summary> The UA is in the air. </summary>
        Airborne = 2, 

        /// <summary> The UA is having an emergency. </summary>
        Emergency = 3 };

    public enum MavOdidHeightRef { 

        /// <summary> The height field is relative to the take-off location. </summary>
        OverTakeoff = 0, 

        /// <summary> The height field is relative to ground. </summary>
        OverGround = 1 };

    public enum MavOdidHorAcc { 

        /// <summary> The horizontal accuracy is unknown. </summary>
        Unknown = 0, 

        /// <summary> The horizontal accuracy is smaller than 10 Nautical Miles. 18.52 km. </summary>
        _10nm = 1, 

        /// <summary> The horizontal accuracy is smaller than 4 Nautical Miles. 7.408 km. </summary>
        _4nm = 2, 

        /// <summary> The horizontal accuracy is smaller than 2 Nautical Miles. 3.704 km. </summary>
        _2nm = 3, 

        /// <summary> The horizontal accuracy is smaller than 1 Nautical Miles. 1.852 km. </summary>
        _1nm = 4, 

        /// <summary> The horizontal accuracy is smaller than 0.5 Nautical Miles. 926 m. </summary>
        _05nm = 5, 

        /// <summary> The horizontal accuracy is smaller than 0.3 Nautical Miles. 555.6 m. </summary>
        _03nm = 6, 

        /// <summary> The horizontal accuracy is smaller than 0.1 Nautical Miles. 185.2 m. </summary>
        _01nm = 7, 

        /// <summary> The horizontal accuracy is smaller than 0.05 Nautical Miles. 92.6 m. </summary>
        _005nm = 8, 

        /// <summary> The horizontal accuracy is smaller than 30 meter. </summary>
        _30Meter = 9, 

        /// <summary> The horizontal accuracy is smaller than 10 meter. </summary>
        _10Meter = 10, 

        /// <summary> The horizontal accuracy is smaller than 3 meter. </summary>
        _3Meter = 11, 

        /// <summary> The horizontal accuracy is smaller than 1 meter. </summary>
        _1Meter = 12 };

    public enum MavOdidVerAcc { 

        /// <summary> The vertical accuracy is unknown. </summary>
        Unknown = 0, 

        /// <summary> The vertical accuracy is smaller than 150 meter. </summary>
        _150Meter = 1, 

        /// <summary> The vertical accuracy is smaller than 45 meter. </summary>
        _45Meter = 2, 

        /// <summary> The vertical accuracy is smaller than 25 meter. </summary>
        _25Meter = 3, 

        /// <summary> The vertical accuracy is smaller than 10 meter. </summary>
        _10Meter = 4, 

        /// <summary> The vertical accuracy is smaller than 3 meter. </summary>
        _3Meter = 5, 

        /// <summary> The vertical accuracy is smaller than 1 meter. </summary>
        _1Meter = 6 };

    public enum MavOdidSpeedAcc { 

        /// <summary> The speed accuracy is unknown. </summary>
        Unknown = 0, 

        /// <summary> The speed accuracy is smaller than 10 meters per second. </summary>
        _10MetersPerSecond = 1, 

        /// <summary> The speed accuracy is smaller than 3 meters per second. </summary>
        _3MetersPerSecond = 2, 

        /// <summary> The speed accuracy is smaller than 1 meters per second. </summary>
        _1MetersPerSecond = 3, 

        /// <summary> The speed accuracy is smaller than 0.3 meters per second. </summary>
        _03MetersPerSecond = 4 };

    public enum MavOdidTimeAcc { 

        /// <summary> The timestamp accuracy is unknown. </summary>
        Unknown = 0, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.1 second. </summary>
        _01Second = 1, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.2 second. </summary>
        _02Second = 2, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.3 second. </summary>
        _03Second = 3, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.4 second. </summary>
        _04Second = 4, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.5 second. </summary>
        _05Second = 5, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.6 second. </summary>
        _06Second = 6, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.7 second. </summary>
        _07Second = 7, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.8 second. </summary>
        _08Second = 8, 

        /// <summary> The timestamp accuracy is smaller than or equal to 0.9 second. </summary>
        _09Second = 9, 

        /// <summary> The timestamp accuracy is smaller than or equal to 1.0 second. </summary>
        _10Second = 10, 

        /// <summary> The timestamp accuracy is smaller than or equal to 1.1 second. </summary>
        _11Second = 11, 

        /// <summary> The timestamp accuracy is smaller than or equal to 1.2 second. </summary>
        _12Second = 12, 

        /// <summary> The timestamp accuracy is smaller than or equal to 1.3 second. </summary>
        _13Second = 13, 

        /// <summary> The timestamp accuracy is smaller than or equal to 1.4 second. </summary>
        _14Second = 14, 

        /// <summary> The timestamp accuracy is smaller than or equal to 1.5 second. </summary>
        _15Second = 15 };

    public enum MavOdidAuthType { 

        /// <summary> No authentication type is specified. </summary>
        None = 0, 

        /// <summary> Signature for the UAS (Unmanned Aircraft System) ID. </summary>
        UasIdSignature = 1, 

        /// <summary> Signature for the Operator ID. </summary>
        OperatorIdSignature = 2, 

        /// <summary> Signature for the entire message set. </summary>
        MessageSetSignature = 3, 

        /// <summary> Authentication is provided by Network Remote ID. </summary>
        NetworkRemoteId = 4, 

        /// <summary> The exact authentication type is indicated by the first byte of authentication_data and these type values are managed by ICAO. </summary>
        SpecificAuthentication = 5 };

    public enum MavOdidDescType { 

        /// <summary> Free-form text description of the purpose of the flight. </summary>
        Text = 0 };

    public enum MavOdidOperatorLocationType { 

        /// <summary> The location of the operator is the same as the take-off location. </summary>
        Takeoff = 0, 

        /// <summary> The location of the operator is based on live GNSS data. </summary>
        LiveGnss = 1, 

        /// <summary> The location of the operator is a fixed location. </summary>
        Fixed = 2 };

    public enum MavOdidClassificationType { 

        /// <summary> The classification type for the UA is undeclared. </summary>
        Undeclared = 0, 

        /// <summary> The classification type for the UA follows EU (European Union) specifications. </summary>
        Eu = 1 };

    public enum MavOdidCategoryEu { 

        /// <summary> The category for the UA, according to the EU specification, is undeclared. </summary>
        Undeclared = 0, 

        /// <summary> The category for the UA, according to the EU specification, is the Open category. </summary>
        Open = 1, 

        /// <summary> The category for the UA, according to the EU specification, is the Specific category. </summary>
        Specific = 2, 

        /// <summary> The category for the UA, according to the EU specification, is the Certified category. </summary>
        Certified = 3 };

    public enum MavOdidClassEu { 

        /// <summary> The class for the UA, according to the EU specification, is undeclared. </summary>
        Undeclared = 0, 

        /// <summary> The class for the UA, according to the EU specification, is Class 0. </summary>
        Class0 = 1, 

        /// <summary> The class for the UA, according to the EU specification, is Class 1. </summary>
        Class1 = 2, 

        /// <summary> The class for the UA, according to the EU specification, is Class 2. </summary>
        Class2 = 3, 

        /// <summary> The class for the UA, according to the EU specification, is Class 3. </summary>
        Class3 = 4, 

        /// <summary> The class for the UA, according to the EU specification, is Class 4. </summary>
        Class4 = 5, 

        /// <summary> The class for the UA, according to the EU specification, is Class 5. </summary>
        Class5 = 6, 

        /// <summary> The class for the UA, according to the EU specification, is Class 6. </summary>
        Class6 = 7 };

    public enum MavOdidOperatorIdType { 

        /// <summary> CAA (Civil Aviation Authority) registered operator ID. </summary>
        Caa = 0 };

    /// <summary>
    /// Tune formats (used for vehicle buzzer/tone generation).
    /// </summary>
    public enum TuneFormat { 

        /// <summary> Format is QBasic 1.1 Play: https://www.qbasic.net/en/reference/qb11/Statement/PLAY-006.htm. </summary>
        Qbasic11 = 1, 

        /// <summary> Format is Modern Music Markup Language (MML): https://en.wikipedia.org/wiki/Music_Macro_Language#Modern_MML. </summary>
        MmlModern = 2 };

    /// <summary>
    /// Component capability flags (Bitmap)
    /// </summary>
    public enum ComponentCapFlags { 

        /// <summary> Component has parameters, and supports the parameter protocol (PARAM messages). </summary>
        Param = 1, 

        /// <summary> Component has parameters, and supports the extended parameter protocol (PARAM_EXT messages). </summary>
        ParamExt = 2 };

    /// <summary>
    /// Type of AIS vessel, enum duplicated from AIS standard, https://gpsd.gitlab.io/gpsd/AIVDM.html
    /// </summary>
    public enum AisType { 

        /// <summary> Not available (default). </summary>
        Unknown = 0, 

        /// <summary>  </summary>
        Reserved1 = 1, 

        /// <summary>  </summary>
        Reserved2 = 2, 

        /// <summary>  </summary>
        Reserved3 = 3, 

        /// <summary>  </summary>
        Reserved4 = 4, 

        /// <summary>  </summary>
        Reserved5 = 5, 

        /// <summary>  </summary>
        Reserved6 = 6, 

        /// <summary>  </summary>
        Reserved7 = 7, 

        /// <summary>  </summary>
        Reserved8 = 8, 

        /// <summary>  </summary>
        Reserved9 = 9, 

        /// <summary>  </summary>
        Reserved10 = 10, 

        /// <summary>  </summary>
        Reserved11 = 11, 

        /// <summary>  </summary>
        Reserved12 = 12, 

        /// <summary>  </summary>
        Reserved13 = 13, 

        /// <summary>  </summary>
        Reserved14 = 14, 

        /// <summary>  </summary>
        Reserved15 = 15, 

        /// <summary>  </summary>
        Reserved16 = 16, 

        /// <summary>  </summary>
        Reserved17 = 17, 

        /// <summary>  </summary>
        Reserved18 = 18, 

        /// <summary>  </summary>
        Reserved19 = 19, 

        /// <summary> Wing In Ground effect. </summary>
        Wig = 20, 

        /// <summary>  </summary>
        WigHazardousA = 21, 

        /// <summary>  </summary>
        WigHazardousB = 22, 

        /// <summary>  </summary>
        WigHazardousC = 23, 

        /// <summary>  </summary>
        WigHazardousD = 24, 

        /// <summary>  </summary>
        WigReserved1 = 25, 

        /// <summary>  </summary>
        WigReserved2 = 26, 

        /// <summary>  </summary>
        WigReserved3 = 27, 

        /// <summary>  </summary>
        WigReserved4 = 28, 

        /// <summary>  </summary>
        WigReserved5 = 29, 

        /// <summary>  </summary>
        Fishing = 30, 

        /// <summary>  </summary>
        Towing = 31, 

        /// <summary> Towing: length exceeds 200m or breadth exceeds 25m. </summary>
        TowingLarge = 32, 

        /// <summary> Dredging or other underwater ops. </summary>
        Dredging = 33, 

        /// <summary>  </summary>
        Diving = 34, 

        /// <summary>  </summary>
        Military = 35, 

        /// <summary>  </summary>
        Sailing = 36, 

        /// <summary>  </summary>
        Pleasure = 37, 

        /// <summary>  </summary>
        Reserved20 = 38, 

        /// <summary>  </summary>
        Reserved21 = 39, 

        /// <summary> High Speed Craft. </summary>
        Hsc = 40, 

        /// <summary>  </summary>
        HscHazardousA = 41, 

        /// <summary>  </summary>
        HscHazardousB = 42, 

        /// <summary>  </summary>
        HscHazardousC = 43, 

        /// <summary>  </summary>
        HscHazardousD = 44, 

        /// <summary>  </summary>
        HscReserved1 = 45, 

        /// <summary>  </summary>
        HscReserved2 = 46, 

        /// <summary>  </summary>
        HscReserved3 = 47, 

        /// <summary>  </summary>
        HscReserved4 = 48, 

        /// <summary>  </summary>
        HscUnknown = 49, 

        /// <summary>  </summary>
        Pilot = 50, 

        /// <summary> Search And Rescue vessel. </summary>
        Sar = 51, 

        /// <summary>  </summary>
        Tug = 52, 

        /// <summary>  </summary>
        PortTender = 53, 

        /// <summary> Anti-pollution equipment. </summary>
        AntiPollution = 54, 

        /// <summary>  </summary>
        LawEnforcement = 55, 

        /// <summary>  </summary>
        SpareLocal1 = 56, 

        /// <summary>  </summary>
        SpareLocal2 = 57, 

        /// <summary>  </summary>
        MedicalTransport = 58, 

        /// <summary> Noncombatant ship according to RR Resolution No. 18. </summary>
        Nonecombatant = 59, 

        /// <summary>  </summary>
        Passenger = 60, 

        /// <summary>  </summary>
        PassengerHazardousA = 61, 

        /// <summary>  </summary>
        PassengerHazardousB = 62, 

        /// <summary>  </summary>
        AisTypePassengerHazardousC = 63, 

        /// <summary>  </summary>
        PassengerHazardousD = 64, 

        /// <summary>  </summary>
        PassengerReserved1 = 65, 

        /// <summary>  </summary>
        PassengerReserved2 = 66, 

        /// <summary>  </summary>
        PassengerReserved3 = 67, 

        /// <summary>  </summary>
        AisTypePassengerReserved4 = 68, 

        /// <summary>  </summary>
        PassengerUnknown = 69, 

        /// <summary>  </summary>
        Cargo = 70, 

        /// <summary>  </summary>
        CargoHazardousA = 71, 

        /// <summary>  </summary>
        CargoHazardousB = 72, 

        /// <summary>  </summary>
        CargoHazardousC = 73, 

        /// <summary>  </summary>
        CargoHazardousD = 74, 

        /// <summary>  </summary>
        CargoReserved1 = 75, 

        /// <summary>  </summary>
        CargoReserved2 = 76, 

        /// <summary>  </summary>
        CargoReserved3 = 77, 

        /// <summary>  </summary>
        CargoReserved4 = 78, 

        /// <summary>  </summary>
        CargoUnknown = 79, 

        /// <summary>  </summary>
        Tanker = 80, 

        /// <summary>  </summary>
        TankerHazardousA = 81, 

        /// <summary>  </summary>
        TankerHazardousB = 82, 

        /// <summary>  </summary>
        TankerHazardousC = 83, 

        /// <summary>  </summary>
        TankerHazardousD = 84, 

        /// <summary>  </summary>
        TankerReserved1 = 85, 

        /// <summary>  </summary>
        TankerReserved2 = 86, 

        /// <summary>  </summary>
        TankerReserved3 = 87, 

        /// <summary>  </summary>
        TankerReserved4 = 88, 

        /// <summary>  </summary>
        TankerUnknown = 89, 

        /// <summary>  </summary>
        Other = 90, 

        /// <summary>  </summary>
        OtherHazardousA = 91, 

        /// <summary>  </summary>
        OtherHazardousB = 92, 

        /// <summary>  </summary>
        OtherHazardousC = 93, 

        /// <summary>  </summary>
        OtherHazardousD = 94, 

        /// <summary>  </summary>
        OtherReserved1 = 95, 

        /// <summary>  </summary>
        OtherReserved2 = 96, 

        /// <summary>  </summary>
        OtherReserved3 = 97, 

        /// <summary>  </summary>
        OtherReserved4 = 98, 

        /// <summary>  </summary>
        OtherUnknown = 99 };

    /// <summary>
    /// Navigational status of AIS vessel, enum duplicated from AIS standard, https://gpsd.gitlab.io/gpsd/AIVDM.html
    /// </summary>
    public enum AisNavStatus { 

        /// <summary> Under way using engine. </summary>
        UnderWay = 0, 

        /// <summary>  </summary>
        AisNavAnchored = 1, 

        /// <summary>  </summary>
        AisNavUnCommanded = 2, 

        /// <summary>  </summary>
        AisNavRestrictedManoeuverability = 3, 

        /// <summary>  </summary>
        AisNavDraughtConstrained = 4, 

        /// <summary>  </summary>
        AisNavMoored = 5, 

        /// <summary>  </summary>
        AisNavAground = 6, 

        /// <summary>  </summary>
        AisNavFishing = 7, 

        /// <summary>  </summary>
        AisNavSailing = 8, 

        /// <summary>  </summary>
        AisNavReservedHsc = 9, 

        /// <summary>  </summary>
        AisNavReservedWig = 10, 

        /// <summary>  </summary>
        AisNavReserved1 = 11, 

        /// <summary>  </summary>
        AisNavReserved2 = 12, 

        /// <summary>  </summary>
        AisNavReserved3 = 13, 

        /// <summary> Search And Rescue Transponder. </summary>
        AisNavAisSart = 14, 

        /// <summary> Not available (default). </summary>
        AisNavUnknown = 15 };

    /// <summary>
    /// These flags are used in the AIS_VESSEL.fields bitmask to indicate validity of data in the other message fields. When set, the data is valid.
    /// </summary>
    public enum AisFlags { 

        /// <summary> 1 = Position accuracy less than 10m, 0 = position accuracy greater than 10m. </summary>
        PositionAccuracy = 1, 

        /// <summary>  </summary>
        ValidCog = 2, 

        /// <summary>  </summary>
        ValidVelocity = 4, 

        /// <summary> 1 = Velocity over 52.5765m/s (102.2 knots) </summary>
        HighVelocity = 8, 

        /// <summary>  </summary>
        ValidTurnRate = 16, 

        /// <summary> Only the sign of the returned turn rate value is valid, either greater than 5deg/30s or less than -5deg/30s </summary>
        TurnRateSignOnly = 32, 

        /// <summary>  </summary>
        ValidDimensions = 64, 

        /// <summary> Distance to bow is larger than 511m </summary>
        LargeBowDimension = 128, 

        /// <summary> Distance to stern is larger than 511m </summary>
        LargeSternDimension = 256, 

        /// <summary> Distance to port side is larger than 63m </summary>
        LargePortDimension = 512, 

        /// <summary> Distance to starboard side is larger than 63m </summary>
        LargeStarboardDimension = 1024, 

        /// <summary>  </summary>
        ValidCallsign = 2048, 

        /// <summary>  </summary>
        ValidName = 4096 };

    /// <summary>
    /// List of possible units where failures can be injected.
    /// </summary>
    public enum FailureUnit { 

        /// <summary>  </summary>
        SensorGyro = 0, 

        /// <summary>  </summary>
        SensorAccel = 1, 

        /// <summary>  </summary>
        SensorMag = 2, 

        /// <summary>  </summary>
        SensorBaro = 3, 

        /// <summary>  </summary>
        SensorGps = 4, 

        /// <summary>  </summary>
        SensorOpticalFlow = 5, 

        /// <summary>  </summary>
        SensorVio = 6, 

        /// <summary>  </summary>
        SensorDistanceSensor = 7, 

        /// <summary>  </summary>
        SensorAirspeed = 8, 

        /// <summary>  </summary>
        SystemBattery = 100, 

        /// <summary>  </summary>
        SystemMotor = 101, 

        /// <summary>  </summary>
        SystemServo = 102, 

        /// <summary>  </summary>
        SystemAvoidance = 103, 

        /// <summary>  </summary>
        SystemRcSignal = 104, 

        /// <summary>  </summary>
        SystemMavlinkSignal = 105 };

    /// <summary>
    /// List of possible failure type to inject.
    /// </summary>
    public enum FailureType { 

        /// <summary> No failure injected, used to reset a previous failure. </summary>
        Ok = 0, 

        /// <summary> Sets unit off, so completely non-responsive. </summary>
        Off = 1, 

        /// <summary> Unit is stuck e.g. keeps reporting the same value. </summary>
        Stuck = 2, 

        /// <summary> Unit is reporting complete garbage. </summary>
        Garbage = 3, 

        /// <summary> Unit is consistently wrong. </summary>
        Wrong = 4, 

        /// <summary> Unit is slow, so e.g. reporting at slower than expected rate. </summary>
        Slow = 5, 

        /// <summary> Data of unit is delayed in time. </summary>
        Delayed = 6, 

        /// <summary> Unit is sometimes working, sometimes not. </summary>
        Intermittent = 7 };

    public enum NavVtolLandOptions { 

        /// <summary> Default autopilot landing behaviour. </summary>
        Default = 0, 

        /// <summary> Descend in fixed wing mode, transitioning to multicopter mode for vertical landing when close to the ground.           The fixed wing descent pattern is at the discretion of the vehicle (e.g. transition altitude, loiter direction, radius, and speed, etc.).          </summary>
        FwDescent = 1, 

        /// <summary> Land in multicopter mode on reaching the landing co-ordinates (the whole landing is by 'hover descent'). </summary>
        HoverDescent = 2 };

    /// <summary>
    /// Winch status flags used in WINCH_STATUS
    /// </summary>
    public enum MavWinchStatusFlag { 

        /// <summary> Winch is healthy </summary>
        MavWinchStatusHealthy = 1, 

        /// <summary> Winch thread is fully retracted </summary>
        MavWinchStatusFullyRetracted = 2, 

        /// <summary> Winch motor is moving </summary>
        MavWinchStatusMoving = 4, 

        /// <summary> Winch clutch is engaged allowing motor to move freely </summary>
        MavWinchStatusClutchEngaged = 8 };

    public enum MagCalStatus { 

        /// <summary>  </summary>
        MagCalNotStarted = 0, 

        /// <summary>  </summary>
        MagCalWaitingToStart = 1, 

        /// <summary>  </summary>
        MagCalRunningStepOne = 2, 

        /// <summary>  </summary>
        MagCalRunningStepTwo = 3, 

        /// <summary>  </summary>
        MagCalSuccess = 4, 

        /// <summary>  </summary>
        MagCalFailed = 5, 

        /// <summary>  </summary>
        MagCalBadOrientation = 6, 

        /// <summary>  </summary>
        MagCalBadRadius = 7 };

    /// <summary>
    /// Reason for an event error response.
    /// </summary>
    public enum MavEventErrorReason { 

        /// <summary> The requested event is not available (anymore). </summary>
        Unavailable = 0 };

    /// <summary>
    /// Flags for CURRENT_EVENT_SEQUENCE.
    /// </summary>
    public enum MavEventCurrentSequenceFlags { 

        /// <summary> A sequence reset has happened (e.g. vehicle reboot). </summary>
        Reset = 1 };

    /// <summary>
    /// Flags in the HIL_SENSOR message indicate which fields have updated since the last message
    /// </summary>
    public enum HilSensorUpdatedFlags { 

        /// <summary> None of the fields in HIL_SENSOR have been updated </summary>
        HilSensorUpdatedNone = 0, 

        /// <summary> The value in the xacc field has been updated </summary>
        HilSensorUpdatedXacc = 1, 

        /// <summary> The value in the yacc field has been updated </summary>
        HilSensorUpdatedYacc = 2, 

        /// <summary> The value in the zacc field has been updated </summary>
        HilSensorUpdatedZacc = 4, 

        /// <summary> The value in the xgyro field has been updated </summary>
        HilSensorUpdatedXgyro = 8, 

        /// <summary> The value in the ygyro field has been updated </summary>
        HilSensorUpdatedYgyro = 16, 

        /// <summary> The value in the zgyro field has been updated </summary>
        HilSensorUpdatedZgyro = 32, 

        /// <summary> The value in the xmag field has been updated </summary>
        HilSensorUpdatedXmag = 64, 

        /// <summary> The value in the ymag field has been updated </summary>
        HilSensorUpdatedYmag = 128, 

        /// <summary> The value in the zmag field has been updated </summary>
        HilSensorUpdatedZmag = 256, 

        /// <summary> The value in the abs_pressure field has been updated </summary>
        HilSensorUpdatedAbsPressure = 512, 

        /// <summary> The value in the diff_pressure field has been updated </summary>
        HilSensorUpdatedDiffPressure = 1024, 

        /// <summary> The value in the pressure_alt field has been updated </summary>
        HilSensorUpdatedPressureAlt = 2048, 

        /// <summary> The value in the temperature field has been updated </summary>
        HilSensorUpdatedTemperature = 4096, 

        /// <summary> Full reset of attitude/position/velocities/etc was performed in sim (Bit 31). </summary>
        HilSensorUpdatedReset = 4097 };

    /// <summary>
    /// Flags in the HIGHRES_IMU message indicate which fields have updated since the last message
    /// </summary>
    public enum HighresImuUpdatedFlags { 

        /// <summary> None of the fields in HIGHRES_IMU have been updated </summary>
        HighresImuUpdatedNone = 0, 

        /// <summary> The value in the xacc field has been updated </summary>
        HighresImuUpdatedXacc = 1, 

        /// <summary> The value in the yacc field has been updated </summary>
        HighresImuUpdatedYacc = 2, 

        /// <summary> The value in the zacc field has been updated since </summary>
        HighresImuUpdatedZacc = 4, 

        /// <summary> The value in the xgyro field has been updated </summary>
        HighresImuUpdatedXgyro = 8, 

        /// <summary> The value in the ygyro field has been updated </summary>
        HighresImuUpdatedYgyro = 16, 

        /// <summary> The value in the zgyro field has been updated </summary>
        HighresImuUpdatedZgyro = 32, 

        /// <summary> The value in the xmag field has been updated </summary>
        HighresImuUpdatedXmag = 64, 

        /// <summary> The value in the ymag field has been updated </summary>
        HighresImuUpdatedYmag = 128, 

        /// <summary> The value in the zmag field has been updated </summary>
        HighresImuUpdatedZmag = 256, 

        /// <summary> The value in the abs_pressure field has been updated </summary>
        HighresImuUpdatedAbsPressure = 512, 

        /// <summary> The value in the diff_pressure field has been updated </summary>
        HighresImuUpdatedDiffPressure = 1024, 

        /// <summary> The value in the pressure_alt field has been updated </summary>
        HighresImuUpdatedPressureAlt = 2048, 

        /// <summary> The value in the temperature field has been updated </summary>
        HighresImuUpdatedTemperature = 4096, 

        /// <summary> All fields in HIGHRES_IMU have been updated. </summary>
        HighresImuUpdatedAll = 65535 };


    // ___________________________________________________________________________________


    /// <summary>
    /// The heartbeat message shows that a system or component is present and responding. The type and autopilot fields (along with the message component id), allow the receiving system to treat further messages from this system appropriately (e.g. by laying out the user interface based on the autopilot). This microservice is documented at https://mavlink.io/en/services/heartbeat.html
    /// </summary>
    public class UasHeartbeat: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 14; }
        }
        /// <summary>
        /// A bitfield for use for autopilot-specific flags
        /// </summary>
        public UInt32 CustomMode {
            get { return mCustomMode; }
            set { mCustomMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type.
        /// </summary>
        public MavType Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.
        /// </summary>
        public MavAutopilot Autopilot {
            get { return mAutopilot; }
            set { mAutopilot = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System mode bitmap.
        /// </summary>
        public MavModeFlag BaseMode {
            get { return mBaseMode; }
            set { mBaseMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System status flag.
        /// </summary>
        public MavState SystemStatus {
            get { return mSystemStatus; }
            set { mSystemStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version
        /// </summary>
        public byte MavlinkVersion {
            get { return mMavlinkVersion; }
            set { mMavlinkVersion = value; NotifyUpdated(); }
        }

        public UasHeartbeat()
        {
            mMessageId = 0;
            CrcExtra = 50;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mCustomMode);
            s.Write((byte)mType);
            s.Write((byte)mAutopilot);
            s.Write((byte)mBaseMode);
            s.Write((byte)mSystemStatus);
            s.Write(mMavlinkVersion);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mCustomMode = s.ReadUInt32();
            this.mType = (MavType)s.ReadByte();
            this.mAutopilot = (MavAutopilot)s.ReadByte();
            this.mBaseMode = (MavModeFlag)s.ReadByte();
            this.mSystemStatus = (MavState)s.ReadByte();
            this.mMavlinkVersion = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The heartbeat message shows that a system or component is present and responding. The type and autopilot fields (along with the message component id), allow the receiving system to treat further messages from this system appropriately (e.g. by laying out the user interface based on the autopilot). This microservice is documented at https://mavlink.io/en/services/heartbeat.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomMode",
                Description = "A bitfield for use for autopilot-specific flags",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autopilot",
                Description = "Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavAutopilot"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaseMode",
                Description = "System mode bitmap.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavModeFlag"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SystemStatus",
                Description = "System status flag.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavState"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MavlinkVersion",
                Description = "MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version",
                NumElements = 1,
            });

        }

        private UInt32 mCustomMode;
        private MavType mType;
        private MavAutopilot mAutopilot;
        private MavModeFlag mBaseMode;
        private MavState mSystemStatus;
        private byte mMavlinkVersion;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows whether the system is currently active or not and if an emergency occurred. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occurred it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout.
    /// </summary>
    public class UasSysStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Bitmap showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present.
        /// </summary>
        public MavSysStatusSensor OnboardControlSensorsPresent {
            get { return mOnboardControlSensorsPresent; }
            set { mOnboardControlSensorsPresent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled.
        /// </summary>
        public MavSysStatusSensor OnboardControlSensorsEnabled {
            get { return mOnboardControlSensorsEnabled; }
            set { mOnboardControlSensorsEnabled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap showing which onboard controllers and sensors have an error (or are operational). Value of 0: error. Value of 1: healthy.
        /// </summary>
        public MavSysStatusSensor OnboardControlSensorsHealth {
            get { return mOnboardControlSensorsHealth; }
            set { mOnboardControlSensorsHealth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum usage in percent of the mainloop time. Values: [0-1000] - should always be below 1000
        /// </summary>
        public UInt16 Load {
            get { return mLoad; }
            set { mLoad = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery voltage, UINT16_MAX: Voltage not sent by autopilot
        /// </summary>
        public UInt16 VoltageBattery {
            get { return mVoltageBattery; }
            set { mVoltageBattery = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery current, -1: Current not sent by autopilot
        /// </summary>
        public Int16 CurrentBattery {
            get { return mCurrentBattery; }
            set { mCurrentBattery = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Communication drop rate, (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
        /// </summary>
        public UInt16 DropRateComm {
            get { return mDropRateComm; }
            set { mDropRateComm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
        /// </summary>
        public UInt16 ErrorsComm {
            get { return mErrorsComm; }
            set { mErrorsComm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot-specific errors
        /// </summary>
        public UInt16 ErrorsCount1 {
            get { return mErrorsCount1; }
            set { mErrorsCount1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot-specific errors
        /// </summary>
        public UInt16 ErrorsCount2 {
            get { return mErrorsCount2; }
            set { mErrorsCount2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot-specific errors
        /// </summary>
        public UInt16 ErrorsCount3 {
            get { return mErrorsCount3; }
            set { mErrorsCount3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot-specific errors
        /// </summary>
        public UInt16 ErrorsCount4 {
            get { return mErrorsCount4; }
            set { mErrorsCount4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery energy remaining, -1: Battery remaining energy not sent by autopilot
        /// </summary>
        public SByte BatteryRemaining {
            get { return mBatteryRemaining; }
            set { mBatteryRemaining = value; NotifyUpdated(); }
        }

        public UasSysStatus()
        {
            mMessageId = 1;
            CrcExtra = 124;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write((UInt32)mOnboardControlSensorsPresent);
            s.Write((UInt32)mOnboardControlSensorsEnabled);
            s.Write((UInt32)mOnboardControlSensorsHealth);
            s.Write(mLoad);
            s.Write(mVoltageBattery);
            s.Write(mCurrentBattery);
            s.Write(mDropRateComm);
            s.Write(mErrorsComm);
            s.Write(mErrorsCount1);
            s.Write(mErrorsCount2);
            s.Write(mErrorsCount3);
            s.Write(mErrorsCount4);
            s.Write(mBatteryRemaining);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mOnboardControlSensorsPresent = (MavSysStatusSensor)s.ReadUInt32();
            this.mOnboardControlSensorsEnabled = (MavSysStatusSensor)s.ReadUInt32();
            this.mOnboardControlSensorsHealth = (MavSysStatusSensor)s.ReadUInt32();
            this.mLoad = s.ReadUInt16();
            this.mVoltageBattery = s.ReadUInt16();
            this.mCurrentBattery = s.ReadInt16();
            this.mDropRateComm = s.ReadUInt16();
            this.mErrorsComm = s.ReadUInt16();
            this.mErrorsCount1 = s.ReadUInt16();
            this.mErrorsCount2 = s.ReadUInt16();
            this.mErrorsCount3 = s.ReadUInt16();
            this.mErrorsCount4 = s.ReadUInt16();
            this.mBatteryRemaining = s.ReadSByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows whether the system is currently active or not and if an emergency occurred. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occurred it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OnboardControlSensorsPresent",
                Description = "Bitmap showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSysStatusSensor"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OnboardControlSensorsEnabled",
                Description = "Bitmap showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSysStatusSensor"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OnboardControlSensorsHealth",
                Description = "Bitmap showing which onboard controllers and sensors have an error (or are operational). Value of 0: error. Value of 1: healthy.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSysStatusSensor"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Load",
                Description = "Maximum usage in percent of the mainloop time. Values: [0-1000] - should always be below 1000",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VoltageBattery",
                Description = "Battery voltage, UINT16_MAX: Voltage not sent by autopilot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentBattery",
                Description = "Battery current, -1: Current not sent by autopilot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DropRateComm",
                Description = "Communication drop rate, (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsComm",
                Description = "Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsCount1",
                Description = "Autopilot-specific errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsCount2",
                Description = "Autopilot-specific errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsCount3",
                Description = "Autopilot-specific errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsCount4",
                Description = "Autopilot-specific errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BatteryRemaining",
                Description = "Battery energy remaining, -1: Battery remaining energy not sent by autopilot",
                NumElements = 1,
            });

        }

        private MavSysStatusSensor mOnboardControlSensorsPresent;
        private MavSysStatusSensor mOnboardControlSensorsEnabled;
        private MavSysStatusSensor mOnboardControlSensorsHealth;
        private UInt16 mLoad;
        private UInt16 mVoltageBattery;
        private Int16 mCurrentBattery;
        private UInt16 mDropRateComm;
        private UInt16 mErrorsComm;
        private UInt16 mErrorsCount1;
        private UInt16 mErrorsCount2;
        private UInt16 mErrorsCount3;
        private UInt16 mErrorsCount4;
        private SByte mBatteryRemaining;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The system time is the time of the master clock, typically the computer clock of the main onboard computer.
    /// </summary>
    public class UasSystemTime: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 12; }
        }
        /// <summary>
        /// Timestamp (UNIX epoch time).
        /// </summary>
        public UInt64 TimeUnixUsec {
            get { return mTimeUnixUsec; }
            set { mTimeUnixUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        public UasSystemTime()
        {
            mMessageId = 2;
            CrcExtra = 137;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUnixUsec);
            s.Write(mTimeBootMs);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUnixUsec = s.ReadUInt64();
            this.mTimeBootMs = s.ReadUInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The system time is the time of the master clock, typically the computer clock of the main onboard computer."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUnixUsec",
                Description = "Timestamp (UNIX epoch time).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUnixUsec;
        private UInt32 mTimeBootMs;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections. The ping microservice is documented at https://mavlink.io/en/services/ping.html
    /// </summary>
    public class UasPing: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 16; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PING sequence
        /// </summary>
        public UInt32 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: request ping from all receiving systems. If greater than 0: message is a ping response and number is the system id of the requesting system
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: request ping from all receiving components. If greater than 0: message is a ping response and number is the component id of the requesting component.
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasPing()
        {
            mMessageId = 4;
            CrcExtra = 237;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mSeq);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mSeq = s.ReadUInt32();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections. The ping microservice is documented at https://mavlink.io/en/services/ping.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "PING sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "0: request ping from all receiving systems. If greater than 0: message is a ping response and number is the system id of the requesting system",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "0: request ping from all receiving components. If greater than 0: message is a ping response and number is the component id of the requesting component.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mSeq;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request to control this MAV
    /// </summary>
    public class UasChangeOperatorControl: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 56; }
        }
        /// <summary>
        /// System the GCS requests control for
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: request control of this MAV, 1: Release control of this MAV
        /// </summary>
        public byte ControlRequest {
            get { return mControlRequest; }
            set { mControlRequest = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
        /// </summary>
        public byte Version {
            get { return mVersion; }
            set { mVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and '!?,.-'
        /// </summary>
        public char[] Passkey {
            get { return mPasskey; }
            set { mPasskey = value; NotifyUpdated(); }
        }

        public UasChangeOperatorControl()
        {
            mMessageId = 5;
            CrcExtra = 217;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetSystem);
            s.Write(mControlRequest);
            s.Write(mVersion);
            s.Write(mPasskey[0]); 
            s.Write(mPasskey[1]); 
            s.Write(mPasskey[2]); 
            s.Write(mPasskey[3]); 
            s.Write(mPasskey[4]); 
            s.Write(mPasskey[5]); 
            s.Write(mPasskey[6]); 
            s.Write(mPasskey[7]); 
            s.Write(mPasskey[8]); 
            s.Write(mPasskey[9]); 
            s.Write(mPasskey[10]); 
            s.Write(mPasskey[11]); 
            s.Write(mPasskey[12]); 
            s.Write(mPasskey[13]); 
            s.Write(mPasskey[14]); 
            s.Write(mPasskey[15]); 
            s.Write(mPasskey[16]); 
            s.Write(mPasskey[17]); 
            s.Write(mPasskey[18]); 
            s.Write(mPasskey[19]); 
            s.Write(mPasskey[20]); 
            s.Write(mPasskey[21]); 
            s.Write(mPasskey[22]); 
            s.Write(mPasskey[23]); 
            s.Write(mPasskey[24]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetSystem = s.ReadByte();
            this.mControlRequest = s.ReadByte();
            this.mVersion = s.ReadByte();
            this.mPasskey[0] = s.ReadChar();
            this.mPasskey[1] = s.ReadChar();
            this.mPasskey[2] = s.ReadChar();
            this.mPasskey[3] = s.ReadChar();
            this.mPasskey[4] = s.ReadChar();
            this.mPasskey[5] = s.ReadChar();
            this.mPasskey[6] = s.ReadChar();
            this.mPasskey[7] = s.ReadChar();
            this.mPasskey[8] = s.ReadChar();
            this.mPasskey[9] = s.ReadChar();
            this.mPasskey[10] = s.ReadChar();
            this.mPasskey[11] = s.ReadChar();
            this.mPasskey[12] = s.ReadChar();
            this.mPasskey[13] = s.ReadChar();
            this.mPasskey[14] = s.ReadChar();
            this.mPasskey[15] = s.ReadChar();
            this.mPasskey[16] = s.ReadChar();
            this.mPasskey[17] = s.ReadChar();
            this.mPasskey[18] = s.ReadChar();
            this.mPasskey[19] = s.ReadChar();
            this.mPasskey[20] = s.ReadChar();
            this.mPasskey[21] = s.ReadChar();
            this.mPasskey[22] = s.ReadChar();
            this.mPasskey[23] = s.ReadChar();
            this.mPasskey[24] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request to control this MAV"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System the GCS requests control for",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ControlRequest",
                Description = "0: request control of this MAV, 1: Release control of this MAV",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Version",
                Description = "0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Passkey",
                Description = "Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and '!?,.-'",
                NumElements = 25,
            });

        }

        private byte mTargetSystem;
        private byte mControlRequest;
        private byte mVersion;
        private char[] mPasskey = new char[25];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Accept / deny control of this MAV
    /// </summary>
    public class UasChangeOperatorControlAck: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// ID of the GCS this message 
        /// </summary>
        public byte GcsSystemId {
            get { return mGcsSystemId; }
            set { mGcsSystemId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: request control of this MAV, 1: Release control of this MAV
        /// </summary>
        public byte ControlRequest {
            get { return mControlRequest; }
            set { mControlRequest = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
        /// </summary>
        public byte Ack {
            get { return mAck; }
            set { mAck = value; NotifyUpdated(); }
        }

        public UasChangeOperatorControlAck()
        {
            mMessageId = 6;
            CrcExtra = 104;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mGcsSystemId);
            s.Write(mControlRequest);
            s.Write(mAck);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mGcsSystemId = s.ReadByte();
            this.mControlRequest = s.ReadByte();
            this.mAck = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Accept / deny control of this MAV"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GcsSystemId",
                Description = "ID of the GCS this message ",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ControlRequest",
                Description = "0: request control of this MAV, 1: Release control of this MAV",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ack",
                Description = "0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control",
                NumElements = 1,
            });

        }

        private byte mGcsSystemId;
        private byte mControlRequest;
        private byte mAck;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety.
    /// </summary>
    public class UasAuthKey: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 64; }
        }
        /// <summary>
        /// key
        /// </summary>
        public char[] Key {
            get { return mKey; }
            set { mKey = value; NotifyUpdated(); }
        }

        public UasAuthKey()
        {
            mMessageId = 7;
            CrcExtra = 119;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mKey[0]); 
            s.Write(mKey[1]); 
            s.Write(mKey[2]); 
            s.Write(mKey[3]); 
            s.Write(mKey[4]); 
            s.Write(mKey[5]); 
            s.Write(mKey[6]); 
            s.Write(mKey[7]); 
            s.Write(mKey[8]); 
            s.Write(mKey[9]); 
            s.Write(mKey[10]); 
            s.Write(mKey[11]); 
            s.Write(mKey[12]); 
            s.Write(mKey[13]); 
            s.Write(mKey[14]); 
            s.Write(mKey[15]); 
            s.Write(mKey[16]); 
            s.Write(mKey[17]); 
            s.Write(mKey[18]); 
            s.Write(mKey[19]); 
            s.Write(mKey[20]); 
            s.Write(mKey[21]); 
            s.Write(mKey[22]); 
            s.Write(mKey[23]); 
            s.Write(mKey[24]); 
            s.Write(mKey[25]); 
            s.Write(mKey[26]); 
            s.Write(mKey[27]); 
            s.Write(mKey[28]); 
            s.Write(mKey[29]); 
            s.Write(mKey[30]); 
            s.Write(mKey[31]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mKey[0] = s.ReadChar();
            this.mKey[1] = s.ReadChar();
            this.mKey[2] = s.ReadChar();
            this.mKey[3] = s.ReadChar();
            this.mKey[4] = s.ReadChar();
            this.mKey[5] = s.ReadChar();
            this.mKey[6] = s.ReadChar();
            this.mKey[7] = s.ReadChar();
            this.mKey[8] = s.ReadChar();
            this.mKey[9] = s.ReadChar();
            this.mKey[10] = s.ReadChar();
            this.mKey[11] = s.ReadChar();
            this.mKey[12] = s.ReadChar();
            this.mKey[13] = s.ReadChar();
            this.mKey[14] = s.ReadChar();
            this.mKey[15] = s.ReadChar();
            this.mKey[16] = s.ReadChar();
            this.mKey[17] = s.ReadChar();
            this.mKey[18] = s.ReadChar();
            this.mKey[19] = s.ReadChar();
            this.mKey[20] = s.ReadChar();
            this.mKey[21] = s.ReadChar();
            this.mKey[22] = s.ReadChar();
            this.mKey[23] = s.ReadChar();
            this.mKey[24] = s.ReadChar();
            this.mKey[25] = s.ReadChar();
            this.mKey[26] = s.ReadChar();
            this.mKey[27] = s.ReadChar();
            this.mKey[28] = s.ReadChar();
            this.mKey[29] = s.ReadChar();
            this.mKey[30] = s.ReadChar();
            this.mKey[31] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Key",
                Description = "key",
                NumElements = 32,
            });

        }

        private char[] mKey = new char[32];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status generated in each node in the communication chain and injected into MAVLink stream.
    /// </summary>
    public class UasLinkNodeStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 38; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt64 Timestamp {
            get { return mTimestamp; }
            set { mTimestamp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Transmit rate
        /// </summary>
        public UInt32 TxRate {
            get { return mTxRate; }
            set { mTxRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive rate
        /// </summary>
        public UInt32 RxRate {
            get { return mRxRate; }
            set { mRxRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Messages sent
        /// </summary>
        public UInt32 MessagesSent {
            get { return mMessagesSent; }
            set { mMessagesSent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Messages received (estimated from counting seq)
        /// </summary>
        public UInt32 MessagesReceived {
            get { return mMessagesReceived; }
            set { mMessagesReceived = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Messages lost (estimated from counting seq)
        /// </summary>
        public UInt32 MessagesLost {
            get { return mMessagesLost; }
            set { mMessagesLost = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of bytes that could not be parsed correctly.
        /// </summary>
        public UInt16 RxParseErr {
            get { return mRxParseErr; }
            set { mRxParseErr = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Transmit buffer overflows. This number wraps around as it reaches UINT16_MAX
        /// </summary>
        public UInt16 TxOverflows {
            get { return mTxOverflows; }
            set { mTxOverflows = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive buffer overflows. This number wraps around as it reaches UINT16_MAX
        /// </summary>
        public UInt16 RxOverflows {
            get { return mRxOverflows; }
            set { mRxOverflows = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remaining free transmit buffer space
        /// </summary>
        public byte TxBuf {
            get { return mTxBuf; }
            set { mTxBuf = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remaining free receive buffer space
        /// </summary>
        public byte RxBuf {
            get { return mRxBuf; }
            set { mRxBuf = value; NotifyUpdated(); }
        }

        public UasLinkNodeStatus()
        {
            mMessageId = 8;
            CrcExtra = 117;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimestamp);
            s.Write(mTxRate);
            s.Write(mRxRate);
            s.Write(mMessagesSent);
            s.Write(mMessagesReceived);
            s.Write(mMessagesLost);
            s.Write(mRxParseErr);
            s.Write(mTxOverflows);
            s.Write(mRxOverflows);
            s.Write(mTxBuf);
            s.Write(mRxBuf);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimestamp = s.ReadUInt64();
            this.mTxRate = s.ReadUInt32();
            this.mRxRate = s.ReadUInt32();
            this.mMessagesSent = s.ReadUInt32();
            this.mMessagesReceived = s.ReadUInt32();
            this.mMessagesLost = s.ReadUInt32();
            this.mRxParseErr = s.ReadUInt16();
            this.mTxOverflows = s.ReadUInt16();
            this.mRxOverflows = s.ReadUInt16();
            this.mTxBuf = s.ReadByte();
            this.mRxBuf = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status generated in each node in the communication chain and injected into MAVLink stream."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Timestamp",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TxRate",
                Description = "Transmit rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RxRate",
                Description = "Receive rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessagesSent",
                Description = "Messages sent",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessagesReceived",
                Description = "Messages received (estimated from counting seq)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessagesLost",
                Description = "Messages lost (estimated from counting seq)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RxParseErr",
                Description = "Number of bytes that could not be parsed correctly.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TxOverflows",
                Description = "Transmit buffer overflows. This number wraps around as it reaches UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RxOverflows",
                Description = "Receive buffer overflows. This number wraps around as it reaches UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TxBuf",
                Description = "Remaining free transmit buffer space",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RxBuf",
                Description = "Remaining free receive buffer space",
                NumElements = 1,
            });

        }

        private UInt64 mTimestamp;
        private UInt32 mTxRate;
        private UInt32 mRxRate;
        private UInt32 mMessagesSent;
        private UInt32 mMessagesReceived;
        private UInt32 mMessagesLost;
        private UInt16 mRxParseErr;
        private UInt16 mTxOverflows;
        private UInt16 mRxOverflows;
        private byte mTxBuf;
        private byte mRxBuf;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component.
    /// </summary>
    public class UasSetMode: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 8; }
        }
        /// <summary>
        /// The new autopilot-specific mode. This field can be ignored by an autopilot.
        /// </summary>
        public UInt32 CustomMode {
            get { return mCustomMode; }
            set { mCustomMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The system setting the mode
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The new base mode.
        /// </summary>
        public MavMode BaseMode {
            get { return mBaseMode; }
            set { mBaseMode = value; NotifyUpdated(); }
        }

        public UasSetMode()
        {
            mMessageId = 11;
            CrcExtra = 89;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mCustomMode);
            s.Write(mTargetSystem);
            s.Write((byte)mBaseMode);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mCustomMode = s.ReadUInt32();
            this.mTargetSystem = s.ReadByte();
            this.mBaseMode = (MavMode)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomMode",
                Description = "The new autopilot-specific mode. This field can be ignored by an autopilot.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "The system setting the mode",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaseMode",
                Description = "The new base mode.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavMode"),
            });

        }

        private UInt32 mCustomMode;
        private byte mTargetSystem;
        private MavMode mBaseMode;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also https://mavlink.io/en/services/parameter.html for a full documentation of QGroundControl and IMU code.
    /// </summary>
    public class UasParamRequestRead: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 38; }
        }
        /// <summary>
        /// Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
        /// </summary>
        public Int16 ParamIndex {
            get { return mParamIndex; }
            set { mParamIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
        /// </summary>
        public char[] ParamId {
            get { return mParamId; }
            set { mParamId = value; NotifyUpdated(); }
        }

        public UasParamRequestRead()
        {
            mMessageId = 20;
            CrcExtra = 214;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mParamIndex);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mParamId[0]); 
            s.Write(mParamId[1]); 
            s.Write(mParamId[2]); 
            s.Write(mParamId[3]); 
            s.Write(mParamId[4]); 
            s.Write(mParamId[5]); 
            s.Write(mParamId[6]); 
            s.Write(mParamId[7]); 
            s.Write(mParamId[8]); 
            s.Write(mParamId[9]); 
            s.Write(mParamId[10]); 
            s.Write(mParamId[11]); 
            s.Write(mParamId[12]); 
            s.Write(mParamId[13]); 
            s.Write(mParamId[14]); 
            s.Write(mParamId[15]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mParamIndex = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mParamId[0] = s.ReadChar();
            this.mParamId[1] = s.ReadChar();
            this.mParamId[2] = s.ReadChar();
            this.mParamId[3] = s.ReadChar();
            this.mParamId[4] = s.ReadChar();
            this.mParamId[5] = s.ReadChar();
            this.mParamId[6] = s.ReadChar();
            this.mParamId[7] = s.ReadChar();
            this.mParamId[8] = s.ReadChar();
            this.mParamId[9] = s.ReadChar();
            this.mParamId[10] = s.ReadChar();
            this.mParamId[11] = s.ReadChar();
            this.mParamId[12] = s.ReadChar();
            this.mParamId[13] = s.ReadChar();
            this.mParamId[14] = s.ReadChar();
            this.mParamId[15] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also https://mavlink.io/en/services/parameter.html for a full documentation of QGroundControl and IMU code."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamIndex",
                Description = "Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamId",
                Description = "Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string",
                NumElements = 16,
            });

        }

        private Int16 mParamIndex;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private char[] mParamId = new char[16];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request all parameters of this component. After this request, all parameters are emitted. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
    /// </summary>
    public class UasParamRequestList: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 4; }
        }
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasParamRequestList()
        {
            mMessageId = 21;
            CrcExtra = 159;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request all parameters of this component. After this request, all parameters are emitted. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
    /// </summary>
    public class UasParamValue: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 42; }
        }
        /// <summary>
        /// Onboard parameter value
        /// </summary>
        public float ParamValue {
            get { return mParamValue; }
            set { mParamValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Total number of onboard parameters
        /// </summary>
        public UInt16 ParamCount {
            get { return mParamCount; }
            set { mParamCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Index of this onboard parameter
        /// </summary>
        public UInt16 ParamIndex {
            get { return mParamIndex; }
            set { mParamIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
        /// </summary>
        public char[] ParamId {
            get { return mParamId; }
            set { mParamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter type.
        /// </summary>
        public MavParamType ParamType {
            get { return mParamType; }
            set { mParamType = value; NotifyUpdated(); }
        }

        public UasParamValue()
        {
            mMessageId = 22;
            CrcExtra = 220;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mParamValue);
            s.Write(mParamCount);
            s.Write(mParamIndex);
            s.Write(mParamId[0]); 
            s.Write(mParamId[1]); 
            s.Write(mParamId[2]); 
            s.Write(mParamId[3]); 
            s.Write(mParamId[4]); 
            s.Write(mParamId[5]); 
            s.Write(mParamId[6]); 
            s.Write(mParamId[7]); 
            s.Write(mParamId[8]); 
            s.Write(mParamId[9]); 
            s.Write(mParamId[10]); 
            s.Write(mParamId[11]); 
            s.Write(mParamId[12]); 
            s.Write(mParamId[13]); 
            s.Write(mParamId[14]); 
            s.Write(mParamId[15]); 
            s.Write((byte)mParamType);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mParamValue = s.ReadSingle();
            this.mParamCount = s.ReadUInt16();
            this.mParamIndex = s.ReadUInt16();
            this.mParamId[0] = s.ReadChar();
            this.mParamId[1] = s.ReadChar();
            this.mParamId[2] = s.ReadChar();
            this.mParamId[3] = s.ReadChar();
            this.mParamId[4] = s.ReadChar();
            this.mParamId[5] = s.ReadChar();
            this.mParamId[6] = s.ReadChar();
            this.mParamId[7] = s.ReadChar();
            this.mParamId[8] = s.ReadChar();
            this.mParamId[9] = s.ReadChar();
            this.mParamId[10] = s.ReadChar();
            this.mParamId[11] = s.ReadChar();
            this.mParamId[12] = s.ReadChar();
            this.mParamId[13] = s.ReadChar();
            this.mParamId[14] = s.ReadChar();
            this.mParamId[15] = s.ReadChar();
            this.mParamType = (MavParamType)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValue",
                Description = "Onboard parameter value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamCount",
                Description = "Total number of onboard parameters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamIndex",
                Description = "Index of this onboard parameter",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamId",
                Description = "Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamType",
                Description = "Onboard parameter type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavParamType"),
            });

        }

        private float mParamValue;
        private UInt16 mParamCount;
        private UInt16 mParamIndex;
        private char[] mParamId = new char[16];
        private MavParamType mParamType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set a parameter value (write new value to permanent storage).         The receiving component should acknowledge the new parameter value by broadcasting a PARAM_VALUE message (broadcasting ensures that multiple GCS all have an up-to-date list of all parameters). If the sending GCS did not receive a PARAM_VALUE within its timeout time, it should re-send the PARAM_SET message. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html.         PARAM_SET may also be called within the context of a transaction (started with MAV_CMD_PARAM_TRANSACTION). Within a transaction the receiving component should respond with PARAM_ACK_TRANSACTION to the setter component (instead of broadcasting PARAM_VALUE), and PARAM_SET should be re-sent if this is ACK not received.
    /// </summary>
    public class UasParamSet: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 42; }
        }
        /// <summary>
        /// Onboard parameter value
        /// </summary>
        public float ParamValue {
            get { return mParamValue; }
            set { mParamValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
        /// </summary>
        public char[] ParamId {
            get { return mParamId; }
            set { mParamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter type.
        /// </summary>
        public MavParamType ParamType {
            get { return mParamType; }
            set { mParamType = value; NotifyUpdated(); }
        }

        public UasParamSet()
        {
            mMessageId = 23;
            CrcExtra = 168;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mParamValue);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mParamId[0]); 
            s.Write(mParamId[1]); 
            s.Write(mParamId[2]); 
            s.Write(mParamId[3]); 
            s.Write(mParamId[4]); 
            s.Write(mParamId[5]); 
            s.Write(mParamId[6]); 
            s.Write(mParamId[7]); 
            s.Write(mParamId[8]); 
            s.Write(mParamId[9]); 
            s.Write(mParamId[10]); 
            s.Write(mParamId[11]); 
            s.Write(mParamId[12]); 
            s.Write(mParamId[13]); 
            s.Write(mParamId[14]); 
            s.Write(mParamId[15]); 
            s.Write((byte)mParamType);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mParamValue = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mParamId[0] = s.ReadChar();
            this.mParamId[1] = s.ReadChar();
            this.mParamId[2] = s.ReadChar();
            this.mParamId[3] = s.ReadChar();
            this.mParamId[4] = s.ReadChar();
            this.mParamId[5] = s.ReadChar();
            this.mParamId[6] = s.ReadChar();
            this.mParamId[7] = s.ReadChar();
            this.mParamId[8] = s.ReadChar();
            this.mParamId[9] = s.ReadChar();
            this.mParamId[10] = s.ReadChar();
            this.mParamId[11] = s.ReadChar();
            this.mParamId[12] = s.ReadChar();
            this.mParamId[13] = s.ReadChar();
            this.mParamId[14] = s.ReadChar();
            this.mParamId[15] = s.ReadChar();
            this.mParamType = (MavParamType)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set a parameter value (write new value to permanent storage).         The receiving component should acknowledge the new parameter value by broadcasting a PARAM_VALUE message (broadcasting ensures that multiple GCS all have an up-to-date list of all parameters). If the sending GCS did not receive a PARAM_VALUE within its timeout time, it should re-send the PARAM_SET message. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html.         PARAM_SET may also be called within the context of a transaction (started with MAV_CMD_PARAM_TRANSACTION). Within a transaction the receiving component should respond with PARAM_ACK_TRANSACTION to the setter component (instead of broadcasting PARAM_VALUE), and PARAM_SET should be re-sent if this is ACK not received."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValue",
                Description = "Onboard parameter value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamId",
                Description = "Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamType",
                Description = "Onboard parameter type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavParamType"),
            });

        }

        private float mParamValue;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private char[] mParamId = new char[16];
        private MavParamType mParamType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The global position, as returned by the Global Positioning System (GPS). This is                 NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION_INT for the global position estimate.
    /// </summary>
    public class UasGpsRawInt: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84, EGM96 ellipsoid)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84, EGM96 ellipsoid)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Positive for up. Note that virtually all GPS modules provide the MSL altitude in addition to the WGS84 altitude.
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Eph {
            get { return mEph; }
            set { mEph = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Epv {
            get { return mEpv; }
            set { mEpv = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS ground speed. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Vel {
            get { return mVel; }
            set { mVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Cog {
            get { return mCog; }
            set { mCog = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS fix type.
        /// </summary>
        public GpsFixType FixType {
            get { return mFixType; }
            set { mFixType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of satellites visible. If unknown, set to UINT8_MAX
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        public UasGpsRawInt()
        {
            mMessageId = 24;
            CrcExtra = 24;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mEph);
            s.Write(mEpv);
            s.Write(mVel);
            s.Write(mCog);
            s.Write((byte)mFixType);
            s.Write(mSatellitesVisible);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mEph = s.ReadUInt16();
            this.mEpv = s.ReadUInt16();
            this.mVel = s.ReadUInt16();
            this.mCog = s.ReadUInt16();
            this.mFixType = (GpsFixType)s.ReadByte();
            this.mSatellitesVisible = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The global position, as returned by the Global Positioning System (GPS). This is                 NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION_INT for the global position estimate."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84, EGM96 ellipsoid)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84, EGM96 ellipsoid)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (MSL). Positive for up. Note that virtually all GPS modules provide the MSL altitude in addition to the WGS84 altitude.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Eph",
                Description = "GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Epv",
                Description = "GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vel",
                Description = "GPS ground speed. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Cog",
                Description = "Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FixType",
                Description = "GPS fix type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("GpsFixType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible. If unknown, set to UINT8_MAX",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private UInt16 mEph;
        private UInt16 mEpv;
        private UInt16 mVel;
        private UInt16 mCog;
        private GpsFixType mFixType;
        private byte mSatellitesVisible;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION_INT for the global position estimate. This message can contain information for up to 20 satellites.
    /// </summary>
    public class UasGpsStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 202; }
        }
        /// <summary>
        /// Number of satellites visible
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global satellite ID
        /// </summary>
        public byte[] SatellitePrn {
            get { return mSatellitePrn; }
            set { mSatellitePrn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: Satellite not used, 1: used for localization
        /// </summary>
        public byte[] SatelliteUsed {
            get { return mSatelliteUsed; }
            set { mSatelliteUsed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Elevation (0: right on top of receiver, 90: on the horizon) of satellite
        /// </summary>
        public byte[] SatelliteElevation {
            get { return mSatelliteElevation; }
            set { mSatelliteElevation = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Direction of satellite, 0: 0 deg, 255: 360 deg.
        /// </summary>
        public byte[] SatelliteAzimuth {
            get { return mSatelliteAzimuth; }
            set { mSatelliteAzimuth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Signal to noise ratio of satellite
        /// </summary>
        public byte[] SatelliteSnr {
            get { return mSatelliteSnr; }
            set { mSatelliteSnr = value; NotifyUpdated(); }
        }

        public UasGpsStatus()
        {
            mMessageId = 25;
            CrcExtra = 23;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mSatellitesVisible);
            s.Write(mSatellitePrn[0]); 
            s.Write(mSatellitePrn[1]); 
            s.Write(mSatellitePrn[2]); 
            s.Write(mSatellitePrn[3]); 
            s.Write(mSatellitePrn[4]); 
            s.Write(mSatellitePrn[5]); 
            s.Write(mSatellitePrn[6]); 
            s.Write(mSatellitePrn[7]); 
            s.Write(mSatellitePrn[8]); 
            s.Write(mSatellitePrn[9]); 
            s.Write(mSatellitePrn[10]); 
            s.Write(mSatellitePrn[11]); 
            s.Write(mSatellitePrn[12]); 
            s.Write(mSatellitePrn[13]); 
            s.Write(mSatellitePrn[14]); 
            s.Write(mSatellitePrn[15]); 
            s.Write(mSatellitePrn[16]); 
            s.Write(mSatellitePrn[17]); 
            s.Write(mSatellitePrn[18]); 
            s.Write(mSatellitePrn[19]); 
            s.Write(mSatelliteUsed[0]); 
            s.Write(mSatelliteUsed[1]); 
            s.Write(mSatelliteUsed[2]); 
            s.Write(mSatelliteUsed[3]); 
            s.Write(mSatelliteUsed[4]); 
            s.Write(mSatelliteUsed[5]); 
            s.Write(mSatelliteUsed[6]); 
            s.Write(mSatelliteUsed[7]); 
            s.Write(mSatelliteUsed[8]); 
            s.Write(mSatelliteUsed[9]); 
            s.Write(mSatelliteUsed[10]); 
            s.Write(mSatelliteUsed[11]); 
            s.Write(mSatelliteUsed[12]); 
            s.Write(mSatelliteUsed[13]); 
            s.Write(mSatelliteUsed[14]); 
            s.Write(mSatelliteUsed[15]); 
            s.Write(mSatelliteUsed[16]); 
            s.Write(mSatelliteUsed[17]); 
            s.Write(mSatelliteUsed[18]); 
            s.Write(mSatelliteUsed[19]); 
            s.Write(mSatelliteElevation[0]); 
            s.Write(mSatelliteElevation[1]); 
            s.Write(mSatelliteElevation[2]); 
            s.Write(mSatelliteElevation[3]); 
            s.Write(mSatelliteElevation[4]); 
            s.Write(mSatelliteElevation[5]); 
            s.Write(mSatelliteElevation[6]); 
            s.Write(mSatelliteElevation[7]); 
            s.Write(mSatelliteElevation[8]); 
            s.Write(mSatelliteElevation[9]); 
            s.Write(mSatelliteElevation[10]); 
            s.Write(mSatelliteElevation[11]); 
            s.Write(mSatelliteElevation[12]); 
            s.Write(mSatelliteElevation[13]); 
            s.Write(mSatelliteElevation[14]); 
            s.Write(mSatelliteElevation[15]); 
            s.Write(mSatelliteElevation[16]); 
            s.Write(mSatelliteElevation[17]); 
            s.Write(mSatelliteElevation[18]); 
            s.Write(mSatelliteElevation[19]); 
            s.Write(mSatelliteAzimuth[0]); 
            s.Write(mSatelliteAzimuth[1]); 
            s.Write(mSatelliteAzimuth[2]); 
            s.Write(mSatelliteAzimuth[3]); 
            s.Write(mSatelliteAzimuth[4]); 
            s.Write(mSatelliteAzimuth[5]); 
            s.Write(mSatelliteAzimuth[6]); 
            s.Write(mSatelliteAzimuth[7]); 
            s.Write(mSatelliteAzimuth[8]); 
            s.Write(mSatelliteAzimuth[9]); 
            s.Write(mSatelliteAzimuth[10]); 
            s.Write(mSatelliteAzimuth[11]); 
            s.Write(mSatelliteAzimuth[12]); 
            s.Write(mSatelliteAzimuth[13]); 
            s.Write(mSatelliteAzimuth[14]); 
            s.Write(mSatelliteAzimuth[15]); 
            s.Write(mSatelliteAzimuth[16]); 
            s.Write(mSatelliteAzimuth[17]); 
            s.Write(mSatelliteAzimuth[18]); 
            s.Write(mSatelliteAzimuth[19]); 
            s.Write(mSatelliteSnr[0]); 
            s.Write(mSatelliteSnr[1]); 
            s.Write(mSatelliteSnr[2]); 
            s.Write(mSatelliteSnr[3]); 
            s.Write(mSatelliteSnr[4]); 
            s.Write(mSatelliteSnr[5]); 
            s.Write(mSatelliteSnr[6]); 
            s.Write(mSatelliteSnr[7]); 
            s.Write(mSatelliteSnr[8]); 
            s.Write(mSatelliteSnr[9]); 
            s.Write(mSatelliteSnr[10]); 
            s.Write(mSatelliteSnr[11]); 
            s.Write(mSatelliteSnr[12]); 
            s.Write(mSatelliteSnr[13]); 
            s.Write(mSatelliteSnr[14]); 
            s.Write(mSatelliteSnr[15]); 
            s.Write(mSatelliteSnr[16]); 
            s.Write(mSatelliteSnr[17]); 
            s.Write(mSatelliteSnr[18]); 
            s.Write(mSatelliteSnr[19]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSatellitesVisible = s.ReadByte();
            this.mSatellitePrn[0] = s.ReadByte();
            this.mSatellitePrn[1] = s.ReadByte();
            this.mSatellitePrn[2] = s.ReadByte();
            this.mSatellitePrn[3] = s.ReadByte();
            this.mSatellitePrn[4] = s.ReadByte();
            this.mSatellitePrn[5] = s.ReadByte();
            this.mSatellitePrn[6] = s.ReadByte();
            this.mSatellitePrn[7] = s.ReadByte();
            this.mSatellitePrn[8] = s.ReadByte();
            this.mSatellitePrn[9] = s.ReadByte();
            this.mSatellitePrn[10] = s.ReadByte();
            this.mSatellitePrn[11] = s.ReadByte();
            this.mSatellitePrn[12] = s.ReadByte();
            this.mSatellitePrn[13] = s.ReadByte();
            this.mSatellitePrn[14] = s.ReadByte();
            this.mSatellitePrn[15] = s.ReadByte();
            this.mSatellitePrn[16] = s.ReadByte();
            this.mSatellitePrn[17] = s.ReadByte();
            this.mSatellitePrn[18] = s.ReadByte();
            this.mSatellitePrn[19] = s.ReadByte();
            this.mSatelliteUsed[0] = s.ReadByte();
            this.mSatelliteUsed[1] = s.ReadByte();
            this.mSatelliteUsed[2] = s.ReadByte();
            this.mSatelliteUsed[3] = s.ReadByte();
            this.mSatelliteUsed[4] = s.ReadByte();
            this.mSatelliteUsed[5] = s.ReadByte();
            this.mSatelliteUsed[6] = s.ReadByte();
            this.mSatelliteUsed[7] = s.ReadByte();
            this.mSatelliteUsed[8] = s.ReadByte();
            this.mSatelliteUsed[9] = s.ReadByte();
            this.mSatelliteUsed[10] = s.ReadByte();
            this.mSatelliteUsed[11] = s.ReadByte();
            this.mSatelliteUsed[12] = s.ReadByte();
            this.mSatelliteUsed[13] = s.ReadByte();
            this.mSatelliteUsed[14] = s.ReadByte();
            this.mSatelliteUsed[15] = s.ReadByte();
            this.mSatelliteUsed[16] = s.ReadByte();
            this.mSatelliteUsed[17] = s.ReadByte();
            this.mSatelliteUsed[18] = s.ReadByte();
            this.mSatelliteUsed[19] = s.ReadByte();
            this.mSatelliteElevation[0] = s.ReadByte();
            this.mSatelliteElevation[1] = s.ReadByte();
            this.mSatelliteElevation[2] = s.ReadByte();
            this.mSatelliteElevation[3] = s.ReadByte();
            this.mSatelliteElevation[4] = s.ReadByte();
            this.mSatelliteElevation[5] = s.ReadByte();
            this.mSatelliteElevation[6] = s.ReadByte();
            this.mSatelliteElevation[7] = s.ReadByte();
            this.mSatelliteElevation[8] = s.ReadByte();
            this.mSatelliteElevation[9] = s.ReadByte();
            this.mSatelliteElevation[10] = s.ReadByte();
            this.mSatelliteElevation[11] = s.ReadByte();
            this.mSatelliteElevation[12] = s.ReadByte();
            this.mSatelliteElevation[13] = s.ReadByte();
            this.mSatelliteElevation[14] = s.ReadByte();
            this.mSatelliteElevation[15] = s.ReadByte();
            this.mSatelliteElevation[16] = s.ReadByte();
            this.mSatelliteElevation[17] = s.ReadByte();
            this.mSatelliteElevation[18] = s.ReadByte();
            this.mSatelliteElevation[19] = s.ReadByte();
            this.mSatelliteAzimuth[0] = s.ReadByte();
            this.mSatelliteAzimuth[1] = s.ReadByte();
            this.mSatelliteAzimuth[2] = s.ReadByte();
            this.mSatelliteAzimuth[3] = s.ReadByte();
            this.mSatelliteAzimuth[4] = s.ReadByte();
            this.mSatelliteAzimuth[5] = s.ReadByte();
            this.mSatelliteAzimuth[6] = s.ReadByte();
            this.mSatelliteAzimuth[7] = s.ReadByte();
            this.mSatelliteAzimuth[8] = s.ReadByte();
            this.mSatelliteAzimuth[9] = s.ReadByte();
            this.mSatelliteAzimuth[10] = s.ReadByte();
            this.mSatelliteAzimuth[11] = s.ReadByte();
            this.mSatelliteAzimuth[12] = s.ReadByte();
            this.mSatelliteAzimuth[13] = s.ReadByte();
            this.mSatelliteAzimuth[14] = s.ReadByte();
            this.mSatelliteAzimuth[15] = s.ReadByte();
            this.mSatelliteAzimuth[16] = s.ReadByte();
            this.mSatelliteAzimuth[17] = s.ReadByte();
            this.mSatelliteAzimuth[18] = s.ReadByte();
            this.mSatelliteAzimuth[19] = s.ReadByte();
            this.mSatelliteSnr[0] = s.ReadByte();
            this.mSatelliteSnr[1] = s.ReadByte();
            this.mSatelliteSnr[2] = s.ReadByte();
            this.mSatelliteSnr[3] = s.ReadByte();
            this.mSatelliteSnr[4] = s.ReadByte();
            this.mSatelliteSnr[5] = s.ReadByte();
            this.mSatelliteSnr[6] = s.ReadByte();
            this.mSatelliteSnr[7] = s.ReadByte();
            this.mSatelliteSnr[8] = s.ReadByte();
            this.mSatelliteSnr[9] = s.ReadByte();
            this.mSatelliteSnr[10] = s.ReadByte();
            this.mSatelliteSnr[11] = s.ReadByte();
            this.mSatelliteSnr[12] = s.ReadByte();
            this.mSatelliteSnr[13] = s.ReadByte();
            this.mSatelliteSnr[14] = s.ReadByte();
            this.mSatelliteSnr[15] = s.ReadByte();
            this.mSatelliteSnr[16] = s.ReadByte();
            this.mSatelliteSnr[17] = s.ReadByte();
            this.mSatelliteSnr[18] = s.ReadByte();
            this.mSatelliteSnr[19] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION_INT for the global position estimate. This message can contain information for up to 20 satellites."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitePrn",
                Description = "Global satellite ID",
                NumElements = 20,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatelliteUsed",
                Description = "0: Satellite not used, 1: used for localization",
                NumElements = 20,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatelliteElevation",
                Description = "Elevation (0: right on top of receiver, 90: on the horizon) of satellite",
                NumElements = 20,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatelliteAzimuth",
                Description = "Direction of satellite, 0: 0 deg, 255: 360 deg.",
                NumElements = 20,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatelliteSnr",
                Description = "Signal to noise ratio of satellite",
                NumElements = 20,
            });

        }

        private byte mSatellitesVisible;
        private byte[] mSatellitePrn = new byte[20];
        private byte[] mSatelliteUsed = new byte[20];
        private byte[] mSatelliteElevation = new byte[20];
        private byte[] mSatelliteAzimuth = new byte[20];
        private byte[] mSatelliteSnr = new byte[20];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units
    /// </summary>
    public class UasScaledImu: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 22; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis
        /// </summary>
        public Int16 Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis
        /// </summary>
        public Int16 Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis
        /// </summary>
        public Int16 Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field
        /// </summary>
        public Int16 Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field
        /// </summary>
        public Int16 Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field
        /// </summary>
        public Int16 Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        public UasScaledImu()
        {
            mMessageId = 26;
            CrcExtra = 170;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
            this.mXgyro = s.ReadInt16();
            this.mYgyro = s.ReadInt16();
            this.mZgyro = s.ReadInt16();
            this.mXmag = s.ReadInt16();
            this.mYmag = s.ReadInt16();
            this.mZmag = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
        private Int16 mXgyro;
        private Int16 mYgyro;
        private Int16 mZgyro;
        private Int16 mXmag;
        private Int16 mYmag;
        private Int16 mZmag;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW IMU readings for a 9DOF sensor, which is identified by the id (default IMU1). This message should always contain the true raw values without any scaling to allow data capture and system debugging.
    /// </summary>
    public class UasRawImu: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 26; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (raw)
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (raw)
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (raw)
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis (raw)
        /// </summary>
        public Int16 Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis (raw)
        /// </summary>
        public Int16 Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis (raw)
        /// </summary>
        public Int16 Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field (raw)
        /// </summary>
        public Int16 Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field (raw)
        /// </summary>
        public Int16 Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field (raw)
        /// </summary>
        public Int16 Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        public UasRawImu()
        {
            mMessageId = 27;
            CrcExtra = 144;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
            this.mXgyro = s.ReadInt16();
            this.mYgyro = s.ReadInt16();
            this.mZgyro = s.ReadInt16();
            this.mXmag = s.ReadInt16();
            this.mYmag = s.ReadInt16();
            this.mZmag = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW IMU readings for a 9DOF sensor, which is identified by the id (default IMU1). This message should always contain the true raw values without any scaling to allow data capture and system debugging."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field (raw)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
        private Int16 mXgyro;
        private Int16 mYgyro;
        private Int16 mZgyro;
        private Int16 mXmag;
        private Int16 mYmag;
        private Int16 mZmag;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values.
    /// </summary>
    public class UasRawPressure: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 16; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure (raw)
        /// </summary>
        public Int16 PressAbs {
            get { return mPressAbs; }
            set { mPressAbs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure 1 (raw, 0 if nonexistent)
        /// </summary>
        public Int16 PressDiff1 {
            get { return mPressDiff1; }
            set { mPressDiff1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure 2 (raw, 0 if nonexistent)
        /// </summary>
        public Int16 PressDiff2 {
            get { return mPressDiff2; }
            set { mPressDiff2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Raw Temperature measurement (raw)
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        public UasRawPressure()
        {
            mMessageId = 28;
            CrcExtra = 67;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mPressAbs);
            s.Write(mPressDiff1);
            s.Write(mPressDiff2);
            s.Write(mTemperature);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mPressAbs = s.ReadInt16();
            this.mPressDiff1 = s.ReadInt16();
            this.mPressDiff2 = s.ReadInt16();
            this.mTemperature = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressAbs",
                Description = "Absolute pressure (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff1",
                Description = "Differential pressure 1 (raw, 0 if nonexistent)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff2",
                Description = "Differential pressure 2 (raw, 0 if nonexistent)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Raw Temperature measurement (raw)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int16 mPressAbs;
        private Int16 mPressDiff1;
        private Int16 mPressDiff2;
        private Int16 mTemperature;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field.
    /// </summary>
    public class UasScaledPressure: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 14; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure
        /// </summary>
        public float PressAbs {
            get { return mPressAbs; }
            set { mPressAbs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure 1
        /// </summary>
        public float PressDiff {
            get { return mPressDiff; }
            set { mPressDiff = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure temperature
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        public UasScaledPressure()
        {
            mMessageId = 29;
            CrcExtra = 115;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mPressAbs);
            s.Write(mPressDiff);
            s.Write(mTemperature);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mPressAbs = s.ReadSingle();
            this.mPressDiff = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressAbs",
                Description = "Absolute pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff",
                Description = "Differential pressure 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Absolute pressure temperature",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mPressAbs;
        private float mPressDiff;
        private Int16 mTemperature;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right).
    /// </summary>
    public class UasAttitude: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 28; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle (-pi..+pi)
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle (-pi..+pi)
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle (-pi..+pi)
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angular speed
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angular speed
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angular speed
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        public UasAttitude()
        {
            mMessageId = 30;
            CrcExtra = 39;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle (-pi..+pi)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle (-pi..+pi)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle (-pi..+pi)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Roll angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Pitch angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Yaw angular speed",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
    /// </summary>
    public class UasAttitudeQuaternion: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion component 1, w (1 in null-rotation)
        /// </summary>
        public float Q1 {
            get { return mQ1; }
            set { mQ1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion component 2, x (0 in null-rotation)
        /// </summary>
        public float Q2 {
            get { return mQ2; }
            set { mQ2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion component 3, y (0 in null-rotation)
        /// </summary>
        public float Q3 {
            get { return mQ3; }
            set { mQ3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion component 4, z (0 in null-rotation)
        /// </summary>
        public float Q4 {
            get { return mQ4; }
            set { mQ4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angular speed
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angular speed
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angular speed
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        public UasAttitudeQuaternion()
        {
            mMessageId = 31;
            CrcExtra = 246;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mQ1);
            s.Write(mQ2);
            s.Write(mQ3);
            s.Write(mQ4);
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mQ1 = s.ReadSingle();
            this.mQ2 = s.ReadSingle();
            this.mQ3 = s.ReadSingle();
            this.mQ4 = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q1",
                Description = "Quaternion component 1, w (1 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q2",
                Description = "Quaternion component 2, x (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q3",
                Description = "Quaternion component 3, y (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q4",
                Description = "Quaternion component 4, z (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Roll angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Pitch angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Yaw angular speed",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mQ1;
        private float mQ2;
        private float mQ3;
        private float mQ4;
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    /// </summary>
    public class UasLocalPositionNed: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 28; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Speed
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Speed
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Speed
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        public UasLocalPositionNed()
        {
            mMessageId = 32;
            CrcExtra = 185;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X Speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y Speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z Speed",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mVx;
        private float mVy;
        private float mVz;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It                is designed as scaled integer message since the resolution of float is not sufficient.
    /// </summary>
    public class UasGlobalPositionInt: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 28; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude, expressed
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude, expressed
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Note that virtually all GPS modules provide both WGS84 and MSL.
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude above ground
        /// </summary>
        public Int32 RelativeAlt {
            get { return mRelativeAlt; }
            set { mRelativeAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground X Speed (Latitude, positive north)
        /// </summary>
        public Int16 Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Y Speed (Longitude, positive east)
        /// </summary>
        public Int16 Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Z Speed (Altitude, positive down)
        /// </summary>
        public Int16 Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vehicle heading (yaw angle), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Hdg {
            get { return mHdg; }
            set { mHdg = value; NotifyUpdated(); }
        }

        public UasGlobalPositionInt()
        {
            mMessageId = 33;
            CrcExtra = 104;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mRelativeAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mHdg);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mRelativeAlt = s.ReadInt32();
            this.mVx = s.ReadInt16();
            this.mVy = s.ReadInt16();
            this.mVz = s.ReadInt16();
            this.mHdg = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It                is designed as scaled integer message since the resolution of float is not sufficient."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude, expressed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude, expressed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (MSL). Note that virtually all GPS modules provide both WGS84 and MSL.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RelativeAlt",
                Description = "Altitude above ground",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "Ground X Speed (Latitude, positive north)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Ground Y Speed (Longitude, positive east)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Ground Z Speed (Altitude, positive down)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Hdg",
                Description = "Vehicle heading (yaw angle), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private Int32 mRelativeAlt;
        private Int16 mVx;
        private Int16 mVy;
        private Int16 mVz;
        private UInt16 mHdg;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The scaled values of the RC channels received: (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to UINT16_MAX.
    /// </summary>
    public class UasRcChannelsScaled: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 24; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 1 value scaled.
        /// </summary>
        public Int16 Chan1Scaled {
            get { return mChan1Scaled; }
            set { mChan1Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value scaled.
        /// </summary>
        public Int16 Chan2Scaled {
            get { return mChan2Scaled; }
            set { mChan2Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value scaled.
        /// </summary>
        public Int16 Chan3Scaled {
            get { return mChan3Scaled; }
            set { mChan3Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value scaled.
        /// </summary>
        public Int16 Chan4Scaled {
            get { return mChan4Scaled; }
            set { mChan4Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value scaled.
        /// </summary>
        public Int16 Chan5Scaled {
            get { return mChan5Scaled; }
            set { mChan5Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value scaled.
        /// </summary>
        public Int16 Chan6Scaled {
            get { return mChan6Scaled; }
            set { mChan6Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value scaled.
        /// </summary>
        public Int16 Chan7Scaled {
            get { return mChan7Scaled; }
            set { mChan7Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value scaled.
        /// </summary>
        public Int16 Chan8Scaled {
            get { return mChan8Scaled; }
            set { mChan8Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
        /// </summary>
        public byte Port {
            get { return mPort; }
            set { mPort = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        public UasRcChannelsScaled()
        {
            mMessageId = 34;
            CrcExtra = 237;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mChan1Scaled);
            s.Write(mChan2Scaled);
            s.Write(mChan3Scaled);
            s.Write(mChan4Scaled);
            s.Write(mChan5Scaled);
            s.Write(mChan6Scaled);
            s.Write(mChan7Scaled);
            s.Write(mChan8Scaled);
            s.Write(mPort);
            s.Write(mRssi);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mChan1Scaled = s.ReadInt16();
            this.mChan2Scaled = s.ReadInt16();
            this.mChan3Scaled = s.ReadInt16();
            this.mChan4Scaled = s.ReadInt16();
            this.mChan5Scaled = s.ReadInt16();
            this.mChan6Scaled = s.ReadInt16();
            this.mChan7Scaled = s.ReadInt16();
            this.mChan8Scaled = s.ReadInt16();
            this.mPort = s.ReadByte();
            this.mRssi = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The scaled values of the RC channels received: (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to UINT16_MAX."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Scaled",
                Description = "RC channel 1 value scaled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Scaled",
                Description = "RC channel 2 value scaled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Scaled",
                Description = "RC channel 3 value scaled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Scaled",
                Description = "RC channel 4 value scaled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Scaled",
                Description = "RC channel 5 value scaled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Scaled",
                Description = "RC channel 6 value scaled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Scaled",
                Description = "RC channel 7 value scaled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Scaled",
                Description = "RC channel 8 value scaled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Port",
                Description = "Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int16 mChan1Scaled;
        private Int16 mChan2Scaled;
        private Int16 mChan3Scaled;
        private Int16 mChan4Scaled;
        private Int16 mChan5Scaled;
        private Int16 mChan6Scaled;
        private Int16 mChan7Scaled;
        private Int16 mChan8Scaled;
        private byte mPort;
        private byte mRssi;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification.
    /// </summary>
    public class UasRcChannelsRaw: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 24; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 1 value.
        /// </summary>
        public UInt16 Chan1Raw {
            get { return mChan1Raw; }
            set { mChan1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value.
        /// </summary>
        public UInt16 Chan2Raw {
            get { return mChan2Raw; }
            set { mChan2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value.
        /// </summary>
        public UInt16 Chan3Raw {
            get { return mChan3Raw; }
            set { mChan3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value.
        /// </summary>
        public UInt16 Chan4Raw {
            get { return mChan4Raw; }
            set { mChan4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value.
        /// </summary>
        public UInt16 Chan5Raw {
            get { return mChan5Raw; }
            set { mChan5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value.
        /// </summary>
        public UInt16 Chan6Raw {
            get { return mChan6Raw; }
            set { mChan6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value.
        /// </summary>
        public UInt16 Chan7Raw {
            get { return mChan7Raw; }
            set { mChan7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value.
        /// </summary>
        public UInt16 Chan8Raw {
            get { return mChan8Raw; }
            set { mChan8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
        /// </summary>
        public byte Port {
            get { return mPort; }
            set { mPort = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        public UasRcChannelsRaw()
        {
            mMessageId = 35;
            CrcExtra = 244;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mChan1Raw);
            s.Write(mChan2Raw);
            s.Write(mChan3Raw);
            s.Write(mChan4Raw);
            s.Write(mChan5Raw);
            s.Write(mChan6Raw);
            s.Write(mChan7Raw);
            s.Write(mChan8Raw);
            s.Write(mPort);
            s.Write(mRssi);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mChan1Raw = s.ReadUInt16();
            this.mChan2Raw = s.ReadUInt16();
            this.mChan3Raw = s.ReadUInt16();
            this.mChan4Raw = s.ReadUInt16();
            this.mChan5Raw = s.ReadUInt16();
            this.mChan6Raw = s.ReadUInt16();
            this.mChan7Raw = s.ReadUInt16();
            this.mChan8Raw = s.ReadUInt16();
            this.mPort = s.ReadByte();
            this.mRssi = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Raw",
                Description = "RC channel 1 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Raw",
                Description = "RC channel 2 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Raw",
                Description = "RC channel 3 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Raw",
                Description = "RC channel 4 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Raw",
                Description = "RC channel 5 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Raw",
                Description = "RC channel 6 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Raw",
                Description = "RC channel 7 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Raw",
                Description = "RC channel 8 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Port",
                Description = "Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private UInt16 mChan1Raw;
        private UInt16 mChan2Raw;
        private UInt16 mChan3Raw;
        private UInt16 mChan4Raw;
        private UInt16 mChan5Raw;
        private UInt16 mChan6Raw;
        private UInt16 mChan7Raw;
        private UInt16 mChan8Raw;
        private byte mPort;
        private byte mRssi;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Superseded by ACTUATOR_OUTPUT_STATUS. The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.
    /// </summary>
    public class UasServoOutputRaw: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 22; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt32 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 1 value
        /// </summary>
        public UInt16 Servo1Raw {
            get { return mServo1Raw; }
            set { mServo1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 2 value
        /// </summary>
        public UInt16 Servo2Raw {
            get { return mServo2Raw; }
            set { mServo2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 3 value
        /// </summary>
        public UInt16 Servo3Raw {
            get { return mServo3Raw; }
            set { mServo3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 4 value
        /// </summary>
        public UInt16 Servo4Raw {
            get { return mServo4Raw; }
            set { mServo4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 5 value
        /// </summary>
        public UInt16 Servo5Raw {
            get { return mServo5Raw; }
            set { mServo5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 6 value
        /// </summary>
        public UInt16 Servo6Raw {
            get { return mServo6Raw; }
            set { mServo6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 7 value
        /// </summary>
        public UInt16 Servo7Raw {
            get { return mServo7Raw; }
            set { mServo7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 8 value
        /// </summary>
        public UInt16 Servo8Raw {
            get { return mServo8Raw; }
            set { mServo8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
        /// </summary>
        public byte Port {
            get { return mPort; }
            set { mPort = value; NotifyUpdated(); }
        }

        public UasServoOutputRaw()
        {
            mMessageId = 36;
            CrcExtra = 222;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mServo1Raw);
            s.Write(mServo2Raw);
            s.Write(mServo3Raw);
            s.Write(mServo4Raw);
            s.Write(mServo5Raw);
            s.Write(mServo6Raw);
            s.Write(mServo7Raw);
            s.Write(mServo8Raw);
            s.Write(mPort);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt32();
            this.mServo1Raw = s.ReadUInt16();
            this.mServo2Raw = s.ReadUInt16();
            this.mServo3Raw = s.ReadUInt16();
            this.mServo4Raw = s.ReadUInt16();
            this.mServo5Raw = s.ReadUInt16();
            this.mServo6Raw = s.ReadUInt16();
            this.mServo7Raw = s.ReadUInt16();
            this.mServo8Raw = s.ReadUInt16();
            this.mPort = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Superseded by ACTUATOR_OUTPUT_STATUS. The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo1Raw",
                Description = "Servo output 1 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo2Raw",
                Description = "Servo output 2 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo3Raw",
                Description = "Servo output 3 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo4Raw",
                Description = "Servo output 4 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo5Raw",
                Description = "Servo output 5 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo6Raw",
                Description = "Servo output 6 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo7Raw",
                Description = "Servo output 7 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo8Raw",
                Description = "Servo output 8 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Port",
                Description = "Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeUsec;
        private UInt16 mServo1Raw;
        private UInt16 mServo2Raw;
        private UInt16 mServo3Raw;
        private UInt16 mServo4Raw;
        private UInt16 mServo5Raw;
        private UInt16 mServo6Raw;
        private UInt16 mServo7Raw;
        private UInt16 mServo8Raw;
        private byte mPort;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a partial list of mission items from the system/component. https://mavlink.io/en/services/mission.html. If start and end index are the same, just send one waypoint.
    /// </summary>
    public class UasMissionRequestPartialList: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 8; }
        }
        /// <summary>
        /// Start index
        /// </summary>
        public Int16 StartIndex {
            get { return mStartIndex; }
            set { mStartIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// End index, -1 by default (-1: send list to end). Else a valid index of the list
        /// </summary>
        public Int16 EndIndex {
            get { return mEndIndex; }
            set { mEndIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionRequestPartialList()
        {
            mMessageId = 37;
            CrcExtra = 212;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mStartIndex);
            s.Write(mEndIndex);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mStartIndex = s.ReadInt16();
            this.mEndIndex = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a partial list of mission items from the system/component. https://mavlink.io/en/services/mission.html. If start and end index are the same, just send one waypoint."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StartIndex",
                Description = "Start index",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EndIndex",
                Description = "End index, -1 by default (-1: send list to end). Else a valid index of the list",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private Int16 mStartIndex;
        private Int16 mEndIndex;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED!
    /// </summary>
    public class UasMissionWritePartialList: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 8; }
        }
        /// <summary>
        /// Start index. Must be smaller / equal to the largest index of the current onboard list.
        /// </summary>
        public Int16 StartIndex {
            get { return mStartIndex; }
            set { mStartIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// End index, equal or greater than start index.
        /// </summary>
        public Int16 EndIndex {
            get { return mEndIndex; }
            set { mEndIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionWritePartialList()
        {
            mMessageId = 38;
            CrcExtra = 9;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mStartIndex);
            s.Write(mEndIndex);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mStartIndex = s.ReadInt16();
            this.mEndIndex = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED!"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StartIndex",
                Description = "Start index. Must be smaller / equal to the largest index of the current onboard list.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EndIndex",
                Description = "End index, equal or greater than start index.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private Int16 mStartIndex;
        private Int16 mEndIndex;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN may be used to indicate an optional/default value (e.g. to use the system's current latitude or yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html.
    /// </summary>
    public class UasMissionItem: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 42; }
        }
        /// <summary>
        /// PARAM1, see MAV_CMD enum
        /// </summary>
        public float Param1 {
            get { return mParam1; }
            set { mParam1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM2, see MAV_CMD enum
        /// </summary>
        public float Param2 {
            get { return mParam2; }
            set { mParam2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM3, see MAV_CMD enum
        /// </summary>
        public float Param3 {
            get { return mParam3; }
            set { mParam3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM4, see MAV_CMD enum
        /// </summary>
        public float Param4 {
            get { return mParam4; }
            set { mParam4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM5 / local: X coordinate, global: latitude
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM6 / local: Y coordinate, global: longitude
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM7 / local: Z coordinate, global: altitude (relative or absolute, depending on frame).
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The scheduled action for the waypoint.
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The coordinate system of the waypoint.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        /// <summary>
        /// false:0, true:1
        /// </summary>
        public byte Current {
            get { return mCurrent; }
            set { mCurrent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autocontinue to next waypoint
        /// </summary>
        public byte Autocontinue {
            get { return mAutocontinue; }
            set { mAutocontinue = value; NotifyUpdated(); }
        }

        public UasMissionItem()
        {
            mMessageId = 39;
            CrcExtra = 254;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mParam1);
            s.Write(mParam2);
            s.Write(mParam3);
            s.Write(mParam4);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mSeq);
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mFrame);
            s.Write(mCurrent);
            s.Write(mAutocontinue);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mParam1 = s.ReadSingle();
            this.mParam2 = s.ReadSingle();
            this.mParam3 = s.ReadSingle();
            this.mParam4 = s.ReadSingle();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mSeq = s.ReadUInt16();
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
            this.mCurrent = s.ReadByte();
            this.mAutocontinue = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN may be used to indicate an optional/default value (e.g. to use the system's current latitude or yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param1",
                Description = "PARAM1, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param2",
                Description = "PARAM2, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param3",
                Description = "PARAM3, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param4",
                Description = "PARAM4, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "PARAM5 / local: X coordinate, global: latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "PARAM6 / local: Y coordinate, global: longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "PARAM7 / local: Z coordinate, global: altitude (relative or absolute, depending on frame).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "The scheduled action for the waypoint.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "The coordinate system of the waypoint.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Current",
                Description = "false:0, true:1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autocontinue",
                Description = "Autocontinue to next waypoint",
                NumElements = 1,
            });

        }

        private float mParam1;
        private float mParam2;
        private float mParam3;
        private float mParam4;
        private float mX;
        private float mY;
        private float mZ;
        private UInt16 mSeq;
        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mFrame;
        private byte mCurrent;
        private byte mAutocontinue;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. https://mavlink.io/en/services/mission.html
    /// </summary>
    public class UasMissionRequest: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionRequest()
        {
            mMessageId = 40;
            CrcExtra = 230;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mSeq);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSeq = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. https://mavlink.io/en/services/mission.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between).
    /// </summary>
    public class UasMissionSetCurrent: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionSetCurrent()
        {
            mMessageId = 41;
            CrcExtra = 28;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mSeq);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSeq = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message that announces the sequence number of the current active mission item. The MAV will fly towards this mission item.
    /// </summary>
    public class UasMissionCurrent: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 2; }
        }
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        public UasMissionCurrent()
        {
            mMessageId = 42;
            CrcExtra = 28;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mSeq);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSeq = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message that announces the sequence number of the current active mission item. The MAV will fly towards this mission item."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request the overall list of mission items from the system/component.
    /// </summary>
    public class UasMissionRequestList: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 4; }
        }
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionRequestList()
        {
            mMessageId = 43;
            CrcExtra = 132;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request the overall list of mission items from the system/component."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of waypoints.
    /// </summary>
    public class UasMissionCount: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// Number of mission items in the sequence
        /// </summary>
        public UInt16 Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionCount()
        {
            mMessageId = 44;
            CrcExtra = 221;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mCount);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mCount = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of waypoints."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "Number of mission items in the sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mCount;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Delete all mission items at once.
    /// </summary>
    public class UasMissionClearAll: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 4; }
        }
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionClearAll()
        {
            mMessageId = 45;
            CrcExtra = 232;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Delete all mission items at once."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next waypoint.
    /// </summary>
    public class UasMissionItemReached: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 2; }
        }
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        public UasMissionItemReached()
        {
            mMessageId = 46;
            CrcExtra = 11;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mSeq);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSeq = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next waypoint."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Acknowledgment message during waypoint handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero).
    /// </summary>
    public class UasMissionAck: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Mission result.
        /// </summary>
        public MavMissionResult Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        public UasMissionAck()
        {
            mMessageId = 47;
            CrcExtra = 153;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mType);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mType = (MavMissionResult)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Acknowledgment message during waypoint handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Mission result.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavMissionResult"),
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavMissionResult mType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sets the GPS co-ordinates of the vehicle local origin (0,0,0) position. Vehicle should emit GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the local coordinate frame and the global (GPS) coordinate frame, which may be necessary when (for example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor.
    /// </summary>
    public class UasSetGpsGlobalOrigin: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 14; }
        }
        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Positive for up.
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        public UasSetGpsGlobalOrigin()
        {
            mMessageId = 48;
            CrcExtra = 41;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mAltitude);
            s.Write(mTargetSystem);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
            this.mTargetSystem = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sets the GPS co-ordinates of the vehicle local origin (0,0,0) position. Vehicle should emit GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the local coordinate frame and the global (GPS) coordinate frame, which may be necessary when (for example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (MSL). Positive for up.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

        }

        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int32 mAltitude;
        private byte mTargetSystem;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Publishes the GPS co-ordinates of the vehicle local origin (0,0,0) position. Emitted whenever a new GPS-Local position mapping is requested or set - e.g. following SET_GPS_GLOBAL_ORIGIN message.
    /// </summary>
    public class UasGpsGlobalOrigin: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 12; }
        }
        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Positive for up.
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        public UasGpsGlobalOrigin()
        {
            mMessageId = 49;
            CrcExtra = 39;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mAltitude);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Publishes the GPS co-ordinates of the vehicle local origin (0,0,0) position. Emitted whenever a new GPS-Local position mapping is requested or set - e.g. following SET_GPS_GLOBAL_ORIGIN message."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (MSL). Positive for up.",
                NumElements = 1,
            });

        }

        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int32 mAltitude;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Bind a RC channel to a parameter. The parameter should change according to the RC channel value.
    /// </summary>
    public class UasParamMapRc: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 56; }
        }
        /// <summary>
        /// Initial parameter value
        /// </summary>
        public float ParamValue0 {
            get { return mParamValue0; }
            set { mParamValue0 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Scale, maps the RC range [-1, 1] to a parameter value
        /// </summary>
        public float Scale {
            get { return mScale; }
            set { mScale = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
        /// </summary>
        public float ParamValueMin {
            get { return mParamValueMin; }
            set { mParamValueMin = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
        /// </summary>
        public float ParamValueMax {
            get { return mParamValueMax; }
            set { mParamValueMax = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
        /// </summary>
        public Int16 ParamIndex {
            get { return mParamIndex; }
            set { mParamIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
        /// </summary>
        public char[] ParamId {
            get { return mParamId; }
            set { mParamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Index of parameter RC channel. Not equal to the RC channel id. Typically corresponds to a potentiometer-knob on the RC.
        /// </summary>
        public byte ParameterRcChannelIndex {
            get { return mParameterRcChannelIndex; }
            set { mParameterRcChannelIndex = value; NotifyUpdated(); }
        }

        public UasParamMapRc()
        {
            mMessageId = 50;
            CrcExtra = 78;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mParamValue0);
            s.Write(mScale);
            s.Write(mParamValueMin);
            s.Write(mParamValueMax);
            s.Write(mParamIndex);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mParamId[0]); 
            s.Write(mParamId[1]); 
            s.Write(mParamId[2]); 
            s.Write(mParamId[3]); 
            s.Write(mParamId[4]); 
            s.Write(mParamId[5]); 
            s.Write(mParamId[6]); 
            s.Write(mParamId[7]); 
            s.Write(mParamId[8]); 
            s.Write(mParamId[9]); 
            s.Write(mParamId[10]); 
            s.Write(mParamId[11]); 
            s.Write(mParamId[12]); 
            s.Write(mParamId[13]); 
            s.Write(mParamId[14]); 
            s.Write(mParamId[15]); 
            s.Write(mParameterRcChannelIndex);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mParamValue0 = s.ReadSingle();
            this.mScale = s.ReadSingle();
            this.mParamValueMin = s.ReadSingle();
            this.mParamValueMax = s.ReadSingle();
            this.mParamIndex = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mParamId[0] = s.ReadChar();
            this.mParamId[1] = s.ReadChar();
            this.mParamId[2] = s.ReadChar();
            this.mParamId[3] = s.ReadChar();
            this.mParamId[4] = s.ReadChar();
            this.mParamId[5] = s.ReadChar();
            this.mParamId[6] = s.ReadChar();
            this.mParamId[7] = s.ReadChar();
            this.mParamId[8] = s.ReadChar();
            this.mParamId[9] = s.ReadChar();
            this.mParamId[10] = s.ReadChar();
            this.mParamId[11] = s.ReadChar();
            this.mParamId[12] = s.ReadChar();
            this.mParamId[13] = s.ReadChar();
            this.mParamId[14] = s.ReadChar();
            this.mParamId[15] = s.ReadChar();
            this.mParameterRcChannelIndex = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Bind a RC channel to a parameter. The parameter should change according to the RC channel value."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValue0",
                Description = "Initial parameter value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Scale",
                Description = "Scale, maps the RC range [-1, 1] to a parameter value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValueMin",
                Description = "Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValueMax",
                Description = "Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamIndex",
                Description = "Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamId",
                Description = "Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParameterRcChannelIndex",
                Description = "Index of parameter RC channel. Not equal to the RC channel id. Typically corresponds to a potentiometer-knob on the RC.",
                NumElements = 1,
            });

        }

        private float mParamValue0;
        private float mScale;
        private float mParamValueMin;
        private float mParamValueMax;
        private Int16 mParamIndex;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private char[] mParamId = new char[16];
        private byte mParameterRcChannelIndex;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM_INT message. https://mavlink.io/en/services/mission.html
    /// </summary>
    public class UasMissionRequestInt: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionRequestInt()
        {
            mMessageId = 51;
            CrcExtra = 196;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mSeq);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSeq = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM_INT message. https://mavlink.io/en/services/mission.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/waypoints to accept and which to reject. Safety areas are often enforced by national or competition regulations.
    /// </summary>
    public class UasSafetySetAllowedArea: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 30; }
        }
        /// <summary>
        /// x position 1 / Latitude 1
        /// </summary>
        public float P1x {
            get { return mP1x; }
            set { mP1x = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y position 1 / Longitude 1
        /// </summary>
        public float P1y {
            get { return mP1y; }
            set { mP1y = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z position 1 / Altitude 1
        /// </summary>
        public float P1z {
            get { return mP1z; }
            set { mP1z = value; NotifyUpdated(); }
        }

        /// <summary>
        /// x position 2 / Latitude 2
        /// </summary>
        public float P2x {
            get { return mP2x; }
            set { mP2x = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y position 2 / Longitude 2
        /// </summary>
        public float P2y {
            get { return mP2y; }
            set { mP2y = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z position 2 / Altitude 2
        /// </summary>
        public float P2z {
            get { return mP2z; }
            set { mP2z = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        public UasSafetySetAllowedArea()
        {
            mMessageId = 54;
            CrcExtra = 15;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mP1x);
            s.Write(mP1y);
            s.Write(mP1z);
            s.Write(mP2x);
            s.Write(mP2y);
            s.Write(mP2z);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mFrame);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mP1x = s.ReadSingle();
            this.mP1y = s.ReadSingle();
            this.mP1z = s.ReadSingle();
            this.mP2x = s.ReadSingle();
            this.mP2y = s.ReadSingle();
            this.mP2z = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/waypoints to accept and which to reject. Safety areas are often enforced by national or competition regulations."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1x",
                Description = "x position 1 / Latitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1y",
                Description = "y position 1 / Longitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1z",
                Description = "z position 1 / Altitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2x",
                Description = "x position 2 / Latitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2y",
                Description = "y position 2 / Longitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2z",
                Description = "z position 2 / Altitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private float mP1x;
        private float mP1y;
        private float mP1z;
        private float mP2x;
        private float mP2y;
        private float mP2z;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Read out the safety zone the MAV currently assumes.
    /// </summary>
    public class UasSafetyAllowedArea: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 26; }
        }
        /// <summary>
        /// x position 1 / Latitude 1
        /// </summary>
        public float P1x {
            get { return mP1x; }
            set { mP1x = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y position 1 / Longitude 1
        /// </summary>
        public float P1y {
            get { return mP1y; }
            set { mP1y = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z position 1 / Altitude 1
        /// </summary>
        public float P1z {
            get { return mP1z; }
            set { mP1z = value; NotifyUpdated(); }
        }

        /// <summary>
        /// x position 2 / Latitude 2
        /// </summary>
        public float P2x {
            get { return mP2x; }
            set { mP2x = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y position 2 / Longitude 2
        /// </summary>
        public float P2y {
            get { return mP2y; }
            set { mP2y = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z position 2 / Altitude 2
        /// </summary>
        public float P2z {
            get { return mP2z; }
            set { mP2z = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        public UasSafetyAllowedArea()
        {
            mMessageId = 55;
            CrcExtra = 3;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mP1x);
            s.Write(mP1y);
            s.Write(mP1z);
            s.Write(mP2x);
            s.Write(mP2y);
            s.Write(mP2z);
            s.Write((byte)mFrame);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mP1x = s.ReadSingle();
            this.mP1y = s.ReadSingle();
            this.mP1z = s.ReadSingle();
            this.mP2x = s.ReadSingle();
            this.mP2y = s.ReadSingle();
            this.mP2z = s.ReadSingle();
            this.mFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Read out the safety zone the MAV currently assumes."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1x",
                Description = "x position 1 / Latitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1y",
                Description = "y position 1 / Longitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1z",
                Description = "z position 1 / Altitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2x",
                Description = "x position 2 / Latitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2y",
                Description = "y position 2 / Longitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2z",
                Description = "z position 2 / Altitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private float mP1x;
        private float mP1y;
        private float mP1z;
        private float mP2x;
        private float mP2y;
        private float mP2z;
        private MavFrame mFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
    /// </summary>
    public class UasAttitudeQuaternionCov: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 72; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angular speed
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angular speed
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angular speed
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Row-major representation of a 3x3 attitude covariance matrix (states: roll, pitch, yaw; first three entries are the first ROW, next three entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
        /// </summary>
        public float[] Covariance {
            get { return mCovariance; }
            set { mCovariance = value; NotifyUpdated(); }
        }

        public UasAttitudeQuaternionCov()
        {
            mMessageId = 61;
            CrcExtra = 167;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
            s.Write(mCovariance[0]); 
            s.Write(mCovariance[1]); 
            s.Write(mCovariance[2]); 
            s.Write(mCovariance[3]); 
            s.Write(mCovariance[4]); 
            s.Write(mCovariance[5]); 
            s.Write(mCovariance[6]); 
            s.Write(mCovariance[7]); 
            s.Write(mCovariance[8]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
            this.mCovariance[0] = s.ReadSingle();
            this.mCovariance[1] = s.ReadSingle();
            this.mCovariance[2] = s.ReadSingle();
            this.mCovariance[3] = s.ReadSingle();
            this.mCovariance[4] = s.ReadSingle();
            this.mCovariance[5] = s.ReadSingle();
            this.mCovariance[6] = s.ReadSingle();
            this.mCovariance[7] = s.ReadSingle();
            this.mCovariance[8] = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Roll angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Pitch angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Yaw angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Covariance",
                Description = "Row-major representation of a 3x3 attitude covariance matrix (states: roll, pitch, yaw; first three entries are the first ROW, next three entries are the second row, etc.). If unknown, assign NaN value to first element in the array.",
                NumElements = 9,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mQ = new float[4];
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
        private float[] mCovariance = new float[9];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The state of the navigation and position controller.
    /// </summary>
    public class UasNavControllerOutput: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 26; }
        }
        /// <summary>
        /// Current desired roll
        /// </summary>
        public float NavRoll {
            get { return mNavRoll; }
            set { mNavRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current desired pitch
        /// </summary>
        public float NavPitch {
            get { return mNavPitch; }
            set { mNavPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current altitude error
        /// </summary>
        public float AltError {
            get { return mAltError; }
            set { mAltError = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current airspeed error
        /// </summary>
        public float AspdError {
            get { return mAspdError; }
            set { mAspdError = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current crosstrack error on x-y plane
        /// </summary>
        public float XtrackError {
            get { return mXtrackError; }
            set { mXtrackError = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current desired heading
        /// </summary>
        public Int16 NavBearing {
            get { return mNavBearing; }
            set { mNavBearing = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bearing to current waypoint/target
        /// </summary>
        public Int16 TargetBearing {
            get { return mTargetBearing; }
            set { mTargetBearing = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to active waypoint
        /// </summary>
        public UInt16 WpDist {
            get { return mWpDist; }
            set { mWpDist = value; NotifyUpdated(); }
        }

        public UasNavControllerOutput()
        {
            mMessageId = 62;
            CrcExtra = 183;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mNavRoll);
            s.Write(mNavPitch);
            s.Write(mAltError);
            s.Write(mAspdError);
            s.Write(mXtrackError);
            s.Write(mNavBearing);
            s.Write(mTargetBearing);
            s.Write(mWpDist);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mNavRoll = s.ReadSingle();
            this.mNavPitch = s.ReadSingle();
            this.mAltError = s.ReadSingle();
            this.mAspdError = s.ReadSingle();
            this.mXtrackError = s.ReadSingle();
            this.mNavBearing = s.ReadInt16();
            this.mTargetBearing = s.ReadInt16();
            this.mWpDist = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The state of the navigation and position controller."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NavRoll",
                Description = "Current desired roll",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NavPitch",
                Description = "Current desired pitch",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltError",
                Description = "Current altitude error",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AspdError",
                Description = "Current airspeed error",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "XtrackError",
                Description = "Current crosstrack error on x-y plane",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NavBearing",
                Description = "Current desired heading",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetBearing",
                Description = "Bearing to current waypoint/target",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WpDist",
                Description = "Distance to active waypoint",
                NumElements = 1,
            });

        }

        private float mNavRoll;
        private float mNavPitch;
        private float mAltError;
        private float mAspdError;
        private float mXtrackError;
        private Int16 mNavBearing;
        private Int16 mTargetBearing;
        private UInt16 mWpDist;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset.
    /// </summary>
    public class UasGlobalPositionIntCov: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 182; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude in meters above MSL
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude above ground
        /// </summary>
        public Int32 RelativeAlt {
            get { return mRelativeAlt; }
            set { mRelativeAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground X Speed (Latitude)
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Y Speed (Longitude)
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Z Speed (Altitude)
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Row-major representation of a 6x6 position and velocity 6x6 cross-covariance matrix (states: lat, lon, alt, vx, vy, vz; first six entries are the first ROW, next six entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
        /// </summary>
        public float[] Covariance {
            get { return mCovariance; }
            set { mCovariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Class id of the estimator this estimate originated from.
        /// </summary>
        public MavEstimatorType EstimatorType {
            get { return mEstimatorType; }
            set { mEstimatorType = value; NotifyUpdated(); }
        }

        public UasGlobalPositionIntCov()
        {
            mMessageId = 63;
            CrcExtra = 119;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mRelativeAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mCovariance[0]); 
            s.Write(mCovariance[1]); 
            s.Write(mCovariance[2]); 
            s.Write(mCovariance[3]); 
            s.Write(mCovariance[4]); 
            s.Write(mCovariance[5]); 
            s.Write(mCovariance[6]); 
            s.Write(mCovariance[7]); 
            s.Write(mCovariance[8]); 
            s.Write(mCovariance[9]); 
            s.Write(mCovariance[10]); 
            s.Write(mCovariance[11]); 
            s.Write(mCovariance[12]); 
            s.Write(mCovariance[13]); 
            s.Write(mCovariance[14]); 
            s.Write(mCovariance[15]); 
            s.Write(mCovariance[16]); 
            s.Write(mCovariance[17]); 
            s.Write(mCovariance[18]); 
            s.Write(mCovariance[19]); 
            s.Write(mCovariance[20]); 
            s.Write(mCovariance[21]); 
            s.Write(mCovariance[22]); 
            s.Write(mCovariance[23]); 
            s.Write(mCovariance[24]); 
            s.Write(mCovariance[25]); 
            s.Write(mCovariance[26]); 
            s.Write(mCovariance[27]); 
            s.Write(mCovariance[28]); 
            s.Write(mCovariance[29]); 
            s.Write(mCovariance[30]); 
            s.Write(mCovariance[31]); 
            s.Write(mCovariance[32]); 
            s.Write(mCovariance[33]); 
            s.Write(mCovariance[34]); 
            s.Write(mCovariance[35]); 
            s.Write((byte)mEstimatorType);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mRelativeAlt = s.ReadInt32();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mCovariance[0] = s.ReadSingle();
            this.mCovariance[1] = s.ReadSingle();
            this.mCovariance[2] = s.ReadSingle();
            this.mCovariance[3] = s.ReadSingle();
            this.mCovariance[4] = s.ReadSingle();
            this.mCovariance[5] = s.ReadSingle();
            this.mCovariance[6] = s.ReadSingle();
            this.mCovariance[7] = s.ReadSingle();
            this.mCovariance[8] = s.ReadSingle();
            this.mCovariance[9] = s.ReadSingle();
            this.mCovariance[10] = s.ReadSingle();
            this.mCovariance[11] = s.ReadSingle();
            this.mCovariance[12] = s.ReadSingle();
            this.mCovariance[13] = s.ReadSingle();
            this.mCovariance[14] = s.ReadSingle();
            this.mCovariance[15] = s.ReadSingle();
            this.mCovariance[16] = s.ReadSingle();
            this.mCovariance[17] = s.ReadSingle();
            this.mCovariance[18] = s.ReadSingle();
            this.mCovariance[19] = s.ReadSingle();
            this.mCovariance[20] = s.ReadSingle();
            this.mCovariance[21] = s.ReadSingle();
            this.mCovariance[22] = s.ReadSingle();
            this.mCovariance[23] = s.ReadSingle();
            this.mCovariance[24] = s.ReadSingle();
            this.mCovariance[25] = s.ReadSingle();
            this.mCovariance[26] = s.ReadSingle();
            this.mCovariance[27] = s.ReadSingle();
            this.mCovariance[28] = s.ReadSingle();
            this.mCovariance[29] = s.ReadSingle();
            this.mCovariance[30] = s.ReadSingle();
            this.mCovariance[31] = s.ReadSingle();
            this.mCovariance[32] = s.ReadSingle();
            this.mCovariance[33] = s.ReadSingle();
            this.mCovariance[34] = s.ReadSingle();
            this.mCovariance[35] = s.ReadSingle();
            this.mEstimatorType = (MavEstimatorType)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude in meters above MSL",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RelativeAlt",
                Description = "Altitude above ground",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "Ground X Speed (Latitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Ground Y Speed (Longitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Ground Z Speed (Altitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Covariance",
                Description = "Row-major representation of a 6x6 position and velocity 6x6 cross-covariance matrix (states: lat, lon, alt, vx, vy, vz; first six entries are the first ROW, next six entries are the second row, etc.). If unknown, assign NaN value to first element in the array.",
                NumElements = 36,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EstimatorType",
                Description = "Class id of the estimator this estimate originated from.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavEstimatorType"),
            });

        }

        private UInt64 mTimeUsec;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private Int32 mRelativeAlt;
        private float mVx;
        private float mVy;
        private float mVz;
        private float[] mCovariance = new float[36];
        private MavEstimatorType mEstimatorType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    /// </summary>
    public class UasLocalPositionNedCov: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 226; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Speed
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Speed
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Speed
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Acceleration
        /// </summary>
        public float Ax {
            get { return mAx; }
            set { mAx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Acceleration
        /// </summary>
        public float Ay {
            get { return mAy; }
            set { mAy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Acceleration
        /// </summary>
        public float Az {
            get { return mAz; }
            set { mAz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Row-major representation of position, velocity and acceleration 9x9 cross-covariance matrix upper right triangle (states: x, y, z, vx, vy, vz, ax, ay, az; first nine entries are the first ROW, next eight entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
        /// </summary>
        public float[] Covariance {
            get { return mCovariance; }
            set { mCovariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Class id of the estimator this estimate originated from.
        /// </summary>
        public MavEstimatorType EstimatorType {
            get { return mEstimatorType; }
            set { mEstimatorType = value; NotifyUpdated(); }
        }

        public UasLocalPositionNedCov()
        {
            mMessageId = 64;
            CrcExtra = 191;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAx);
            s.Write(mAy);
            s.Write(mAz);
            s.Write(mCovariance[0]); 
            s.Write(mCovariance[1]); 
            s.Write(mCovariance[2]); 
            s.Write(mCovariance[3]); 
            s.Write(mCovariance[4]); 
            s.Write(mCovariance[5]); 
            s.Write(mCovariance[6]); 
            s.Write(mCovariance[7]); 
            s.Write(mCovariance[8]); 
            s.Write(mCovariance[9]); 
            s.Write(mCovariance[10]); 
            s.Write(mCovariance[11]); 
            s.Write(mCovariance[12]); 
            s.Write(mCovariance[13]); 
            s.Write(mCovariance[14]); 
            s.Write(mCovariance[15]); 
            s.Write(mCovariance[16]); 
            s.Write(mCovariance[17]); 
            s.Write(mCovariance[18]); 
            s.Write(mCovariance[19]); 
            s.Write(mCovariance[20]); 
            s.Write(mCovariance[21]); 
            s.Write(mCovariance[22]); 
            s.Write(mCovariance[23]); 
            s.Write(mCovariance[24]); 
            s.Write(mCovariance[25]); 
            s.Write(mCovariance[26]); 
            s.Write(mCovariance[27]); 
            s.Write(mCovariance[28]); 
            s.Write(mCovariance[29]); 
            s.Write(mCovariance[30]); 
            s.Write(mCovariance[31]); 
            s.Write(mCovariance[32]); 
            s.Write(mCovariance[33]); 
            s.Write(mCovariance[34]); 
            s.Write(mCovariance[35]); 
            s.Write(mCovariance[36]); 
            s.Write(mCovariance[37]); 
            s.Write(mCovariance[38]); 
            s.Write(mCovariance[39]); 
            s.Write(mCovariance[40]); 
            s.Write(mCovariance[41]); 
            s.Write(mCovariance[42]); 
            s.Write(mCovariance[43]); 
            s.Write(mCovariance[44]); 
            s.Write((byte)mEstimatorType);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAx = s.ReadSingle();
            this.mAy = s.ReadSingle();
            this.mAz = s.ReadSingle();
            this.mCovariance[0] = s.ReadSingle();
            this.mCovariance[1] = s.ReadSingle();
            this.mCovariance[2] = s.ReadSingle();
            this.mCovariance[3] = s.ReadSingle();
            this.mCovariance[4] = s.ReadSingle();
            this.mCovariance[5] = s.ReadSingle();
            this.mCovariance[6] = s.ReadSingle();
            this.mCovariance[7] = s.ReadSingle();
            this.mCovariance[8] = s.ReadSingle();
            this.mCovariance[9] = s.ReadSingle();
            this.mCovariance[10] = s.ReadSingle();
            this.mCovariance[11] = s.ReadSingle();
            this.mCovariance[12] = s.ReadSingle();
            this.mCovariance[13] = s.ReadSingle();
            this.mCovariance[14] = s.ReadSingle();
            this.mCovariance[15] = s.ReadSingle();
            this.mCovariance[16] = s.ReadSingle();
            this.mCovariance[17] = s.ReadSingle();
            this.mCovariance[18] = s.ReadSingle();
            this.mCovariance[19] = s.ReadSingle();
            this.mCovariance[20] = s.ReadSingle();
            this.mCovariance[21] = s.ReadSingle();
            this.mCovariance[22] = s.ReadSingle();
            this.mCovariance[23] = s.ReadSingle();
            this.mCovariance[24] = s.ReadSingle();
            this.mCovariance[25] = s.ReadSingle();
            this.mCovariance[26] = s.ReadSingle();
            this.mCovariance[27] = s.ReadSingle();
            this.mCovariance[28] = s.ReadSingle();
            this.mCovariance[29] = s.ReadSingle();
            this.mCovariance[30] = s.ReadSingle();
            this.mCovariance[31] = s.ReadSingle();
            this.mCovariance[32] = s.ReadSingle();
            this.mCovariance[33] = s.ReadSingle();
            this.mCovariance[34] = s.ReadSingle();
            this.mCovariance[35] = s.ReadSingle();
            this.mCovariance[36] = s.ReadSingle();
            this.mCovariance[37] = s.ReadSingle();
            this.mCovariance[38] = s.ReadSingle();
            this.mCovariance[39] = s.ReadSingle();
            this.mCovariance[40] = s.ReadSingle();
            this.mCovariance[41] = s.ReadSingle();
            this.mCovariance[42] = s.ReadSingle();
            this.mCovariance[43] = s.ReadSingle();
            this.mCovariance[44] = s.ReadSingle();
            this.mEstimatorType = (MavEstimatorType)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X Speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y Speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z Speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ax",
                Description = "X Acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ay",
                Description = "Y Acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Az",
                Description = "Z Acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Covariance",
                Description = "Row-major representation of position, velocity and acceleration 9x9 cross-covariance matrix upper right triangle (states: x, y, z, vx, vy, vz, ax, ay, az; first nine entries are the first ROW, next eight entries are the second row, etc.). If unknown, assign NaN value to first element in the array.",
                NumElements = 45,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EstimatorType",
                Description = "Class id of the estimator this estimate originated from.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavEstimatorType"),
            });

        }

        private UInt64 mTimeUsec;
        private float mX;
        private float mY;
        private float mZ;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAx;
        private float mAy;
        private float mAz;
        private float[] mCovariance = new float[45];
        private MavEstimatorType mEstimatorType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.  A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification.
    /// </summary>
    public class UasRcChannels: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 44; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 1 value.
        /// </summary>
        public UInt16 Chan1Raw {
            get { return mChan1Raw; }
            set { mChan1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value.
        /// </summary>
        public UInt16 Chan2Raw {
            get { return mChan2Raw; }
            set { mChan2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value.
        /// </summary>
        public UInt16 Chan3Raw {
            get { return mChan3Raw; }
            set { mChan3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value.
        /// </summary>
        public UInt16 Chan4Raw {
            get { return mChan4Raw; }
            set { mChan4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value.
        /// </summary>
        public UInt16 Chan5Raw {
            get { return mChan5Raw; }
            set { mChan5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value.
        /// </summary>
        public UInt16 Chan6Raw {
            get { return mChan6Raw; }
            set { mChan6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value.
        /// </summary>
        public UInt16 Chan7Raw {
            get { return mChan7Raw; }
            set { mChan7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value.
        /// </summary>
        public UInt16 Chan8Raw {
            get { return mChan8Raw; }
            set { mChan8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 9 value.
        /// </summary>
        public UInt16 Chan9Raw {
            get { return mChan9Raw; }
            set { mChan9Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 10 value.
        /// </summary>
        public UInt16 Chan10Raw {
            get { return mChan10Raw; }
            set { mChan10Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 11 value.
        /// </summary>
        public UInt16 Chan11Raw {
            get { return mChan11Raw; }
            set { mChan11Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 12 value.
        /// </summary>
        public UInt16 Chan12Raw {
            get { return mChan12Raw; }
            set { mChan12Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 13 value.
        /// </summary>
        public UInt16 Chan13Raw {
            get { return mChan13Raw; }
            set { mChan13Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 14 value.
        /// </summary>
        public UInt16 Chan14Raw {
            get { return mChan14Raw; }
            set { mChan14Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 15 value.
        /// </summary>
        public UInt16 Chan15Raw {
            get { return mChan15Raw; }
            set { mChan15Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 16 value.
        /// </summary>
        public UInt16 Chan16Raw {
            get { return mChan16Raw; }
            set { mChan16Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 17 value.
        /// </summary>
        public UInt16 Chan17Raw {
            get { return mChan17Raw; }
            set { mChan17Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 18 value.
        /// </summary>
        public UInt16 Chan18Raw {
            get { return mChan18Raw; }
            set { mChan18Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
        /// </summary>
        public byte Chancount {
            get { return mChancount; }
            set { mChancount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        public UasRcChannels()
        {
            mMessageId = 65;
            CrcExtra = 118;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mChan1Raw);
            s.Write(mChan2Raw);
            s.Write(mChan3Raw);
            s.Write(mChan4Raw);
            s.Write(mChan5Raw);
            s.Write(mChan6Raw);
            s.Write(mChan7Raw);
            s.Write(mChan8Raw);
            s.Write(mChan9Raw);
            s.Write(mChan10Raw);
            s.Write(mChan11Raw);
            s.Write(mChan12Raw);
            s.Write(mChan13Raw);
            s.Write(mChan14Raw);
            s.Write(mChan15Raw);
            s.Write(mChan16Raw);
            s.Write(mChan17Raw);
            s.Write(mChan18Raw);
            s.Write(mChancount);
            s.Write(mRssi);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mChan1Raw = s.ReadUInt16();
            this.mChan2Raw = s.ReadUInt16();
            this.mChan3Raw = s.ReadUInt16();
            this.mChan4Raw = s.ReadUInt16();
            this.mChan5Raw = s.ReadUInt16();
            this.mChan6Raw = s.ReadUInt16();
            this.mChan7Raw = s.ReadUInt16();
            this.mChan8Raw = s.ReadUInt16();
            this.mChan9Raw = s.ReadUInt16();
            this.mChan10Raw = s.ReadUInt16();
            this.mChan11Raw = s.ReadUInt16();
            this.mChan12Raw = s.ReadUInt16();
            this.mChan13Raw = s.ReadUInt16();
            this.mChan14Raw = s.ReadUInt16();
            this.mChan15Raw = s.ReadUInt16();
            this.mChan16Raw = s.ReadUInt16();
            this.mChan17Raw = s.ReadUInt16();
            this.mChan18Raw = s.ReadUInt16();
            this.mChancount = s.ReadByte();
            this.mRssi = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.  A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Raw",
                Description = "RC channel 1 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Raw",
                Description = "RC channel 2 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Raw",
                Description = "RC channel 3 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Raw",
                Description = "RC channel 4 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Raw",
                Description = "RC channel 5 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Raw",
                Description = "RC channel 6 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Raw",
                Description = "RC channel 7 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Raw",
                Description = "RC channel 8 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan9Raw",
                Description = "RC channel 9 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan10Raw",
                Description = "RC channel 10 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan11Raw",
                Description = "RC channel 11 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan12Raw",
                Description = "RC channel 12 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan13Raw",
                Description = "RC channel 13 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan14Raw",
                Description = "RC channel 14 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan15Raw",
                Description = "RC channel 15 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan16Raw",
                Description = "RC channel 16 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan17Raw",
                Description = "RC channel 17 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan18Raw",
                Description = "RC channel 18 value.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chancount",
                Description = "Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private UInt16 mChan1Raw;
        private UInt16 mChan2Raw;
        private UInt16 mChan3Raw;
        private UInt16 mChan4Raw;
        private UInt16 mChan5Raw;
        private UInt16 mChan6Raw;
        private UInt16 mChan7Raw;
        private UInt16 mChan8Raw;
        private UInt16 mChan9Raw;
        private UInt16 mChan10Raw;
        private UInt16 mChan11Raw;
        private UInt16 mChan12Raw;
        private UInt16 mChan13Raw;
        private UInt16 mChan14Raw;
        private UInt16 mChan15Raw;
        private UInt16 mChan16Raw;
        private UInt16 mChan17Raw;
        private UInt16 mChan18Raw;
        private byte mChancount;
        private byte mRssi;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a data stream.
    /// </summary>
    public class UasRequestDataStream: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 10; }
        }
        /// <summary>
        /// The requested message rate
        /// </summary>
        public UInt16 ReqMessageRate {
            get { return mReqMessageRate; }
            set { mReqMessageRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The target requested to send the message stream.
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The target requested to send the message stream.
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The ID of the requested data stream
        /// </summary>
        public byte ReqStreamId {
            get { return mReqStreamId; }
            set { mReqStreamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 1 to start sending, 0 to stop sending.
        /// </summary>
        public byte StartStop {
            get { return mStartStop; }
            set { mStartStop = value; NotifyUpdated(); }
        }

        public UasRequestDataStream()
        {
            mMessageId = 66;
            CrcExtra = 148;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mReqMessageRate);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mReqStreamId);
            s.Write(mStartStop);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mReqMessageRate = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mReqStreamId = s.ReadByte();
            this.mStartStop = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a data stream."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ReqMessageRate",
                Description = "The requested message rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "The target requested to send the message stream.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "The target requested to send the message stream.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ReqStreamId",
                Description = "The ID of the requested data stream",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StartStop",
                Description = "1 to start sending, 0 to stop sending.",
                NumElements = 1,
            });

        }

        private UInt16 mReqMessageRate;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mReqStreamId;
        private byte mStartStop;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Data stream status information.
    /// </summary>
    public class UasDataStream: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// The message rate
        /// </summary>
        public UInt16 MessageRate {
            get { return mMessageRate; }
            set { mMessageRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The ID of the requested data stream
        /// </summary>
        public byte StreamId {
            get { return mStreamId; }
            set { mStreamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 1 stream is enabled, 0 stream is stopped.
        /// </summary>
        public byte OnOff {
            get { return mOnOff; }
            set { mOnOff = value; NotifyUpdated(); }
        }

        public UasDataStream()
        {
            mMessageId = 67;
            CrcExtra = 21;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mMessageRate);
            s.Write(mStreamId);
            s.Write(mOnOff);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mMessageRate = s.ReadUInt16();
            this.mStreamId = s.ReadByte();
            this.mOnOff = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Data stream status information."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessageRate",
                Description = "The message rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StreamId",
                Description = "The ID of the requested data stream",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OnOff",
                Description = "1 stream is enabled, 0 stream is stopped.",
                NumElements = 1,
            });

        }

        private UInt16 mMessageRate;
        private byte mStreamId;
        private byte mOnOff;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled and buttons states are transmitted as individual on/off bits of a bitmask
    /// </summary>
    public class UasManualControl: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 12; }
        }
        /// <summary>
        /// X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
        /// </summary>
        public Int16 X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
        /// </summary>
        public Int16 Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle. Positive values are positive thrust, negative values are negative thrust.
        /// </summary>
        public Int16 Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
        /// </summary>
        public Int16 R {
            get { return mR; }
            set { mR = value; NotifyUpdated(); }
        }

        /// <summary>
        /// A bitfield corresponding to the joystick buttons' 0-15 current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
        /// </summary>
        public UInt16 Buttons {
            get { return mButtons; }
            set { mButtons = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The system to be controlled.
        /// </summary>
        public byte Target {
            get { return mTarget; }
            set { mTarget = value; NotifyUpdated(); }
        }

        public UasManualControl()
        {
            mMessageId = 69;
            CrcExtra = 243;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mR);
            s.Write(mButtons);
            s.Write(mTarget);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mX = s.ReadInt16();
            this.mY = s.ReadInt16();
            this.mZ = s.ReadInt16();
            this.mR = s.ReadInt16();
            this.mButtons = s.ReadUInt16();
            this.mTarget = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled and buttons states are transmitted as individual on/off bits of a bitmask"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle. Positive values are positive thrust, negative values are negative thrust.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "R",
                Description = "R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Buttons",
                Description = "A bitfield corresponding to the joystick buttons' 0-15 current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Target",
                Description = "The system to be controlled.",
                NumElements = 1,
            });

        }

        private Int16 mX;
        private Int16 mY;
        private Int16 mZ;
        private Int16 mR;
        private UInt16 mButtons;
        private byte mTarget;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW values of the RC channels sent to the MAV to override info received from the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.  Note carefully the semantic differences between the first 8 channels and the subsequent channels
    /// </summary>
    public class UasRcChannelsOverride: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 20; }
        }
        /// <summary>
        /// RC channel 1 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
        /// </summary>
        public UInt16 Chan1Raw {
            get { return mChan1Raw; }
            set { mChan1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
        /// </summary>
        public UInt16 Chan2Raw {
            get { return mChan2Raw; }
            set { mChan2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
        /// </summary>
        public UInt16 Chan3Raw {
            get { return mChan3Raw; }
            set { mChan3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
        /// </summary>
        public UInt16 Chan4Raw {
            get { return mChan4Raw; }
            set { mChan4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
        /// </summary>
        public UInt16 Chan5Raw {
            get { return mChan5Raw; }
            set { mChan5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
        /// </summary>
        public UInt16 Chan6Raw {
            get { return mChan6Raw; }
            set { mChan6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
        /// </summary>
        public UInt16 Chan7Raw {
            get { return mChan7Raw; }
            set { mChan7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
        /// </summary>
        public UInt16 Chan8Raw {
            get { return mChan8Raw; }
            set { mChan8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasRcChannelsOverride()
        {
            mMessageId = 70;
            CrcExtra = 124;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mChan1Raw);
            s.Write(mChan2Raw);
            s.Write(mChan3Raw);
            s.Write(mChan4Raw);
            s.Write(mChan5Raw);
            s.Write(mChan6Raw);
            s.Write(mChan7Raw);
            s.Write(mChan8Raw);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mChan1Raw = s.ReadUInt16();
            this.mChan2Raw = s.ReadUInt16();
            this.mChan3Raw = s.ReadUInt16();
            this.mChan4Raw = s.ReadUInt16();
            this.mChan5Raw = s.ReadUInt16();
            this.mChan6Raw = s.ReadUInt16();
            this.mChan7Raw = s.ReadUInt16();
            this.mChan8Raw = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW values of the RC channels sent to the MAV to override info received from the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.  Note carefully the semantic differences between the first 8 channels and the subsequent channels"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Raw",
                Description = "RC channel 1 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Raw",
                Description = "RC channel 2 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Raw",
                Description = "RC channel 3 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Raw",
                Description = "RC channel 4 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Raw",
                Description = "RC channel 5 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Raw",
                Description = "RC channel 6 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Raw",
                Description = "RC channel 7 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Raw",
                Description = "RC channel 8 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mChan1Raw;
        private UInt16 mChan2Raw;
        private UInt16 mChan3Raw;
        private UInt16 mChan4Raw;
        private UInt16 mChan5Raw;
        private UInt16 mChan6Raw;
        private UInt16 mChan7Raw;
        private UInt16 mChan8Raw;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html.
    /// </summary>
    public class UasMissionItemInt: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 42; }
        }
        /// <summary>
        /// PARAM1, see MAV_CMD enum
        /// </summary>
        public float Param1 {
            get { return mParam1; }
            set { mParam1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM2, see MAV_CMD enum
        /// </summary>
        public float Param2 {
            get { return mParam2; }
            set { mParam2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM3, see MAV_CMD enum
        /// </summary>
        public float Param3 {
            get { return mParam3; }
            set { mParam3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM4, see MAV_CMD enum
        /// </summary>
        public float Param4 {
            get { return mParam4; }
            set { mParam4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
        /// </summary>
        public Int32 X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
        /// </summary>
        public Int32 Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The scheduled action for the waypoint.
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The coordinate system of the waypoint.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        /// <summary>
        /// false:0, true:1
        /// </summary>
        public byte Current {
            get { return mCurrent; }
            set { mCurrent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autocontinue to next waypoint
        /// </summary>
        public byte Autocontinue {
            get { return mAutocontinue; }
            set { mAutocontinue = value; NotifyUpdated(); }
        }

        public UasMissionItemInt()
        {
            mMessageId = 73;
            CrcExtra = 38;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mParam1);
            s.Write(mParam2);
            s.Write(mParam3);
            s.Write(mParam4);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mSeq);
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mFrame);
            s.Write(mCurrent);
            s.Write(mAutocontinue);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mParam1 = s.ReadSingle();
            this.mParam2 = s.ReadSingle();
            this.mParam3 = s.ReadSingle();
            this.mParam4 = s.ReadSingle();
            this.mX = s.ReadInt32();
            this.mY = s.ReadInt32();
            this.mZ = s.ReadSingle();
            this.mSeq = s.ReadUInt16();
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
            this.mCurrent = s.ReadByte();
            this.mAutocontinue = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param1",
                Description = "PARAM1, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param2",
                Description = "PARAM2, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param3",
                Description = "PARAM3, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param4",
                Description = "PARAM4, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "The scheduled action for the waypoint.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "The coordinate system of the waypoint.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Current",
                Description = "false:0, true:1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autocontinue",
                Description = "Autocontinue to next waypoint",
                NumElements = 1,
            });

        }

        private float mParam1;
        private float mParam2;
        private float mParam3;
        private float mParam4;
        private Int32 mX;
        private Int32 mY;
        private float mZ;
        private UInt16 mSeq;
        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mFrame;
        private byte mCurrent;
        private byte mAutocontinue;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Metrics typically displayed on a HUD for fixed wing aircraft.
    /// </summary>
    public class UasVfrHud: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 20; }
        }
        /// <summary>
        /// Vehicle speed in form appropriate for vehicle type. For standard aircraft this is typically calibrated airspeed (CAS) or indicated airspeed (IAS) - either of which can be used by a pilot to estimate stall speed.
        /// </summary>
        public float Airspeed {
            get { return mAirspeed; }
            set { mAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current ground speed.
        /// </summary>
        public float Groundspeed {
            get { return mGroundspeed; }
            set { mGroundspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current altitude (MSL).
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current climb rate.
        /// </summary>
        public float Climb {
            get { return mClimb; }
            set { mClimb = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current heading in compass units (0-360, 0=north).
        /// </summary>
        public Int16 Heading {
            get { return mHeading; }
            set { mHeading = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current throttle setting (0 to 100).
        /// </summary>
        public UInt16 Throttle {
            get { return mThrottle; }
            set { mThrottle = value; NotifyUpdated(); }
        }

        public UasVfrHud()
        {
            mMessageId = 74;
            CrcExtra = 20;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mAirspeed);
            s.Write(mGroundspeed);
            s.Write(mAlt);
            s.Write(mClimb);
            s.Write(mHeading);
            s.Write(mThrottle);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mAirspeed = s.ReadSingle();
            this.mGroundspeed = s.ReadSingle();
            this.mAlt = s.ReadSingle();
            this.mClimb = s.ReadSingle();
            this.mHeading = s.ReadInt16();
            this.mThrottle = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Metrics typically displayed on a HUD for fixed wing aircraft."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Airspeed",
                Description = "Vehicle speed in form appropriate for vehicle type. For standard aircraft this is typically calibrated airspeed (CAS) or indicated airspeed (IAS) - either of which can be used by a pilot to estimate stall speed.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Groundspeed",
                Description = "Current ground speed.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Current altitude (MSL).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Climb",
                Description = "Current climb rate.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Heading",
                Description = "Current heading in compass units (0-360, 0=north).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Throttle",
                Description = "Current throttle setting (0 to 100).",
                NumElements = 1,
            });

        }

        private float mAirspeed;
        private float mGroundspeed;
        private float mAlt;
        private float mClimb;
        private Int16 mHeading;
        private UInt16 mThrottle;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value. NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). The command microservice is documented at https://mavlink.io/en/services/command.html
    /// </summary>
    public class UasCommandInt: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 40; }
        }
        /// <summary>
        /// PARAM1, see MAV_CMD enum
        /// </summary>
        public float Param1 {
            get { return mParam1; }
            set { mParam1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM2, see MAV_CMD enum
        /// </summary>
        public float Param2 {
            get { return mParam2; }
            set { mParam2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM3, see MAV_CMD enum
        /// </summary>
        public float Param3 {
            get { return mParam3; }
            set { mParam3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM4, see MAV_CMD enum
        /// </summary>
        public float Param4 {
            get { return mParam4; }
            set { mParam4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
        /// </summary>
        public Int32 X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
        /// </summary>
        public Int32 Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame).
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The scheduled action for the mission item.
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The coordinate system of the COMMAND.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Not used.
        /// </summary>
        public byte Current {
            get { return mCurrent; }
            set { mCurrent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Not used (set 0).
        /// </summary>
        public byte Autocontinue {
            get { return mAutocontinue; }
            set { mAutocontinue = value; NotifyUpdated(); }
        }

        public UasCommandInt()
        {
            mMessageId = 75;
            CrcExtra = 158;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mParam1);
            s.Write(mParam2);
            s.Write(mParam3);
            s.Write(mParam4);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mFrame);
            s.Write(mCurrent);
            s.Write(mAutocontinue);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mParam1 = s.ReadSingle();
            this.mParam2 = s.ReadSingle();
            this.mParam3 = s.ReadSingle();
            this.mParam4 = s.ReadSingle();
            this.mX = s.ReadInt32();
            this.mY = s.ReadInt32();
            this.mZ = s.ReadSingle();
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
            this.mCurrent = s.ReadByte();
            this.mAutocontinue = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value. NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). The command microservice is documented at https://mavlink.io/en/services/command.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param1",
                Description = "PARAM1, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param2",
                Description = "PARAM2, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param3",
                Description = "PARAM3, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param4",
                Description = "PARAM4, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "The scheduled action for the mission item.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "The coordinate system of the COMMAND.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Current",
                Description = "Not used.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autocontinue",
                Description = "Not used (set 0).",
                NumElements = 1,
            });

        }

        private float mParam1;
        private float mParam2;
        private float mParam3;
        private float mParam4;
        private Int32 mX;
        private Int32 mY;
        private float mZ;
        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mFrame;
        private byte mCurrent;
        private byte mAutocontinue;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a command with up to seven parameters to the MAV. The command microservice is documented at https://mavlink.io/en/services/command.html
    /// </summary>
    public class UasCommandLong: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 36; }
        }
        /// <summary>
        /// Parameter 1 (for the specific command).
        /// </summary>
        public float Param1 {
            get { return mParam1; }
            set { mParam1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 2 (for the specific command).
        /// </summary>
        public float Param2 {
            get { return mParam2; }
            set { mParam2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 3 (for the specific command).
        /// </summary>
        public float Param3 {
            get { return mParam3; }
            set { mParam3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 4 (for the specific command).
        /// </summary>
        public float Param4 {
            get { return mParam4; }
            set { mParam4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 5 (for the specific command).
        /// </summary>
        public float Param5 {
            get { return mParam5; }
            set { mParam5 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 6 (for the specific command).
        /// </summary>
        public float Param6 {
            get { return mParam6; }
            set { mParam6 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 7 (for the specific command).
        /// </summary>
        public float Param7 {
            get { return mParam7; }
            set { mParam7 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Command ID (of command to send).
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System which should execute the command
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component which should execute the command, 0 for all components
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
        /// </summary>
        public byte Confirmation {
            get { return mConfirmation; }
            set { mConfirmation = value; NotifyUpdated(); }
        }

        public UasCommandLong()
        {
            mMessageId = 76;
            CrcExtra = 152;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mParam1);
            s.Write(mParam2);
            s.Write(mParam3);
            s.Write(mParam4);
            s.Write(mParam5);
            s.Write(mParam6);
            s.Write(mParam7);
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mConfirmation);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mParam1 = s.ReadSingle();
            this.mParam2 = s.ReadSingle();
            this.mParam3 = s.ReadSingle();
            this.mParam4 = s.ReadSingle();
            this.mParam5 = s.ReadSingle();
            this.mParam6 = s.ReadSingle();
            this.mParam7 = s.ReadSingle();
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mConfirmation = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a command with up to seven parameters to the MAV. The command microservice is documented at https://mavlink.io/en/services/command.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param1",
                Description = "Parameter 1 (for the specific command).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param2",
                Description = "Parameter 2 (for the specific command).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param3",
                Description = "Parameter 3 (for the specific command).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param4",
                Description = "Parameter 4 (for the specific command).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param5",
                Description = "Parameter 5 (for the specific command).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param6",
                Description = "Parameter 6 (for the specific command).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param7",
                Description = "Parameter 7 (for the specific command).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "Command ID (of command to send).",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System which should execute the command",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component which should execute the command, 0 for all components",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Confirmation",
                Description = "0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)",
                NumElements = 1,
            });

        }

        private float mParam1;
        private float mParam2;
        private float mParam3;
        private float mParam4;
        private float mParam5;
        private float mParam6;
        private float mParam7;
        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mConfirmation;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Report status of a command. Includes feedback whether the command was executed. The command microservice is documented at https://mavlink.io/en/services/command.html
    /// </summary>
    public class UasCommandAck: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 4; }
        }
        /// <summary>
        /// Command ID (of acknowledged command).
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Result of command.
        /// </summary>
        public MavResult Result {
            get { return mResult; }
            set { mResult = value; NotifyUpdated(); }
        }

        public UasCommandAck()
        {
            mMessageId = 77;
            CrcExtra = 143;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write((UInt16)mCommand);
            s.Write((byte)mResult);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mResult = (MavResult)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Report status of a command. Includes feedback whether the command was executed. The command microservice is documented at https://mavlink.io/en/services/command.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "Command ID (of acknowledged command).",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Result",
                Description = "Result of command.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavResult"),
            });

        }

        private MavCmd mCommand;
        private MavResult mResult;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Cancel a long running command. The target system should respond with a COMMAND_ACK to the original command with result=MAV_RESULT_CANCELLED if the long running process was cancelled. If it has already completed, the cancel action can be ignored. The cancel action can be retried until some sort of acknowledgement to the original command has been received. The command microservice is documented at https://mavlink.io/en/services/command.html
    /// </summary>
    public class UasCommandCancel: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// Command ID (of command to cancel).
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System executing long running command. Should not be broadcast (0).
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component executing long running command.
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasCommandCancel()
        {
            mMessageId = 80;
            CrcExtra = 14;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Cancel a long running command. The target system should respond with a COMMAND_ACK to the original command with result=MAV_RESULT_CANCELLED if the long running process was cancelled. If it has already completed, the cancel action can be ignored. The cancel action can be retried until some sort of acknowledgement to the original command has been received. The command microservice is documented at https://mavlink.io/en/services/command.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "Command ID (of command to cancel).",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System executing long running command. Should not be broadcast (0).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component executing long running command.",
                NumElements = 1,
            });

        }

        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Setpoint in roll, pitch, yaw and thrust from the operator
    /// </summary>
    public class UasManualSetpoint: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 24; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Desired roll rate
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Desired pitch rate
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Desired yaw rate
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Collective thrust, normalized to 0 .. 1
        /// </summary>
        public float Thrust {
            get { return mThrust; }
            set { mThrust = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flight mode switch position, 0.. 255
        /// </summary>
        public byte ModeSwitch {
            get { return mModeSwitch; }
            set { mModeSwitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Override mode switch position, 0.. 255
        /// </summary>
        public byte ManualOverrideSwitch {
            get { return mManualOverrideSwitch; }
            set { mManualOverrideSwitch = value; NotifyUpdated(); }
        }

        public UasManualSetpoint()
        {
            mMessageId = 81;
            CrcExtra = 106;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mThrust);
            s.Write(mModeSwitch);
            s.Write(mManualOverrideSwitch);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mThrust = s.ReadSingle();
            this.mModeSwitch = s.ReadByte();
            this.mManualOverrideSwitch = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Setpoint in roll, pitch, yaw and thrust from the operator"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Desired roll rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Desired pitch rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Desired yaw rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Thrust",
                Description = "Collective thrust, normalized to 0 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ModeSwitch",
                Description = "Flight mode switch position, 0.. 255",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ManualOverrideSwitch",
                Description = "Override mode switch position, 0.. 255",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mThrust;
        private byte mModeSwitch;
        private byte mManualOverrideSwitch;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller or other system).
    /// </summary>
    public class UasSetAttitudeTarget: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 42; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body roll rate
        /// </summary>
        public float BodyRollRate {
            get { return mBodyRollRate; }
            set { mBodyRollRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body pitch rate
        /// </summary>
        public float BodyPitchRate {
            get { return mBodyPitchRate; }
            set { mBodyPitchRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body yaw rate
        /// </summary>
        public float BodyYawRate {
            get { return mBodyYawRate; }
            set { mBodyYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
        /// </summary>
        public float Thrust {
            get { return mThrust; }
            set { mThrust = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap to indicate which dimensions should be ignored by the vehicle.
        /// </summary>
        public AttitudeTargetTypemask TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        public UasSetAttitudeTarget()
        {
            mMessageId = 82;
            CrcExtra = 49;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mBodyRollRate);
            s.Write(mBodyPitchRate);
            s.Write(mBodyYawRate);
            s.Write(mThrust);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mTypeMask);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mBodyRollRate = s.ReadSingle();
            this.mBodyPitchRate = s.ReadSingle();
            this.mBodyYawRate = s.ReadSingle();
            this.mThrust = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mTypeMask = (AttitudeTargetTypemask)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller or other system)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyRollRate",
                Description = "Body roll rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyPitchRate",
                Description = "Body pitch rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyYawRate",
                Description = "Body yaw rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Thrust",
                Description = "Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmap to indicate which dimensions should be ignored by the vehicle.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("AttitudeTargetTypemask"),
            });

        }

        private UInt32 mTimeBootMs;
        private float[] mQ = new float[4];
        private float mBodyRollRate;
        private float mBodyPitchRate;
        private float mBodyYawRate;
        private float mThrust;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private AttitudeTargetTypemask mTypeMask;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way.
    /// </summary>
    public class UasAttitudeTarget: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 38; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body roll rate
        /// </summary>
        public float BodyRollRate {
            get { return mBodyRollRate; }
            set { mBodyRollRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body pitch rate
        /// </summary>
        public float BodyPitchRate {
            get { return mBodyPitchRate; }
            set { mBodyPitchRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body yaw rate
        /// </summary>
        public float BodyYawRate {
            get { return mBodyYawRate; }
            set { mBodyYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
        /// </summary>
        public float Thrust {
            get { return mThrust; }
            set { mThrust = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap to indicate which dimensions should be ignored by the vehicle.
        /// </summary>
        public AttitudeTargetTypemask TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        public UasAttitudeTarget()
        {
            mMessageId = 83;
            CrcExtra = 22;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mBodyRollRate);
            s.Write(mBodyPitchRate);
            s.Write(mBodyYawRate);
            s.Write(mThrust);
            s.Write((byte)mTypeMask);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mBodyRollRate = s.ReadSingle();
            this.mBodyPitchRate = s.ReadSingle();
            this.mBodyYawRate = s.ReadSingle();
            this.mThrust = s.ReadSingle();
            this.mTypeMask = (AttitudeTargetTypemask)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyRollRate",
                Description = "Body roll rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyPitchRate",
                Description = "Body pitch rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyYawRate",
                Description = "Body yaw rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Thrust",
                Description = "Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmap to indicate which dimensions should be ignored by the vehicle.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("AttitudeTargetTypemask"),
            });

        }

        private UInt32 mTimeBootMs;
        private float[] mQ = new float[4];
        private float mBodyRollRate;
        private float mBodyPitchRate;
        private float mBodyYawRate;
        private float mThrust;
        private AttitudeTargetTypemask mTypeMask;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller to command the vehicle (manual controller or other system).
    /// </summary>
    public class UasSetPositionTargetLocalNed: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 56; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position in NED frame
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position in NED frame
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position in NED frame (note, altitude is negative in NED)
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in NED frame
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in NED frame
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in NED frame
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afx {
            get { return mAfx; }
            set { mAfx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afy {
            get { return mAfy; }
            set { mAfy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afz {
            get { return mAfz; }
            set { mAfz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw setpoint
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw rate setpoint
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap to indicate which dimensions should be ignored by the vehicle.
        /// </summary>
        public PositionTargetTypemask TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
        /// </summary>
        public MavFrame CoordinateFrame {
            get { return mCoordinateFrame; }
            set { mCoordinateFrame = value; NotifyUpdated(); }
        }

        public UasSetPositionTargetLocalNed()
        {
            mMessageId = 84;
            CrcExtra = 143;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAfx);
            s.Write(mAfy);
            s.Write(mAfz);
            s.Write(mYaw);
            s.Write(mYawRate);
            s.Write((UInt16)mTypeMask);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mCoordinateFrame);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAfx = s.ReadSingle();
            this.mAfy = s.ReadSingle();
            this.mAfz = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
            this.mTypeMask = (PositionTargetTypemask)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mCoordinateFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller to command the vehicle (manual controller or other system)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position in NED frame (note, altitude is negative in NED)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afx",
                Description = "X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afy",
                Description = "Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afz",
                Description = "Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "yaw setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "yaw rate setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmap to indicate which dimensions should be ignored by the vehicle.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("PositionTargetTypemask"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CoordinateFrame",
                Description = "Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAfx;
        private float mAfy;
        private float mAfz;
        private float mYaw;
        private float mYawRate;
        private PositionTargetTypemask mTypeMask;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mCoordinateFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled this way.
    /// </summary>
    public class UasPositionTargetLocalNed: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 52; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position in NED frame
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position in NED frame
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position in NED frame (note, altitude is negative in NED)
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in NED frame
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in NED frame
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in NED frame
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afx {
            get { return mAfx; }
            set { mAfx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afy {
            get { return mAfy; }
            set { mAfy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afz {
            get { return mAfz; }
            set { mAfz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw setpoint
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw rate setpoint
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap to indicate which dimensions should be ignored by the vehicle.
        /// </summary>
        public PositionTargetTypemask TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
        /// </summary>
        public MavFrame CoordinateFrame {
            get { return mCoordinateFrame; }
            set { mCoordinateFrame = value; NotifyUpdated(); }
        }

        public UasPositionTargetLocalNed()
        {
            mMessageId = 85;
            CrcExtra = 140;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAfx);
            s.Write(mAfy);
            s.Write(mAfz);
            s.Write(mYaw);
            s.Write(mYawRate);
            s.Write((UInt16)mTypeMask);
            s.Write((byte)mCoordinateFrame);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAfx = s.ReadSingle();
            this.mAfy = s.ReadSingle();
            this.mAfz = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
            this.mTypeMask = (PositionTargetTypemask)s.ReadUInt16();
            this.mCoordinateFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled this way."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position in NED frame (note, altitude is negative in NED)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afx",
                Description = "X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afy",
                Description = "Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afz",
                Description = "Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "yaw setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "yaw rate setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmap to indicate which dimensions should be ignored by the vehicle.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("PositionTargetTypemask"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CoordinateFrame",
                Description = "Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAfx;
        private float mAfy;
        private float mAfz;
        private float mYaw;
        private float mYawRate;
        private PositionTargetTypemask mTypeMask;
        private MavFrame mCoordinateFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84). Used by an external controller to command the vehicle (manual controller or other system).
    /// </summary>
    public class UasSetPositionTargetGlobalInt: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 56; }
        }
        /// <summary>
        /// Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position in WGS84 frame
        /// </summary>
        public Int32 LatInt {
            get { return mLatInt; }
            set { mLatInt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position in WGS84 frame
        /// </summary>
        public Int32 LonInt {
            get { return mLonInt; }
            set { mLonInt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL, Relative to home, or AGL - depending on frame)
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in NED frame
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in NED frame
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in NED frame
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afx {
            get { return mAfx; }
            set { mAfx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afy {
            get { return mAfy; }
            set { mAfy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afz {
            get { return mAfz; }
            set { mAfz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw setpoint
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw rate setpoint
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap to indicate which dimensions should be ignored by the vehicle.
        /// </summary>
        public PositionTargetTypemask TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
        /// </summary>
        public MavFrame CoordinateFrame {
            get { return mCoordinateFrame; }
            set { mCoordinateFrame = value; NotifyUpdated(); }
        }

        public UasSetPositionTargetGlobalInt()
        {
            mMessageId = 86;
            CrcExtra = 5;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mLatInt);
            s.Write(mLonInt);
            s.Write(mAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAfx);
            s.Write(mAfy);
            s.Write(mAfz);
            s.Write(mYaw);
            s.Write(mYawRate);
            s.Write((UInt16)mTypeMask);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mCoordinateFrame);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mLatInt = s.ReadInt32();
            this.mLonInt = s.ReadInt32();
            this.mAlt = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAfx = s.ReadSingle();
            this.mAfy = s.ReadSingle();
            this.mAfz = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
            this.mTypeMask = (PositionTargetTypemask)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mCoordinateFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84). Used by an external controller to command the vehicle (manual controller or other system)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LatInt",
                Description = "X Position in WGS84 frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LonInt",
                Description = "Y Position in WGS84 frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (MSL, Relative to home, or AGL - depending on frame)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afx",
                Description = "X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afy",
                Description = "Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afz",
                Description = "Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "yaw setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "yaw rate setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmap to indicate which dimensions should be ignored by the vehicle.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("PositionTargetTypemask"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CoordinateFrame",
                Description = "Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt32 mTimeBootMs;
        private Int32 mLatInt;
        private Int32 mLonInt;
        private float mAlt;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAfx;
        private float mAfy;
        private float mAfz;
        private float mYaw;
        private float mYawRate;
        private PositionTargetTypemask mTypeMask;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mCoordinateFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way.
    /// </summary>
    public class UasPositionTargetGlobalInt: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 52; }
        }
        /// <summary>
        /// Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position in WGS84 frame
        /// </summary>
        public Int32 LatInt {
            get { return mLatInt; }
            set { mLatInt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position in WGS84 frame
        /// </summary>
        public Int32 LonInt {
            get { return mLonInt; }
            set { mLonInt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL, AGL or relative to home altitude, depending on frame)
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in NED frame
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in NED frame
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in NED frame
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afx {
            get { return mAfx; }
            set { mAfx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afy {
            get { return mAfy; }
            set { mAfy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afz {
            get { return mAfz; }
            set { mAfz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw setpoint
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw rate setpoint
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap to indicate which dimensions should be ignored by the vehicle.
        /// </summary>
        public PositionTargetTypemask TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
        /// </summary>
        public MavFrame CoordinateFrame {
            get { return mCoordinateFrame; }
            set { mCoordinateFrame = value; NotifyUpdated(); }
        }

        public UasPositionTargetGlobalInt()
        {
            mMessageId = 87;
            CrcExtra = 150;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mLatInt);
            s.Write(mLonInt);
            s.Write(mAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAfx);
            s.Write(mAfy);
            s.Write(mAfz);
            s.Write(mYaw);
            s.Write(mYawRate);
            s.Write((UInt16)mTypeMask);
            s.Write((byte)mCoordinateFrame);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mLatInt = s.ReadInt32();
            this.mLonInt = s.ReadInt32();
            this.mAlt = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAfx = s.ReadSingle();
            this.mAfy = s.ReadSingle();
            this.mAfz = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
            this.mTypeMask = (PositionTargetTypemask)s.ReadUInt16();
            this.mCoordinateFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LatInt",
                Description = "X Position in WGS84 frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LonInt",
                Description = "Y Position in WGS84 frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (MSL, AGL or relative to home altitude, depending on frame)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z velocity in NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afx",
                Description = "X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afy",
                Description = "Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afz",
                Description = "Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "yaw setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "yaw rate setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmap to indicate which dimensions should be ignored by the vehicle.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("PositionTargetTypemask"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CoordinateFrame",
                Description = "Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt32 mTimeBootMs;
        private Int32 mLatInt;
        private Int32 mLonInt;
        private float mAlt;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAfx;
        private float mAfy;
        private float mAfz;
        private float mYaw;
        private float mYawRate;
        private PositionTargetTypemask mTypeMask;
        private MavFrame mCoordinateFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    /// </summary>
    public class UasLocalPositionNedSystemGlobalOffset: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 28; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        public UasLocalPositionNedSystemGlobalOffset()
        {
            mMessageId = 89;
            CrcExtra = 231;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mRoll;
        private float mPitch;
        private float mYaw;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations.
    /// </summary>
    public class UasHilState: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 56; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame roll / phi angular speed
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame pitch / theta angular speed
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame yaw / psi angular speed
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground X Speed (Latitude)
        /// </summary>
        public Int16 Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Y Speed (Longitude)
        /// </summary>
        public Int16 Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Z Speed (Altitude)
        /// </summary>
        public Int16 Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        public UasHilState()
        {
            mMessageId = 90;
            CrcExtra = 183;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mVx = s.ReadInt16();
            this.mVy = s.ReadInt16();
            this.mVz = s.ReadInt16();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Body frame roll / phi angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Body frame pitch / theta angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Body frame yaw / psi angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "Ground X Speed (Latitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Ground Y Speed (Longitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Ground Z Speed (Altitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private Int16 mVx;
        private Int16 mVy;
        private Int16 mVz;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sent from autopilot to simulation. Hardware in the loop control outputs
    /// </summary>
    public class UasHilControls: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 44; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Control output -1 .. 1
        /// </summary>
        public float RollAilerons {
            get { return mRollAilerons; }
            set { mRollAilerons = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Control output -1 .. 1
        /// </summary>
        public float PitchElevator {
            get { return mPitchElevator; }
            set { mPitchElevator = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Control output -1 .. 1
        /// </summary>
        public float YawRudder {
            get { return mYawRudder; }
            set { mYawRudder = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Throttle 0 .. 1
        /// </summary>
        public float Throttle {
            get { return mThrottle; }
            set { mThrottle = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Aux 1, -1 .. 1
        /// </summary>
        public float Aux1 {
            get { return mAux1; }
            set { mAux1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Aux 2, -1 .. 1
        /// </summary>
        public float Aux2 {
            get { return mAux2; }
            set { mAux2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Aux 3, -1 .. 1
        /// </summary>
        public float Aux3 {
            get { return mAux3; }
            set { mAux3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Aux 4, -1 .. 1
        /// </summary>
        public float Aux4 {
            get { return mAux4; }
            set { mAux4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System mode.
        /// </summary>
        public MavMode Mode {
            get { return mMode; }
            set { mMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Navigation mode (MAV_NAV_MODE)
        /// </summary>
        public byte NavMode {
            get { return mNavMode; }
            set { mNavMode = value; NotifyUpdated(); }
        }

        public UasHilControls()
        {
            mMessageId = 91;
            CrcExtra = 63;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mRollAilerons);
            s.Write(mPitchElevator);
            s.Write(mYawRudder);
            s.Write(mThrottle);
            s.Write(mAux1);
            s.Write(mAux2);
            s.Write(mAux3);
            s.Write(mAux4);
            s.Write((byte)mMode);
            s.Write(mNavMode);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mRollAilerons = s.ReadSingle();
            this.mPitchElevator = s.ReadSingle();
            this.mYawRudder = s.ReadSingle();
            this.mThrottle = s.ReadSingle();
            this.mAux1 = s.ReadSingle();
            this.mAux2 = s.ReadSingle();
            this.mAux3 = s.ReadSingle();
            this.mAux4 = s.ReadSingle();
            this.mMode = (MavMode)s.ReadByte();
            this.mNavMode = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sent from autopilot to simulation. Hardware in the loop control outputs"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RollAilerons",
                Description = "Control output -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PitchElevator",
                Description = "Control output -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRudder",
                Description = "Control output -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Throttle",
                Description = "Throttle 0 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aux1",
                Description = "Aux 1, -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aux2",
                Description = "Aux 2, -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aux3",
                Description = "Aux 3, -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aux4",
                Description = "Aux 4, -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Mode",
                Description = "System mode.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavMode"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NavMode",
                Description = "Navigation mode (MAV_NAV_MODE)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mRollAilerons;
        private float mPitchElevator;
        private float mYawRudder;
        private float mThrottle;
        private float mAux1;
        private float mAux2;
        private float mAux3;
        private float mAux4;
        private MavMode mMode;
        private byte mNavMode;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
    /// </summary>
    public class UasHilRcInputsRaw: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 34; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 1 value
        /// </summary>
        public UInt16 Chan1Raw {
            get { return mChan1Raw; }
            set { mChan1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value
        /// </summary>
        public UInt16 Chan2Raw {
            get { return mChan2Raw; }
            set { mChan2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value
        /// </summary>
        public UInt16 Chan3Raw {
            get { return mChan3Raw; }
            set { mChan3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value
        /// </summary>
        public UInt16 Chan4Raw {
            get { return mChan4Raw; }
            set { mChan4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value
        /// </summary>
        public UInt16 Chan5Raw {
            get { return mChan5Raw; }
            set { mChan5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value
        /// </summary>
        public UInt16 Chan6Raw {
            get { return mChan6Raw; }
            set { mChan6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value
        /// </summary>
        public UInt16 Chan7Raw {
            get { return mChan7Raw; }
            set { mChan7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value
        /// </summary>
        public UInt16 Chan8Raw {
            get { return mChan8Raw; }
            set { mChan8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 9 value
        /// </summary>
        public UInt16 Chan9Raw {
            get { return mChan9Raw; }
            set { mChan9Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 10 value
        /// </summary>
        public UInt16 Chan10Raw {
            get { return mChan10Raw; }
            set { mChan10Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 11 value
        /// </summary>
        public UInt16 Chan11Raw {
            get { return mChan11Raw; }
            set { mChan11Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 12 value
        /// </summary>
        public UInt16 Chan12Raw {
            get { return mChan12Raw; }
            set { mChan12Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        public UasHilRcInputsRaw()
        {
            mMessageId = 92;
            CrcExtra = 54;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mChan1Raw);
            s.Write(mChan2Raw);
            s.Write(mChan3Raw);
            s.Write(mChan4Raw);
            s.Write(mChan5Raw);
            s.Write(mChan6Raw);
            s.Write(mChan7Raw);
            s.Write(mChan8Raw);
            s.Write(mChan9Raw);
            s.Write(mChan10Raw);
            s.Write(mChan11Raw);
            s.Write(mChan12Raw);
            s.Write(mRssi);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mChan1Raw = s.ReadUInt16();
            this.mChan2Raw = s.ReadUInt16();
            this.mChan3Raw = s.ReadUInt16();
            this.mChan4Raw = s.ReadUInt16();
            this.mChan5Raw = s.ReadUInt16();
            this.mChan6Raw = s.ReadUInt16();
            this.mChan7Raw = s.ReadUInt16();
            this.mChan8Raw = s.ReadUInt16();
            this.mChan9Raw = s.ReadUInt16();
            this.mChan10Raw = s.ReadUInt16();
            this.mChan11Raw = s.ReadUInt16();
            this.mChan12Raw = s.ReadUInt16();
            this.mRssi = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Raw",
                Description = "RC channel 1 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Raw",
                Description = "RC channel 2 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Raw",
                Description = "RC channel 3 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Raw",
                Description = "RC channel 4 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Raw",
                Description = "RC channel 5 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Raw",
                Description = "RC channel 6 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Raw",
                Description = "RC channel 7 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Raw",
                Description = "RC channel 8 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan9Raw",
                Description = "RC channel 9 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan10Raw",
                Description = "RC channel 10 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan11Raw",
                Description = "RC channel 11 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan12Raw",
                Description = "RC channel 12 value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt16 mChan1Raw;
        private UInt16 mChan2Raw;
        private UInt16 mChan3Raw;
        private UInt16 mChan4Raw;
        private UInt16 mChan5Raw;
        private UInt16 mChan6Raw;
        private UInt16 mChan7Raw;
        private UInt16 mChan8Raw;
        private UInt16 mChan9Raw;
        private UInt16 mChan10Raw;
        private UInt16 mChan11Raw;
        private UInt16 mChan12Raw;
        private byte mRssi;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sent from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS)
    /// </summary>
    public class UasHilActuatorControls: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 82; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flags as bitfield, 1: indicate simulation using lockstep.
        /// </summary>
        public UInt64 Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.
        /// </summary>
        public float[] Controls {
            get { return mControls; }
            set { mControls = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System mode. Includes arming state.
        /// </summary>
        public MavModeFlag Mode {
            get { return mMode; }
            set { mMode = value; NotifyUpdated(); }
        }

        public UasHilActuatorControls()
        {
            mMessageId = 93;
            CrcExtra = 47;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mFlags);
            s.Write(mControls[0]); 
            s.Write(mControls[1]); 
            s.Write(mControls[2]); 
            s.Write(mControls[3]); 
            s.Write(mControls[4]); 
            s.Write(mControls[5]); 
            s.Write(mControls[6]); 
            s.Write(mControls[7]); 
            s.Write(mControls[8]); 
            s.Write(mControls[9]); 
            s.Write(mControls[10]); 
            s.Write(mControls[11]); 
            s.Write(mControls[12]); 
            s.Write(mControls[13]); 
            s.Write(mControls[14]); 
            s.Write(mControls[15]); 
            s.Write((byte)mMode);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mFlags = s.ReadUInt64();
            this.mControls[0] = s.ReadSingle();
            this.mControls[1] = s.ReadSingle();
            this.mControls[2] = s.ReadSingle();
            this.mControls[3] = s.ReadSingle();
            this.mControls[4] = s.ReadSingle();
            this.mControls[5] = s.ReadSingle();
            this.mControls[6] = s.ReadSingle();
            this.mControls[7] = s.ReadSingle();
            this.mControls[8] = s.ReadSingle();
            this.mControls[9] = s.ReadSingle();
            this.mControls[10] = s.ReadSingle();
            this.mControls[11] = s.ReadSingle();
            this.mControls[12] = s.ReadSingle();
            this.mControls[13] = s.ReadSingle();
            this.mControls[14] = s.ReadSingle();
            this.mControls[15] = s.ReadSingle();
            this.mMode = (MavModeFlag)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sent from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "Flags as bitfield, 1: indicate simulation using lockstep.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Controls",
                Description = "Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Mode",
                Description = "System mode. Includes arming state.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavModeFlag"),
            });

        }

        private UInt64 mTimeUsec;
        private UInt64 mFlags;
        private float[] mControls = new float[16];
        private MavModeFlag mMode;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Optical flow from a flow sensor (e.g. optical mouse sensor)
    /// </summary>
    public class UasOpticalFlow: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 28; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in x-sensor direction, angular-speed compensated
        /// </summary>
        public float FlowCompMX {
            get { return mFlowCompMX; }
            set { mFlowCompMX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in y-sensor direction, angular-speed compensated
        /// </summary>
        public float FlowCompMY {
            get { return mFlowCompMY; }
            set { mFlowCompMY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground distance. Positive value: distance known. Negative value: Unknown distance
        /// </summary>
        public float GroundDistance {
            get { return mGroundDistance; }
            set { mGroundDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in x-sensor direction
        /// </summary>
        public Int16 FlowX {
            get { return mFlowX; }
            set { mFlowX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in y-sensor direction
        /// </summary>
        public Int16 FlowY {
            get { return mFlowY; }
            set { mFlowY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Sensor ID
        /// </summary>
        public byte SensorId {
            get { return mSensorId; }
            set { mSensorId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Optical flow quality / confidence. 0: bad, 255: maximum quality
        /// </summary>
        public byte Quality {
            get { return mQuality; }
            set { mQuality = value; NotifyUpdated(); }
        }

        public UasOpticalFlow()
        {
            mMessageId = 100;
            CrcExtra = 175;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mFlowCompMX);
            s.Write(mFlowCompMY);
            s.Write(mGroundDistance);
            s.Write(mFlowX);
            s.Write(mFlowY);
            s.Write(mSensorId);
            s.Write(mQuality);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mFlowCompMX = s.ReadSingle();
            this.mFlowCompMY = s.ReadSingle();
            this.mGroundDistance = s.ReadSingle();
            this.mFlowX = s.ReadInt16();
            this.mFlowY = s.ReadInt16();
            this.mSensorId = s.ReadByte();
            this.mQuality = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Optical flow from a flow sensor (e.g. optical mouse sensor)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlowCompMX",
                Description = "Flow in x-sensor direction, angular-speed compensated",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlowCompMY",
                Description = "Flow in y-sensor direction, angular-speed compensated",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GroundDistance",
                Description = "Ground distance. Positive value: distance known. Negative value: Unknown distance",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlowX",
                Description = "Flow in x-sensor direction",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlowY",
                Description = "Flow in y-sensor direction",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SensorId",
                Description = "Sensor ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Quality",
                Description = "Optical flow quality / confidence. 0: bad, 255: maximum quality",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mFlowCompMX;
        private float mFlowCompMY;
        private float mGroundDistance;
        private Int16 mFlowX;
        private Int16 mFlowY;
        private byte mSensorId;
        private byte mQuality;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Global position/attitude estimate from a vision source.
    /// </summary>
    public class UasGlobalVisionPositionEstimate: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Timestamp (UNIX time or since system boot)
        /// </summary>
        public UInt64 Usec {
            get { return mUsec; }
            set { mUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global X position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Y position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Z position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        public UasGlobalVisionPositionEstimate()
        {
            mMessageId = 101;
            CrcExtra = 102;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Global position/attitude estimate from a vision source."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Usec",
                Description = "Timestamp (UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Global X position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Global Y position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Global Z position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle",
                NumElements = 1,
            });

        }

        private UInt64 mUsec;
        private float mX;
        private float mY;
        private float mZ;
        private float mRoll;
        private float mPitch;
        private float mYaw;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Local position/attitude estimate from a vision source.
    /// </summary>
    public class UasVisionPositionEstimate: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Timestamp (UNIX time or time since system boot)
        /// </summary>
        public UInt64 Usec {
            get { return mUsec; }
            set { mUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        public UasVisionPositionEstimate()
        {
            mMessageId = 102;
            CrcExtra = 158;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Local position/attitude estimate from a vision source."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Usec",
                Description = "Timestamp (UNIX time or time since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Local X position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Local Y position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Local Z position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle",
                NumElements = 1,
            });

        }

        private UInt64 mUsec;
        private float mX;
        private float mY;
        private float mZ;
        private float mRoll;
        private float mPitch;
        private float mYaw;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Speed estimate from a vision source.
    /// </summary>
    public class UasVisionSpeedEstimate: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 20; }
        }
        /// <summary>
        /// Timestamp (UNIX time or time since system boot)
        /// </summary>
        public UInt64 Usec {
            get { return mUsec; }
            set { mUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global X speed
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Y speed
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Z speed
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        public UasVisionSpeedEstimate()
        {
            mMessageId = 103;
            CrcExtra = 208;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Speed estimate from a vision source."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Usec",
                Description = "Timestamp (UNIX time or time since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Global X speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Global Y speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Global Z speed",
                NumElements = 1,
            });

        }

        private UInt64 mUsec;
        private float mX;
        private float mY;
        private float mZ;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Global position estimate from a Vicon motion system source.
    /// </summary>
    public class UasViconPositionEstimate: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Timestamp (UNIX time or time since system boot)
        /// </summary>
        public UInt64 Usec {
            get { return mUsec; }
            set { mUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global X position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Y position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Z position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        public UasViconPositionEstimate()
        {
            mMessageId = 104;
            CrcExtra = 56;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Global position estimate from a Vicon motion system source."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Usec",
                Description = "Timestamp (UNIX time or time since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Global X position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Global Y position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Global Z position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle",
                NumElements = 1,
            });

        }

        private UInt64 mUsec;
        private float mX;
        private float mY;
        private float mZ;
        private float mRoll;
        private float mPitch;
        private float mYaw;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The IMU readings in SI units in NED body frame
    /// </summary>
    public class UasHighresImu: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 62; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration
        /// </summary>
        public float Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration
        /// </summary>
        public float Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration
        /// </summary>
        public float Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis
        /// </summary>
        public float Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis
        /// </summary>
        public float Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis
        /// </summary>
        public float Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field
        /// </summary>
        public float Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field
        /// </summary>
        public float Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field
        /// </summary>
        public float Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure
        /// </summary>
        public float AbsPressure {
            get { return mAbsPressure; }
            set { mAbsPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure
        /// </summary>
        public float DiffPressure {
            get { return mDiffPressure; }
            set { mDiffPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude calculated from pressure
        /// </summary>
        public float PressureAlt {
            get { return mPressureAlt; }
            set { mPressureAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature
        /// </summary>
        public float Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap for fields that have updated since last message
        /// </summary>
        public HighresImuUpdatedFlags FieldsUpdated {
            get { return mFieldsUpdated; }
            set { mFieldsUpdated = value; NotifyUpdated(); }
        }

        public UasHighresImu()
        {
            mMessageId = 105;
            CrcExtra = 93;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
            s.Write(mAbsPressure);
            s.Write(mDiffPressure);
            s.Write(mPressureAlt);
            s.Write(mTemperature);
            s.Write((UInt16)mFieldsUpdated);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mXacc = s.ReadSingle();
            this.mYacc = s.ReadSingle();
            this.mZacc = s.ReadSingle();
            this.mXgyro = s.ReadSingle();
            this.mYgyro = s.ReadSingle();
            this.mZgyro = s.ReadSingle();
            this.mXmag = s.ReadSingle();
            this.mYmag = s.ReadSingle();
            this.mZmag = s.ReadSingle();
            this.mAbsPressure = s.ReadSingle();
            this.mDiffPressure = s.ReadSingle();
            this.mPressureAlt = s.ReadSingle();
            this.mTemperature = s.ReadSingle();
            this.mFieldsUpdated = (HighresImuUpdatedFlags)s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The IMU readings in SI units in NED body frame"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AbsPressure",
                Description = "Absolute pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiffPressure",
                Description = "Differential pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressureAlt",
                Description = "Altitude calculated from pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FieldsUpdated",
                Description = "Bitmap for fields that have updated since last message",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("HighresImuUpdatedFlags"),
            });

        }

        private UInt64 mTimeUsec;
        private float mXacc;
        private float mYacc;
        private float mZacc;
        private float mXgyro;
        private float mYgyro;
        private float mZgyro;
        private float mXmag;
        private float mYmag;
        private float mZmag;
        private float mAbsPressure;
        private float mDiffPressure;
        private float mPressureAlt;
        private float mTemperature;
        private HighresImuUpdatedFlags mFieldsUpdated;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor)
    /// </summary>
    public class UasOpticalFlowRad: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 46; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
        /// </summary>
        public UInt32 IntegrationTimeUs {
            get { return mIntegrationTimeUs; }
            set { mIntegrationTimeUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
        /// </summary>
        public float IntegratedX {
            get { return mIntegratedX; }
            set { mIntegratedX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
        /// </summary>
        public float IntegratedY {
            get { return mIntegratedY; }
            set { mIntegratedY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around X axis
        /// </summary>
        public float IntegratedXgyro {
            get { return mIntegratedXgyro; }
            set { mIntegratedXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around Y axis
        /// </summary>
        public float IntegratedYgyro {
            get { return mIntegratedYgyro; }
            set { mIntegratedYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around Z axis
        /// </summary>
        public float IntegratedZgyro {
            get { return mIntegratedZgyro; }
            set { mIntegratedZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Time since the distance was sampled.
        /// </summary>
        public UInt32 TimeDeltaDistanceUs {
            get { return mTimeDeltaDistanceUs; }
            set { mTimeDeltaDistanceUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance.
        /// </summary>
        public float Distance {
            get { return mDistance; }
            set { mDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Sensor ID
        /// </summary>
        public byte SensorId {
            get { return mSensorId; }
            set { mSensorId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
        /// </summary>
        public byte Quality {
            get { return mQuality; }
            set { mQuality = value; NotifyUpdated(); }
        }

        public UasOpticalFlowRad()
        {
            mMessageId = 106;
            CrcExtra = 138;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mIntegrationTimeUs);
            s.Write(mIntegratedX);
            s.Write(mIntegratedY);
            s.Write(mIntegratedXgyro);
            s.Write(mIntegratedYgyro);
            s.Write(mIntegratedZgyro);
            s.Write(mTimeDeltaDistanceUs);
            s.Write(mDistance);
            s.Write(mTemperature);
            s.Write(mSensorId);
            s.Write(mQuality);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mIntegrationTimeUs = s.ReadUInt32();
            this.mIntegratedX = s.ReadSingle();
            this.mIntegratedY = s.ReadSingle();
            this.mIntegratedXgyro = s.ReadSingle();
            this.mIntegratedYgyro = s.ReadSingle();
            this.mIntegratedZgyro = s.ReadSingle();
            this.mTimeDeltaDistanceUs = s.ReadUInt32();
            this.mDistance = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
            this.mSensorId = s.ReadByte();
            this.mQuality = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegrationTimeUs",
                Description = "Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedX",
                Description = "Flow around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedY",
                Description = "Flow around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedXgyro",
                Description = "RH rotation around X axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedYgyro",
                Description = "RH rotation around Y axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedZgyro",
                Description = "RH rotation around Z axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeDeltaDistanceUs",
                Description = "Time since the distance was sampled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Distance",
                Description = "Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SensorId",
                Description = "Sensor ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Quality",
                Description = "Optical flow quality / confidence. 0: no valid flow, 255: maximum quality",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mIntegrationTimeUs;
        private float mIntegratedX;
        private float mIntegratedY;
        private float mIntegratedXgyro;
        private float mIntegratedYgyro;
        private float mIntegratedZgyro;
        private UInt32 mTimeDeltaDistanceUs;
        private float mDistance;
        private Int16 mTemperature;
        private byte mSensorId;
        private byte mQuality;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The IMU readings in SI units in NED body frame
    /// </summary>
    public class UasHilSensor: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 64; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration
        /// </summary>
        public float Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration
        /// </summary>
        public float Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration
        /// </summary>
        public float Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis in body frame
        /// </summary>
        public float Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis in body frame
        /// </summary>
        public float Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis in body frame
        /// </summary>
        public float Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field
        /// </summary>
        public float Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field
        /// </summary>
        public float Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field
        /// </summary>
        public float Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure
        /// </summary>
        public float AbsPressure {
            get { return mAbsPressure; }
            set { mAbsPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure (airspeed)
        /// </summary>
        public float DiffPressure {
            get { return mDiffPressure; }
            set { mDiffPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude calculated from pressure
        /// </summary>
        public float PressureAlt {
            get { return mPressureAlt; }
            set { mPressureAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature
        /// </summary>
        public float Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap for fields that have updated since last message
        /// </summary>
        public HilSensorUpdatedFlags FieldsUpdated {
            get { return mFieldsUpdated; }
            set { mFieldsUpdated = value; NotifyUpdated(); }
        }

        public UasHilSensor()
        {
            mMessageId = 107;
            CrcExtra = 108;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
            s.Write(mAbsPressure);
            s.Write(mDiffPressure);
            s.Write(mPressureAlt);
            s.Write(mTemperature);
            s.Write((UInt32)mFieldsUpdated);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mXacc = s.ReadSingle();
            this.mYacc = s.ReadSingle();
            this.mZacc = s.ReadSingle();
            this.mXgyro = s.ReadSingle();
            this.mYgyro = s.ReadSingle();
            this.mZgyro = s.ReadSingle();
            this.mXmag = s.ReadSingle();
            this.mYmag = s.ReadSingle();
            this.mZmag = s.ReadSingle();
            this.mAbsPressure = s.ReadSingle();
            this.mDiffPressure = s.ReadSingle();
            this.mPressureAlt = s.ReadSingle();
            this.mTemperature = s.ReadSingle();
            this.mFieldsUpdated = (HilSensorUpdatedFlags)s.ReadUInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The IMU readings in SI units in NED body frame"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AbsPressure",
                Description = "Absolute pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiffPressure",
                Description = "Differential pressure (airspeed)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressureAlt",
                Description = "Altitude calculated from pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FieldsUpdated",
                Description = "Bitmap for fields that have updated since last message",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("HilSensorUpdatedFlags"),
            });

        }

        private UInt64 mTimeUsec;
        private float mXacc;
        private float mYacc;
        private float mZacc;
        private float mXgyro;
        private float mYgyro;
        private float mZgyro;
        private float mXmag;
        private float mYmag;
        private float mZmag;
        private float mAbsPressure;
        private float mDiffPressure;
        private float mPressureAlt;
        private float mTemperature;
        private HilSensorUpdatedFlags mFieldsUpdated;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of simulation environment, if used
    /// </summary>
    public class UasSimState: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 84; }
        }
        /// <summary>
        /// True attitude quaternion component 1, w (1 in null-rotation)
        /// </summary>
        public float Q1 {
            get { return mQ1; }
            set { mQ1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True attitude quaternion component 2, x (0 in null-rotation)
        /// </summary>
        public float Q2 {
            get { return mQ2; }
            set { mQ2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True attitude quaternion component 3, y (0 in null-rotation)
        /// </summary>
        public float Q3 {
            get { return mQ3; }
            set { mQ3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True attitude quaternion component 4, z (0 in null-rotation)
        /// </summary>
        public float Q4 {
            get { return mQ4; }
            set { mQ4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration
        /// </summary>
        public float Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration
        /// </summary>
        public float Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration
        /// </summary>
        public float Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis
        /// </summary>
        public float Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis
        /// </summary>
        public float Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis
        /// </summary>
        public float Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude
        /// </summary>
        public float Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public float Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal position standard deviation
        /// </summary>
        public float StdDevHorz {
            get { return mStdDevHorz; }
            set { mStdDevHorz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical position standard deviation
        /// </summary>
        public float StdDevVert {
            get { return mStdDevVert; }
            set { mStdDevVert = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True velocity in north direction in earth-fixed NED frame
        /// </summary>
        public float Vn {
            get { return mVn; }
            set { mVn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True velocity in east direction in earth-fixed NED frame
        /// </summary>
        public float Ve {
            get { return mVe; }
            set { mVe = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True velocity in down direction in earth-fixed NED frame
        /// </summary>
        public float Vd {
            get { return mVd; }
            set { mVd = value; NotifyUpdated(); }
        }

        public UasSimState()
        {
            mMessageId = 108;
            CrcExtra = 32;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mQ1);
            s.Write(mQ2);
            s.Write(mQ3);
            s.Write(mQ4);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mStdDevHorz);
            s.Write(mStdDevVert);
            s.Write(mVn);
            s.Write(mVe);
            s.Write(mVd);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mQ1 = s.ReadSingle();
            this.mQ2 = s.ReadSingle();
            this.mQ3 = s.ReadSingle();
            this.mQ4 = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mXacc = s.ReadSingle();
            this.mYacc = s.ReadSingle();
            this.mZacc = s.ReadSingle();
            this.mXgyro = s.ReadSingle();
            this.mYgyro = s.ReadSingle();
            this.mZgyro = s.ReadSingle();
            this.mLat = s.ReadSingle();
            this.mLon = s.ReadSingle();
            this.mAlt = s.ReadSingle();
            this.mStdDevHorz = s.ReadSingle();
            this.mStdDevVert = s.ReadSingle();
            this.mVn = s.ReadSingle();
            this.mVe = s.ReadSingle();
            this.mVd = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of simulation environment, if used"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q1",
                Description = "True attitude quaternion component 1, w (1 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q2",
                Description = "True attitude quaternion component 2, x (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q3",
                Description = "True attitude quaternion component 3, y (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q4",
                Description = "True attitude quaternion component 4, z (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Attitude roll expressed as Euler angles, not recommended except for human-readable outputs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StdDevHorz",
                Description = "Horizontal position standard deviation",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StdDevVert",
                Description = "Vertical position standard deviation",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vn",
                Description = "True velocity in north direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ve",
                Description = "True velocity in east direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vd",
                Description = "True velocity in down direction in earth-fixed NED frame",
                NumElements = 1,
            });

        }

        private float mQ1;
        private float mQ2;
        private float mQ3;
        private float mQ4;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mXacc;
        private float mYacc;
        private float mZacc;
        private float mXgyro;
        private float mYgyro;
        private float mZgyro;
        private float mLat;
        private float mLon;
        private float mAlt;
        private float mStdDevHorz;
        private float mStdDevVert;
        private float mVn;
        private float mVe;
        private float mVd;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status generated by radio and injected into MAVLink stream.
    /// </summary>
    public class UasRadioStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 14; }
        }
        /// <summary>
        /// Count of radio packet receive errors (since boot).
        /// </summary>
        public UInt16 Rxerrors {
            get { return mRxerrors; }
            set { mRxerrors = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Count of error corrected radio packets (since boot).
        /// </summary>
        public UInt16 Fixed {
            get { return mFixed; }
            set { mFixed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local (message sender) recieved signal strength indication in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remote (message receiver) signal strength indication in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
        /// </summary>
        public byte Remrssi {
            get { return mRemrssi; }
            set { mRemrssi = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remaining free transmitter buffer space.
        /// </summary>
        public byte Txbuf {
            get { return mTxbuf; }
            set { mTxbuf = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], UINT8_MAX: invalid/unknown.
        /// </summary>
        public byte Noise {
            get { return mNoise; }
            set { mNoise = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remote background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], UINT8_MAX: invalid/unknown.
        /// </summary>
        public byte Remnoise {
            get { return mRemnoise; }
            set { mRemnoise = value; NotifyUpdated(); }
        }

        public UasRadioStatus()
        {
            mMessageId = 109;
            CrcExtra = 185;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mRxerrors);
            s.Write(mFixed);
            s.Write(mRssi);
            s.Write(mRemrssi);
            s.Write(mTxbuf);
            s.Write(mNoise);
            s.Write(mRemnoise);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mRxerrors = s.ReadUInt16();
            this.mFixed = s.ReadUInt16();
            this.mRssi = s.ReadByte();
            this.mRemrssi = s.ReadByte();
            this.mTxbuf = s.ReadByte();
            this.mNoise = s.ReadByte();
            this.mRemnoise = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status generated by radio and injected into MAVLink stream."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rxerrors",
                Description = "Count of radio packet receive errors (since boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Fixed",
                Description = "Count of error corrected radio packets (since boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Local (message sender) recieved signal strength indication in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Remrssi",
                Description = "Remote (message receiver) signal strength indication in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Txbuf",
                Description = "Remaining free transmitter buffer space.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Noise",
                Description = "Local background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], UINT8_MAX: invalid/unknown.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Remnoise",
                Description = "Remote background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], UINT8_MAX: invalid/unknown.",
                NumElements = 1,
            });

        }

        private UInt16 mRxerrors;
        private UInt16 mFixed;
        private byte mRssi;
        private byte mRemrssi;
        private byte mTxbuf;
        private byte mNoise;
        private byte mRemnoise;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// File transfer message
    /// </summary>
    public class UasFileTransferProtocol: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 508; }
        }
        /// <summary>
        /// Network ID (0 for broadcast)
        /// </summary>
        public byte TargetNetwork {
            get { return mTargetNetwork; }
            set { mTargetNetwork = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID (0 for broadcast)
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID (0 for broadcast)
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
        /// </summary>
        public byte[] Payload {
            get { return mPayload; }
            set { mPayload = value; NotifyUpdated(); }
        }

        public UasFileTransferProtocol()
        {
            mMessageId = 110;
            CrcExtra = 84;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetNetwork);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mPayload[0]); 
            s.Write(mPayload[1]); 
            s.Write(mPayload[2]); 
            s.Write(mPayload[3]); 
            s.Write(mPayload[4]); 
            s.Write(mPayload[5]); 
            s.Write(mPayload[6]); 
            s.Write(mPayload[7]); 
            s.Write(mPayload[8]); 
            s.Write(mPayload[9]); 
            s.Write(mPayload[10]); 
            s.Write(mPayload[11]); 
            s.Write(mPayload[12]); 
            s.Write(mPayload[13]); 
            s.Write(mPayload[14]); 
            s.Write(mPayload[15]); 
            s.Write(mPayload[16]); 
            s.Write(mPayload[17]); 
            s.Write(mPayload[18]); 
            s.Write(mPayload[19]); 
            s.Write(mPayload[20]); 
            s.Write(mPayload[21]); 
            s.Write(mPayload[22]); 
            s.Write(mPayload[23]); 
            s.Write(mPayload[24]); 
            s.Write(mPayload[25]); 
            s.Write(mPayload[26]); 
            s.Write(mPayload[27]); 
            s.Write(mPayload[28]); 
            s.Write(mPayload[29]); 
            s.Write(mPayload[30]); 
            s.Write(mPayload[31]); 
            s.Write(mPayload[32]); 
            s.Write(mPayload[33]); 
            s.Write(mPayload[34]); 
            s.Write(mPayload[35]); 
            s.Write(mPayload[36]); 
            s.Write(mPayload[37]); 
            s.Write(mPayload[38]); 
            s.Write(mPayload[39]); 
            s.Write(mPayload[40]); 
            s.Write(mPayload[41]); 
            s.Write(mPayload[42]); 
            s.Write(mPayload[43]); 
            s.Write(mPayload[44]); 
            s.Write(mPayload[45]); 
            s.Write(mPayload[46]); 
            s.Write(mPayload[47]); 
            s.Write(mPayload[48]); 
            s.Write(mPayload[49]); 
            s.Write(mPayload[50]); 
            s.Write(mPayload[51]); 
            s.Write(mPayload[52]); 
            s.Write(mPayload[53]); 
            s.Write(mPayload[54]); 
            s.Write(mPayload[55]); 
            s.Write(mPayload[56]); 
            s.Write(mPayload[57]); 
            s.Write(mPayload[58]); 
            s.Write(mPayload[59]); 
            s.Write(mPayload[60]); 
            s.Write(mPayload[61]); 
            s.Write(mPayload[62]); 
            s.Write(mPayload[63]); 
            s.Write(mPayload[64]); 
            s.Write(mPayload[65]); 
            s.Write(mPayload[66]); 
            s.Write(mPayload[67]); 
            s.Write(mPayload[68]); 
            s.Write(mPayload[69]); 
            s.Write(mPayload[70]); 
            s.Write(mPayload[71]); 
            s.Write(mPayload[72]); 
            s.Write(mPayload[73]); 
            s.Write(mPayload[74]); 
            s.Write(mPayload[75]); 
            s.Write(mPayload[76]); 
            s.Write(mPayload[77]); 
            s.Write(mPayload[78]); 
            s.Write(mPayload[79]); 
            s.Write(mPayload[80]); 
            s.Write(mPayload[81]); 
            s.Write(mPayload[82]); 
            s.Write(mPayload[83]); 
            s.Write(mPayload[84]); 
            s.Write(mPayload[85]); 
            s.Write(mPayload[86]); 
            s.Write(mPayload[87]); 
            s.Write(mPayload[88]); 
            s.Write(mPayload[89]); 
            s.Write(mPayload[90]); 
            s.Write(mPayload[91]); 
            s.Write(mPayload[92]); 
            s.Write(mPayload[93]); 
            s.Write(mPayload[94]); 
            s.Write(mPayload[95]); 
            s.Write(mPayload[96]); 
            s.Write(mPayload[97]); 
            s.Write(mPayload[98]); 
            s.Write(mPayload[99]); 
            s.Write(mPayload[100]); 
            s.Write(mPayload[101]); 
            s.Write(mPayload[102]); 
            s.Write(mPayload[103]); 
            s.Write(mPayload[104]); 
            s.Write(mPayload[105]); 
            s.Write(mPayload[106]); 
            s.Write(mPayload[107]); 
            s.Write(mPayload[108]); 
            s.Write(mPayload[109]); 
            s.Write(mPayload[110]); 
            s.Write(mPayload[111]); 
            s.Write(mPayload[112]); 
            s.Write(mPayload[113]); 
            s.Write(mPayload[114]); 
            s.Write(mPayload[115]); 
            s.Write(mPayload[116]); 
            s.Write(mPayload[117]); 
            s.Write(mPayload[118]); 
            s.Write(mPayload[119]); 
            s.Write(mPayload[120]); 
            s.Write(mPayload[121]); 
            s.Write(mPayload[122]); 
            s.Write(mPayload[123]); 
            s.Write(mPayload[124]); 
            s.Write(mPayload[125]); 
            s.Write(mPayload[126]); 
            s.Write(mPayload[127]); 
            s.Write(mPayload[128]); 
            s.Write(mPayload[129]); 
            s.Write(mPayload[130]); 
            s.Write(mPayload[131]); 
            s.Write(mPayload[132]); 
            s.Write(mPayload[133]); 
            s.Write(mPayload[134]); 
            s.Write(mPayload[135]); 
            s.Write(mPayload[136]); 
            s.Write(mPayload[137]); 
            s.Write(mPayload[138]); 
            s.Write(mPayload[139]); 
            s.Write(mPayload[140]); 
            s.Write(mPayload[141]); 
            s.Write(mPayload[142]); 
            s.Write(mPayload[143]); 
            s.Write(mPayload[144]); 
            s.Write(mPayload[145]); 
            s.Write(mPayload[146]); 
            s.Write(mPayload[147]); 
            s.Write(mPayload[148]); 
            s.Write(mPayload[149]); 
            s.Write(mPayload[150]); 
            s.Write(mPayload[151]); 
            s.Write(mPayload[152]); 
            s.Write(mPayload[153]); 
            s.Write(mPayload[154]); 
            s.Write(mPayload[155]); 
            s.Write(mPayload[156]); 
            s.Write(mPayload[157]); 
            s.Write(mPayload[158]); 
            s.Write(mPayload[159]); 
            s.Write(mPayload[160]); 
            s.Write(mPayload[161]); 
            s.Write(mPayload[162]); 
            s.Write(mPayload[163]); 
            s.Write(mPayload[164]); 
            s.Write(mPayload[165]); 
            s.Write(mPayload[166]); 
            s.Write(mPayload[167]); 
            s.Write(mPayload[168]); 
            s.Write(mPayload[169]); 
            s.Write(mPayload[170]); 
            s.Write(mPayload[171]); 
            s.Write(mPayload[172]); 
            s.Write(mPayload[173]); 
            s.Write(mPayload[174]); 
            s.Write(mPayload[175]); 
            s.Write(mPayload[176]); 
            s.Write(mPayload[177]); 
            s.Write(mPayload[178]); 
            s.Write(mPayload[179]); 
            s.Write(mPayload[180]); 
            s.Write(mPayload[181]); 
            s.Write(mPayload[182]); 
            s.Write(mPayload[183]); 
            s.Write(mPayload[184]); 
            s.Write(mPayload[185]); 
            s.Write(mPayload[186]); 
            s.Write(mPayload[187]); 
            s.Write(mPayload[188]); 
            s.Write(mPayload[189]); 
            s.Write(mPayload[190]); 
            s.Write(mPayload[191]); 
            s.Write(mPayload[192]); 
            s.Write(mPayload[193]); 
            s.Write(mPayload[194]); 
            s.Write(mPayload[195]); 
            s.Write(mPayload[196]); 
            s.Write(mPayload[197]); 
            s.Write(mPayload[198]); 
            s.Write(mPayload[199]); 
            s.Write(mPayload[200]); 
            s.Write(mPayload[201]); 
            s.Write(mPayload[202]); 
            s.Write(mPayload[203]); 
            s.Write(mPayload[204]); 
            s.Write(mPayload[205]); 
            s.Write(mPayload[206]); 
            s.Write(mPayload[207]); 
            s.Write(mPayload[208]); 
            s.Write(mPayload[209]); 
            s.Write(mPayload[210]); 
            s.Write(mPayload[211]); 
            s.Write(mPayload[212]); 
            s.Write(mPayload[213]); 
            s.Write(mPayload[214]); 
            s.Write(mPayload[215]); 
            s.Write(mPayload[216]); 
            s.Write(mPayload[217]); 
            s.Write(mPayload[218]); 
            s.Write(mPayload[219]); 
            s.Write(mPayload[220]); 
            s.Write(mPayload[221]); 
            s.Write(mPayload[222]); 
            s.Write(mPayload[223]); 
            s.Write(mPayload[224]); 
            s.Write(mPayload[225]); 
            s.Write(mPayload[226]); 
            s.Write(mPayload[227]); 
            s.Write(mPayload[228]); 
            s.Write(mPayload[229]); 
            s.Write(mPayload[230]); 
            s.Write(mPayload[231]); 
            s.Write(mPayload[232]); 
            s.Write(mPayload[233]); 
            s.Write(mPayload[234]); 
            s.Write(mPayload[235]); 
            s.Write(mPayload[236]); 
            s.Write(mPayload[237]); 
            s.Write(mPayload[238]); 
            s.Write(mPayload[239]); 
            s.Write(mPayload[240]); 
            s.Write(mPayload[241]); 
            s.Write(mPayload[242]); 
            s.Write(mPayload[243]); 
            s.Write(mPayload[244]); 
            s.Write(mPayload[245]); 
            s.Write(mPayload[246]); 
            s.Write(mPayload[247]); 
            s.Write(mPayload[248]); 
            s.Write(mPayload[249]); 
            s.Write(mPayload[250]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetNetwork = s.ReadByte();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mPayload[0] = s.ReadByte();
            this.mPayload[1] = s.ReadByte();
            this.mPayload[2] = s.ReadByte();
            this.mPayload[3] = s.ReadByte();
            this.mPayload[4] = s.ReadByte();
            this.mPayload[5] = s.ReadByte();
            this.mPayload[6] = s.ReadByte();
            this.mPayload[7] = s.ReadByte();
            this.mPayload[8] = s.ReadByte();
            this.mPayload[9] = s.ReadByte();
            this.mPayload[10] = s.ReadByte();
            this.mPayload[11] = s.ReadByte();
            this.mPayload[12] = s.ReadByte();
            this.mPayload[13] = s.ReadByte();
            this.mPayload[14] = s.ReadByte();
            this.mPayload[15] = s.ReadByte();
            this.mPayload[16] = s.ReadByte();
            this.mPayload[17] = s.ReadByte();
            this.mPayload[18] = s.ReadByte();
            this.mPayload[19] = s.ReadByte();
            this.mPayload[20] = s.ReadByte();
            this.mPayload[21] = s.ReadByte();
            this.mPayload[22] = s.ReadByte();
            this.mPayload[23] = s.ReadByte();
            this.mPayload[24] = s.ReadByte();
            this.mPayload[25] = s.ReadByte();
            this.mPayload[26] = s.ReadByte();
            this.mPayload[27] = s.ReadByte();
            this.mPayload[28] = s.ReadByte();
            this.mPayload[29] = s.ReadByte();
            this.mPayload[30] = s.ReadByte();
            this.mPayload[31] = s.ReadByte();
            this.mPayload[32] = s.ReadByte();
            this.mPayload[33] = s.ReadByte();
            this.mPayload[34] = s.ReadByte();
            this.mPayload[35] = s.ReadByte();
            this.mPayload[36] = s.ReadByte();
            this.mPayload[37] = s.ReadByte();
            this.mPayload[38] = s.ReadByte();
            this.mPayload[39] = s.ReadByte();
            this.mPayload[40] = s.ReadByte();
            this.mPayload[41] = s.ReadByte();
            this.mPayload[42] = s.ReadByte();
            this.mPayload[43] = s.ReadByte();
            this.mPayload[44] = s.ReadByte();
            this.mPayload[45] = s.ReadByte();
            this.mPayload[46] = s.ReadByte();
            this.mPayload[47] = s.ReadByte();
            this.mPayload[48] = s.ReadByte();
            this.mPayload[49] = s.ReadByte();
            this.mPayload[50] = s.ReadByte();
            this.mPayload[51] = s.ReadByte();
            this.mPayload[52] = s.ReadByte();
            this.mPayload[53] = s.ReadByte();
            this.mPayload[54] = s.ReadByte();
            this.mPayload[55] = s.ReadByte();
            this.mPayload[56] = s.ReadByte();
            this.mPayload[57] = s.ReadByte();
            this.mPayload[58] = s.ReadByte();
            this.mPayload[59] = s.ReadByte();
            this.mPayload[60] = s.ReadByte();
            this.mPayload[61] = s.ReadByte();
            this.mPayload[62] = s.ReadByte();
            this.mPayload[63] = s.ReadByte();
            this.mPayload[64] = s.ReadByte();
            this.mPayload[65] = s.ReadByte();
            this.mPayload[66] = s.ReadByte();
            this.mPayload[67] = s.ReadByte();
            this.mPayload[68] = s.ReadByte();
            this.mPayload[69] = s.ReadByte();
            this.mPayload[70] = s.ReadByte();
            this.mPayload[71] = s.ReadByte();
            this.mPayload[72] = s.ReadByte();
            this.mPayload[73] = s.ReadByte();
            this.mPayload[74] = s.ReadByte();
            this.mPayload[75] = s.ReadByte();
            this.mPayload[76] = s.ReadByte();
            this.mPayload[77] = s.ReadByte();
            this.mPayload[78] = s.ReadByte();
            this.mPayload[79] = s.ReadByte();
            this.mPayload[80] = s.ReadByte();
            this.mPayload[81] = s.ReadByte();
            this.mPayload[82] = s.ReadByte();
            this.mPayload[83] = s.ReadByte();
            this.mPayload[84] = s.ReadByte();
            this.mPayload[85] = s.ReadByte();
            this.mPayload[86] = s.ReadByte();
            this.mPayload[87] = s.ReadByte();
            this.mPayload[88] = s.ReadByte();
            this.mPayload[89] = s.ReadByte();
            this.mPayload[90] = s.ReadByte();
            this.mPayload[91] = s.ReadByte();
            this.mPayload[92] = s.ReadByte();
            this.mPayload[93] = s.ReadByte();
            this.mPayload[94] = s.ReadByte();
            this.mPayload[95] = s.ReadByte();
            this.mPayload[96] = s.ReadByte();
            this.mPayload[97] = s.ReadByte();
            this.mPayload[98] = s.ReadByte();
            this.mPayload[99] = s.ReadByte();
            this.mPayload[100] = s.ReadByte();
            this.mPayload[101] = s.ReadByte();
            this.mPayload[102] = s.ReadByte();
            this.mPayload[103] = s.ReadByte();
            this.mPayload[104] = s.ReadByte();
            this.mPayload[105] = s.ReadByte();
            this.mPayload[106] = s.ReadByte();
            this.mPayload[107] = s.ReadByte();
            this.mPayload[108] = s.ReadByte();
            this.mPayload[109] = s.ReadByte();
            this.mPayload[110] = s.ReadByte();
            this.mPayload[111] = s.ReadByte();
            this.mPayload[112] = s.ReadByte();
            this.mPayload[113] = s.ReadByte();
            this.mPayload[114] = s.ReadByte();
            this.mPayload[115] = s.ReadByte();
            this.mPayload[116] = s.ReadByte();
            this.mPayload[117] = s.ReadByte();
            this.mPayload[118] = s.ReadByte();
            this.mPayload[119] = s.ReadByte();
            this.mPayload[120] = s.ReadByte();
            this.mPayload[121] = s.ReadByte();
            this.mPayload[122] = s.ReadByte();
            this.mPayload[123] = s.ReadByte();
            this.mPayload[124] = s.ReadByte();
            this.mPayload[125] = s.ReadByte();
            this.mPayload[126] = s.ReadByte();
            this.mPayload[127] = s.ReadByte();
            this.mPayload[128] = s.ReadByte();
            this.mPayload[129] = s.ReadByte();
            this.mPayload[130] = s.ReadByte();
            this.mPayload[131] = s.ReadByte();
            this.mPayload[132] = s.ReadByte();
            this.mPayload[133] = s.ReadByte();
            this.mPayload[134] = s.ReadByte();
            this.mPayload[135] = s.ReadByte();
            this.mPayload[136] = s.ReadByte();
            this.mPayload[137] = s.ReadByte();
            this.mPayload[138] = s.ReadByte();
            this.mPayload[139] = s.ReadByte();
            this.mPayload[140] = s.ReadByte();
            this.mPayload[141] = s.ReadByte();
            this.mPayload[142] = s.ReadByte();
            this.mPayload[143] = s.ReadByte();
            this.mPayload[144] = s.ReadByte();
            this.mPayload[145] = s.ReadByte();
            this.mPayload[146] = s.ReadByte();
            this.mPayload[147] = s.ReadByte();
            this.mPayload[148] = s.ReadByte();
            this.mPayload[149] = s.ReadByte();
            this.mPayload[150] = s.ReadByte();
            this.mPayload[151] = s.ReadByte();
            this.mPayload[152] = s.ReadByte();
            this.mPayload[153] = s.ReadByte();
            this.mPayload[154] = s.ReadByte();
            this.mPayload[155] = s.ReadByte();
            this.mPayload[156] = s.ReadByte();
            this.mPayload[157] = s.ReadByte();
            this.mPayload[158] = s.ReadByte();
            this.mPayload[159] = s.ReadByte();
            this.mPayload[160] = s.ReadByte();
            this.mPayload[161] = s.ReadByte();
            this.mPayload[162] = s.ReadByte();
            this.mPayload[163] = s.ReadByte();
            this.mPayload[164] = s.ReadByte();
            this.mPayload[165] = s.ReadByte();
            this.mPayload[166] = s.ReadByte();
            this.mPayload[167] = s.ReadByte();
            this.mPayload[168] = s.ReadByte();
            this.mPayload[169] = s.ReadByte();
            this.mPayload[170] = s.ReadByte();
            this.mPayload[171] = s.ReadByte();
            this.mPayload[172] = s.ReadByte();
            this.mPayload[173] = s.ReadByte();
            this.mPayload[174] = s.ReadByte();
            this.mPayload[175] = s.ReadByte();
            this.mPayload[176] = s.ReadByte();
            this.mPayload[177] = s.ReadByte();
            this.mPayload[178] = s.ReadByte();
            this.mPayload[179] = s.ReadByte();
            this.mPayload[180] = s.ReadByte();
            this.mPayload[181] = s.ReadByte();
            this.mPayload[182] = s.ReadByte();
            this.mPayload[183] = s.ReadByte();
            this.mPayload[184] = s.ReadByte();
            this.mPayload[185] = s.ReadByte();
            this.mPayload[186] = s.ReadByte();
            this.mPayload[187] = s.ReadByte();
            this.mPayload[188] = s.ReadByte();
            this.mPayload[189] = s.ReadByte();
            this.mPayload[190] = s.ReadByte();
            this.mPayload[191] = s.ReadByte();
            this.mPayload[192] = s.ReadByte();
            this.mPayload[193] = s.ReadByte();
            this.mPayload[194] = s.ReadByte();
            this.mPayload[195] = s.ReadByte();
            this.mPayload[196] = s.ReadByte();
            this.mPayload[197] = s.ReadByte();
            this.mPayload[198] = s.ReadByte();
            this.mPayload[199] = s.ReadByte();
            this.mPayload[200] = s.ReadByte();
            this.mPayload[201] = s.ReadByte();
            this.mPayload[202] = s.ReadByte();
            this.mPayload[203] = s.ReadByte();
            this.mPayload[204] = s.ReadByte();
            this.mPayload[205] = s.ReadByte();
            this.mPayload[206] = s.ReadByte();
            this.mPayload[207] = s.ReadByte();
            this.mPayload[208] = s.ReadByte();
            this.mPayload[209] = s.ReadByte();
            this.mPayload[210] = s.ReadByte();
            this.mPayload[211] = s.ReadByte();
            this.mPayload[212] = s.ReadByte();
            this.mPayload[213] = s.ReadByte();
            this.mPayload[214] = s.ReadByte();
            this.mPayload[215] = s.ReadByte();
            this.mPayload[216] = s.ReadByte();
            this.mPayload[217] = s.ReadByte();
            this.mPayload[218] = s.ReadByte();
            this.mPayload[219] = s.ReadByte();
            this.mPayload[220] = s.ReadByte();
            this.mPayload[221] = s.ReadByte();
            this.mPayload[222] = s.ReadByte();
            this.mPayload[223] = s.ReadByte();
            this.mPayload[224] = s.ReadByte();
            this.mPayload[225] = s.ReadByte();
            this.mPayload[226] = s.ReadByte();
            this.mPayload[227] = s.ReadByte();
            this.mPayload[228] = s.ReadByte();
            this.mPayload[229] = s.ReadByte();
            this.mPayload[230] = s.ReadByte();
            this.mPayload[231] = s.ReadByte();
            this.mPayload[232] = s.ReadByte();
            this.mPayload[233] = s.ReadByte();
            this.mPayload[234] = s.ReadByte();
            this.mPayload[235] = s.ReadByte();
            this.mPayload[236] = s.ReadByte();
            this.mPayload[237] = s.ReadByte();
            this.mPayload[238] = s.ReadByte();
            this.mPayload[239] = s.ReadByte();
            this.mPayload[240] = s.ReadByte();
            this.mPayload[241] = s.ReadByte();
            this.mPayload[242] = s.ReadByte();
            this.mPayload[243] = s.ReadByte();
            this.mPayload[244] = s.ReadByte();
            this.mPayload[245] = s.ReadByte();
            this.mPayload[246] = s.ReadByte();
            this.mPayload[247] = s.ReadByte();
            this.mPayload[248] = s.ReadByte();
            this.mPayload[249] = s.ReadByte();
            this.mPayload[250] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "File transfer message"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetNetwork",
                Description = "Network ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Payload",
                Description = "Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.",
                NumElements = 251,
            });

        }

        private byte mTargetNetwork;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte[] mPayload = new byte[251];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Time synchronization message.
    /// </summary>
    public class UasTimesync: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 16; }
        }
        /// <summary>
        /// Time sync timestamp 1
        /// </summary>
        public Int64 Tc1 {
            get { return mTc1; }
            set { mTc1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Time sync timestamp 2
        /// </summary>
        public Int64 Ts1 {
            get { return mTs1; }
            set { mTs1 = value; NotifyUpdated(); }
        }

        public UasTimesync()
        {
            mMessageId = 111;
            CrcExtra = 34;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTc1);
            s.Write(mTs1);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTc1 = s.ReadInt64();
            this.mTs1 = s.ReadInt64();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Time synchronization message."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Tc1",
                Description = "Time sync timestamp 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ts1",
                Description = "Time sync timestamp 2",
                NumElements = 1,
            });

        }

        private Int64 mTc1;
        private Int64 mTs1;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Camera-IMU triggering and synchronisation message.
    /// </summary>
    public class UasCameraTrigger: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 12; }
        }
        /// <summary>
        /// Timestamp for image frame (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Image frame sequence
        /// </summary>
        public UInt32 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        public UasCameraTrigger()
        {
            mMessageId = 112;
            CrcExtra = 174;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mSeq);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mSeq = s.ReadUInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Camera-IMU triggering and synchronisation message."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp for image frame (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Image frame sequence",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mSeq;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The global position, as returned by the Global Positioning System (GPS). This is                  NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION_INT for the global position estimate.
    /// </summary>
    public class UasHilGps: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 38; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Positive for up.
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Eph {
            get { return mEph; }
            set { mEph = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Epv {
            get { return mEpv; }
            set { mEpv = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS ground speed. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Vel {
            get { return mVel; }
            set { mVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in north direction in earth-fixed NED frame
        /// </summary>
        public Int16 Vn {
            get { return mVn; }
            set { mVn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in east direction in earth-fixed NED frame
        /// </summary>
        public Int16 Ve {
            get { return mVe; }
            set { mVe = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in down direction in earth-fixed NED frame
        /// </summary>
        public Int16 Vd {
            get { return mVd; }
            set { mVd = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Course over ground (NOT heading, but direction of movement), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Cog {
            get { return mCog; }
            set { mCog = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
        /// </summary>
        public byte FixType {
            get { return mFixType; }
            set { mFixType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of satellites visible. If unknown, set to UINT8_MAX
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        public UasHilGps()
        {
            mMessageId = 113;
            CrcExtra = 124;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mEph);
            s.Write(mEpv);
            s.Write(mVel);
            s.Write(mVn);
            s.Write(mVe);
            s.Write(mVd);
            s.Write(mCog);
            s.Write(mFixType);
            s.Write(mSatellitesVisible);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mEph = s.ReadUInt16();
            this.mEpv = s.ReadUInt16();
            this.mVel = s.ReadUInt16();
            this.mVn = s.ReadInt16();
            this.mVe = s.ReadInt16();
            this.mVd = s.ReadInt16();
            this.mCog = s.ReadUInt16();
            this.mFixType = s.ReadByte();
            this.mSatellitesVisible = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The global position, as returned by the Global Positioning System (GPS). This is                  NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION_INT for the global position estimate."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (MSL). Positive for up.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Eph",
                Description = "GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Epv",
                Description = "GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vel",
                Description = "GPS ground speed. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vn",
                Description = "GPS velocity in north direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ve",
                Description = "GPS velocity in east direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vd",
                Description = "GPS velocity in down direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Cog",
                Description = "Course over ground (NOT heading, but direction of movement), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FixType",
                Description = "0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible. If unknown, set to UINT8_MAX",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private UInt16 mEph;
        private UInt16 mEpv;
        private UInt16 mVel;
        private Int16 mVn;
        private Int16 mVe;
        private Int16 mVd;
        private UInt16 mCog;
        private byte mFixType;
        private byte mSatellitesVisible;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor)
    /// </summary>
    public class UasHilOpticalFlow: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 46; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
        /// </summary>
        public UInt32 IntegrationTimeUs {
            get { return mIntegrationTimeUs; }
            set { mIntegrationTimeUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
        /// </summary>
        public float IntegratedX {
            get { return mIntegratedX; }
            set { mIntegratedX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
        /// </summary>
        public float IntegratedY {
            get { return mIntegratedY; }
            set { mIntegratedY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around X axis
        /// </summary>
        public float IntegratedXgyro {
            get { return mIntegratedXgyro; }
            set { mIntegratedXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around Y axis
        /// </summary>
        public float IntegratedYgyro {
            get { return mIntegratedYgyro; }
            set { mIntegratedYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around Z axis
        /// </summary>
        public float IntegratedZgyro {
            get { return mIntegratedZgyro; }
            set { mIntegratedZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Time since the distance was sampled.
        /// </summary>
        public UInt32 TimeDeltaDistanceUs {
            get { return mTimeDeltaDistanceUs; }
            set { mTimeDeltaDistanceUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance.
        /// </summary>
        public float Distance {
            get { return mDistance; }
            set { mDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Sensor ID
        /// </summary>
        public byte SensorId {
            get { return mSensorId; }
            set { mSensorId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
        /// </summary>
        public byte Quality {
            get { return mQuality; }
            set { mQuality = value; NotifyUpdated(); }
        }

        public UasHilOpticalFlow()
        {
            mMessageId = 114;
            CrcExtra = 237;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mIntegrationTimeUs);
            s.Write(mIntegratedX);
            s.Write(mIntegratedY);
            s.Write(mIntegratedXgyro);
            s.Write(mIntegratedYgyro);
            s.Write(mIntegratedZgyro);
            s.Write(mTimeDeltaDistanceUs);
            s.Write(mDistance);
            s.Write(mTemperature);
            s.Write(mSensorId);
            s.Write(mQuality);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mIntegrationTimeUs = s.ReadUInt32();
            this.mIntegratedX = s.ReadSingle();
            this.mIntegratedY = s.ReadSingle();
            this.mIntegratedXgyro = s.ReadSingle();
            this.mIntegratedYgyro = s.ReadSingle();
            this.mIntegratedZgyro = s.ReadSingle();
            this.mTimeDeltaDistanceUs = s.ReadUInt32();
            this.mDistance = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
            this.mSensorId = s.ReadByte();
            this.mQuality = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegrationTimeUs",
                Description = "Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedX",
                Description = "Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedY",
                Description = "Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedXgyro",
                Description = "RH rotation around X axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedYgyro",
                Description = "RH rotation around Y axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedZgyro",
                Description = "RH rotation around Z axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeDeltaDistanceUs",
                Description = "Time since the distance was sampled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Distance",
                Description = "Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SensorId",
                Description = "Sensor ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Quality",
                Description = "Optical flow quality / confidence. 0: no valid flow, 255: maximum quality",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mIntegrationTimeUs;
        private float mIntegratedX;
        private float mIntegratedY;
        private float mIntegratedXgyro;
        private float mIntegratedYgyro;
        private float mIntegratedZgyro;
        private UInt32 mTimeDeltaDistanceUs;
        private float mDistance;
        private Int16 mTemperature;
        private byte mSensorId;
        private byte mQuality;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations.
    /// </summary>
    public class UasHilStateQuaternion: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 64; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
        /// </summary>
        public float[] AttitudeQuaternion {
            get { return mAttitudeQuaternion; }
            set { mAttitudeQuaternion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame roll / phi angular speed
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame pitch / theta angular speed
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame yaw / psi angular speed
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground X Speed (Latitude)
        /// </summary>
        public Int16 Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Y Speed (Longitude)
        /// </summary>
        public Int16 Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Z Speed (Altitude)
        /// </summary>
        public Int16 Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Indicated airspeed
        /// </summary>
        public UInt16 IndAirspeed {
            get { return mIndAirspeed; }
            set { mIndAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True airspeed
        /// </summary>
        public UInt16 TrueAirspeed {
            get { return mTrueAirspeed; }
            set { mTrueAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        public UasHilStateQuaternion()
        {
            mMessageId = 115;
            CrcExtra = 4;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mAttitudeQuaternion[0]); 
            s.Write(mAttitudeQuaternion[1]); 
            s.Write(mAttitudeQuaternion[2]); 
            s.Write(mAttitudeQuaternion[3]); 
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mIndAirspeed);
            s.Write(mTrueAirspeed);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mAttitudeQuaternion[0] = s.ReadSingle();
            this.mAttitudeQuaternion[1] = s.ReadSingle();
            this.mAttitudeQuaternion[2] = s.ReadSingle();
            this.mAttitudeQuaternion[3] = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mVx = s.ReadInt16();
            this.mVy = s.ReadInt16();
            this.mVz = s.ReadInt16();
            this.mIndAirspeed = s.ReadUInt16();
            this.mTrueAirspeed = s.ReadUInt16();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AttitudeQuaternion",
                Description = "Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Body frame roll / phi angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Body frame pitch / theta angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Body frame yaw / psi angular speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "Ground X Speed (Latitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Ground Y Speed (Longitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Ground Z Speed (Altitude)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IndAirspeed",
                Description = "Indicated airspeed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TrueAirspeed",
                Description = "True airspeed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mAttitudeQuaternion = new float[4];
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private Int16 mVx;
        private Int16 mVy;
        private Int16 mVz;
        private UInt16 mIndAirspeed;
        private UInt16 mTrueAirspeed;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units
    /// </summary>
    public class UasScaledImu2: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 22; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis
        /// </summary>
        public Int16 Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis
        /// </summary>
        public Int16 Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis
        /// </summary>
        public Int16 Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field
        /// </summary>
        public Int16 Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field
        /// </summary>
        public Int16 Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field
        /// </summary>
        public Int16 Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        public UasScaledImu2()
        {
            mMessageId = 116;
            CrcExtra = 76;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
            this.mXgyro = s.ReadInt16();
            this.mYgyro = s.ReadInt16();
            this.mZgyro = s.ReadInt16();
            this.mXmag = s.ReadInt16();
            this.mYmag = s.ReadInt16();
            this.mZmag = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
        private Int16 mXgyro;
        private Int16 mYgyro;
        private Int16 mZgyro;
        private Int16 mXmag;
        private Int16 mYmag;
        private Int16 mZmag;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called. If there are no log files available this request shall be answered with one LOG_ENTRY message with id = 0 and num_logs = 0.
    /// </summary>
    public class UasLogRequestList: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 8; }
        }
        /// <summary>
        /// First log id (0 for first available)
        /// </summary>
        public UInt16 Start {
            get { return mStart; }
            set { mStart = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Last log id (0xffff for last available)
        /// </summary>
        public UInt16 End {
            get { return mEnd; }
            set { mEnd = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasLogRequestList()
        {
            mMessageId = 117;
            CrcExtra = 128;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mStart);
            s.Write(mEnd);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mStart = s.ReadUInt16();
            this.mEnd = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called. If there are no log files available this request shall be answered with one LOG_ENTRY message with id = 0 and num_logs = 0."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Start",
                Description = "First log id (0 for first available)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "End",
                Description = "Last log id (0xffff for last available)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mStart;
        private UInt16 mEnd;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reply to LOG_REQUEST_LIST
    /// </summary>
    public class UasLogEntry: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 14; }
        }
        /// <summary>
        /// UTC timestamp of log since 1970, or 0 if not available
        /// </summary>
        public UInt32 TimeUtc {
            get { return mTimeUtc; }
            set { mTimeUtc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Size of the log (may be approximate)
        /// </summary>
        public UInt32 Size {
            get { return mSize; }
            set { mSize = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Log id
        /// </summary>
        public UInt16 Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Total number of logs
        /// </summary>
        public UInt16 NumLogs {
            get { return mNumLogs; }
            set { mNumLogs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// High log number
        /// </summary>
        public UInt16 LastLogNum {
            get { return mLastLogNum; }
            set { mLastLogNum = value; NotifyUpdated(); }
        }

        public UasLogEntry()
        {
            mMessageId = 118;
            CrcExtra = 56;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUtc);
            s.Write(mSize);
            s.Write(mId);
            s.Write(mNumLogs);
            s.Write(mLastLogNum);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUtc = s.ReadUInt32();
            this.mSize = s.ReadUInt32();
            this.mId = s.ReadUInt16();
            this.mNumLogs = s.ReadUInt16();
            this.mLastLogNum = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reply to LOG_REQUEST_LIST"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUtc",
                Description = "UTC timestamp of log since 1970, or 0 if not available",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Size",
                Description = "Size of the log (may be approximate)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Log id",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NumLogs",
                Description = "Total number of logs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LastLogNum",
                Description = "High log number",
                NumElements = 1,
            });

        }

        private UInt32 mTimeUtc;
        private UInt32 mSize;
        private UInt16 mId;
        private UInt16 mNumLogs;
        private UInt16 mLastLogNum;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a chunk of a log
    /// </summary>
    public class UasLogRequestData: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 14; }
        }
        /// <summary>
        /// Offset into the log
        /// </summary>
        public UInt32 Ofs {
            get { return mOfs; }
            set { mOfs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of bytes
        /// </summary>
        public UInt32 Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Log id (from LOG_ENTRY reply)
        /// </summary>
        public UInt16 Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasLogRequestData()
        {
            mMessageId = 119;
            CrcExtra = 116;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mOfs);
            s.Write(mCount);
            s.Write(mId);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mOfs = s.ReadUInt32();
            this.mCount = s.ReadUInt32();
            this.mId = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a chunk of a log"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ofs",
                Description = "Offset into the log",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "Number of bytes",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Log id (from LOG_ENTRY reply)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt32 mOfs;
        private UInt32 mCount;
        private UInt16 mId;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reply to LOG_REQUEST_DATA
    /// </summary>
    public class UasLogData: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 188; }
        }
        /// <summary>
        /// Offset into the log
        /// </summary>
        public UInt32 Ofs {
            get { return mOfs; }
            set { mOfs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Log id (from LOG_ENTRY reply)
        /// </summary>
        public UInt16 Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of bytes (zero for end of log)
        /// </summary>
        public byte Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// log data
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasLogData()
        {
            mMessageId = 120;
            CrcExtra = 134;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mOfs);
            s.Write(mId);
            s.Write(mCount);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mOfs = s.ReadUInt32();
            this.mId = s.ReadUInt16();
            this.mCount = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reply to LOG_REQUEST_DATA"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ofs",
                Description = "Offset into the log",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Log id (from LOG_ENTRY reply)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "Number of bytes (zero for end of log)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "log data",
                NumElements = 90,
            });

        }

        private UInt32 mOfs;
        private UInt16 mId;
        private byte mCount;
        private byte[] mData = new byte[90];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Erase all logs
    /// </summary>
    public class UasLogErase: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 4; }
        }
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasLogErase()
        {
            mMessageId = 121;
            CrcExtra = 237;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Erase all logs"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Stop log transfer and resume normal logging
    /// </summary>
    public class UasLogRequestEnd: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 4; }
        }
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasLogRequestEnd()
        {
            mMessageId = 122;
            CrcExtra = 203;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Stop log transfer and resume normal logging"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Data for injecting into the onboard GPS (used for DGPS)
    /// </summary>
    public class UasGpsInjectData: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 226; }
        }
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Data length
        /// </summary>
        public byte Len {
            get { return mLen; }
            set { mLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Raw data (110 is enough for 12 satellites of RTCMv2)
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasGpsInjectData()
        {
            mMessageId = 123;
            CrcExtra = 250;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mLen);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
            s.Write(mData[90]); 
            s.Write(mData[91]); 
            s.Write(mData[92]); 
            s.Write(mData[93]); 
            s.Write(mData[94]); 
            s.Write(mData[95]); 
            s.Write(mData[96]); 
            s.Write(mData[97]); 
            s.Write(mData[98]); 
            s.Write(mData[99]); 
            s.Write(mData[100]); 
            s.Write(mData[101]); 
            s.Write(mData[102]); 
            s.Write(mData[103]); 
            s.Write(mData[104]); 
            s.Write(mData[105]); 
            s.Write(mData[106]); 
            s.Write(mData[107]); 
            s.Write(mData[108]); 
            s.Write(mData[109]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mLen = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
            this.mData[90] = s.ReadByte();
            this.mData[91] = s.ReadByte();
            this.mData[92] = s.ReadByte();
            this.mData[93] = s.ReadByte();
            this.mData[94] = s.ReadByte();
            this.mData[95] = s.ReadByte();
            this.mData[96] = s.ReadByte();
            this.mData[97] = s.ReadByte();
            this.mData[98] = s.ReadByte();
            this.mData[99] = s.ReadByte();
            this.mData[100] = s.ReadByte();
            this.mData[101] = s.ReadByte();
            this.mData[102] = s.ReadByte();
            this.mData[103] = s.ReadByte();
            this.mData[104] = s.ReadByte();
            this.mData[105] = s.ReadByte();
            this.mData[106] = s.ReadByte();
            this.mData[107] = s.ReadByte();
            this.mData[108] = s.ReadByte();
            this.mData[109] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Data for injecting into the onboard GPS (used for DGPS)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Len",
                Description = "Data length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "Raw data (110 is enough for 12 satellites of RTCMv2)",
                NumElements = 110,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mLen;
        private byte[] mData = new byte[110];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Second GPS data.
    /// </summary>
    public class UasGps2Raw: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 38; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Positive for up.
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Age of DGPS info
        /// </summary>
        public UInt32 DgpsAge {
            get { return mDgpsAge; }
            set { mDgpsAge = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Eph {
            get { return mEph; }
            set { mEph = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Epv {
            get { return mEpv; }
            set { mEpv = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS ground speed. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Vel {
            get { return mVel; }
            set { mVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Course over ground (NOT heading, but direction of movement): 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Cog {
            get { return mCog; }
            set { mCog = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS fix type.
        /// </summary>
        public GpsFixType FixType {
            get { return mFixType; }
            set { mFixType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of satellites visible. If unknown, set to UINT8_MAX
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of DGPS satellites
        /// </summary>
        public byte DgpsNumch {
            get { return mDgpsNumch; }
            set { mDgpsNumch = value; NotifyUpdated(); }
        }

        public UasGps2Raw()
        {
            mMessageId = 124;
            CrcExtra = 87;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mDgpsAge);
            s.Write(mEph);
            s.Write(mEpv);
            s.Write(mVel);
            s.Write(mCog);
            s.Write((byte)mFixType);
            s.Write(mSatellitesVisible);
            s.Write(mDgpsNumch);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mDgpsAge = s.ReadUInt32();
            this.mEph = s.ReadUInt16();
            this.mEpv = s.ReadUInt16();
            this.mVel = s.ReadUInt16();
            this.mCog = s.ReadUInt16();
            this.mFixType = (GpsFixType)s.ReadByte();
            this.mSatellitesVisible = s.ReadByte();
            this.mDgpsNumch = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Second GPS data."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (MSL). Positive for up.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DgpsAge",
                Description = "Age of DGPS info",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Eph",
                Description = "GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Epv",
                Description = "GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vel",
                Description = "GPS ground speed. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Cog",
                Description = "Course over ground (NOT heading, but direction of movement): 0.0..359.99 degrees. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FixType",
                Description = "GPS fix type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("GpsFixType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible. If unknown, set to UINT8_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DgpsNumch",
                Description = "Number of DGPS satellites",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private UInt32 mDgpsAge;
        private UInt16 mEph;
        private UInt16 mEpv;
        private UInt16 mVel;
        private UInt16 mCog;
        private GpsFixType mFixType;
        private byte mSatellitesVisible;
        private byte mDgpsNumch;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Power supply status
    /// </summary>
    public class UasPowerStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// 5V rail voltage.
        /// </summary>
        public UInt16 Vcc {
            get { return mVcc; }
            set { mVcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo rail voltage.
        /// </summary>
        public UInt16 Vservo {
            get { return mVservo; }
            set { mVservo = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap of power supply status flags.
        /// </summary>
        public MavPowerStatus Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        public UasPowerStatus()
        {
            mMessageId = 125;
            CrcExtra = 203;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mVcc);
            s.Write(mVservo);
            s.Write((UInt16)mFlags);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mVcc = s.ReadUInt16();
            this.mVservo = s.ReadUInt16();
            this.mFlags = (MavPowerStatus)s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Power supply status"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vcc",
                Description = "5V rail voltage.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vservo",
                Description = "Servo rail voltage.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "Bitmap of power supply status flags.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavPowerStatus"),
            });

        }

        private UInt16 mVcc;
        private UInt16 mVservo;
        private MavPowerStatus mFlags;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate.
    /// </summary>
    public class UasSerialControl: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 152; }
        }
        /// <summary>
        /// Baudrate of transfer. Zero means no change.
        /// </summary>
        public UInt32 Baudrate {
            get { return mBaudrate; }
            set { mBaudrate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Timeout for reply data
        /// </summary>
        public UInt16 Timeout {
            get { return mTimeout; }
            set { mTimeout = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Serial control device type.
        /// </summary>
        public SerialControlDev Device {
            get { return mDevice; }
            set { mDevice = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap of serial control flags.
        /// </summary>
        public SerialControlFlag Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// how many bytes in this transfer
        /// </summary>
        public byte Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// serial data
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasSerialControl()
        {
            mMessageId = 126;
            CrcExtra = 220;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mBaudrate);
            s.Write(mTimeout);
            s.Write((byte)mDevice);
            s.Write((byte)mFlags);
            s.Write(mCount);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mBaudrate = s.ReadUInt32();
            this.mTimeout = s.ReadUInt16();
            this.mDevice = (SerialControlDev)s.ReadByte();
            this.mFlags = (SerialControlFlag)s.ReadByte();
            this.mCount = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Baudrate",
                Description = "Baudrate of transfer. Zero means no change.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Timeout",
                Description = "Timeout for reply data",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Device",
                Description = "Serial control device type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("SerialControlDev"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "Bitmap of serial control flags.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("SerialControlFlag"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "how many bytes in this transfer",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "serial data",
                NumElements = 70,
            });

        }

        private UInt32 mBaudrate;
        private UInt16 mTimeout;
        private SerialControlDev mDevice;
        private SerialControlFlag mFlags;
        private byte mCount;
        private byte[] mData = new byte[70];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
    /// </summary>
    public class UasGpsRtk: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 40; }
        }
        /// <summary>
        /// Time since boot of last baseline message received.
        /// </summary>
        public UInt32 TimeLastBaselineMs {
            get { return mTimeLastBaselineMs; }
            set { mTimeLastBaselineMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Time of Week of last baseline
        /// </summary>
        public UInt32 Tow {
            get { return mTow; }
            set { mTow = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF x or NED north component.
        /// </summary>
        public Int32 BaselineAMm {
            get { return mBaselineAMm; }
            set { mBaselineAMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF y or NED east component.
        /// </summary>
        public Int32 BaselineBMm {
            get { return mBaselineBMm; }
            set { mBaselineBMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF z or NED down component.
        /// </summary>
        public Int32 BaselineCMm {
            get { return mBaselineCMm; }
            set { mBaselineCMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current estimate of baseline accuracy.
        /// </summary>
        public UInt32 Accuracy {
            get { return mAccuracy; }
            set { mAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current number of integer ambiguity hypotheses.
        /// </summary>
        public Int32 IarNumHypotheses {
            get { return mIarNumHypotheses; }
            set { mIarNumHypotheses = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Week Number of last baseline
        /// </summary>
        public UInt16 Wn {
            get { return mWn; }
            set { mWn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Identification of connected RTK receiver.
        /// </summary>
        public byte RtkReceiverId {
            get { return mRtkReceiverId; }
            set { mRtkReceiverId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS-specific health report for RTK data.
        /// </summary>
        public byte RtkHealth {
            get { return mRtkHealth; }
            set { mRtkHealth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Rate of baseline messages being received by GPS
        /// </summary>
        public byte RtkRate {
            get { return mRtkRate; }
            set { mRtkRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current number of sats used for RTK calculation.
        /// </summary>
        public byte Nsats {
            get { return mNsats; }
            set { mNsats = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate system of baseline
        /// </summary>
        public RtkBaselineCoordinateSystem BaselineCoordsType {
            get { return mBaselineCoordsType; }
            set { mBaselineCoordsType = value; NotifyUpdated(); }
        }

        public UasGpsRtk()
        {
            mMessageId = 127;
            CrcExtra = 25;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeLastBaselineMs);
            s.Write(mTow);
            s.Write(mBaselineAMm);
            s.Write(mBaselineBMm);
            s.Write(mBaselineCMm);
            s.Write(mAccuracy);
            s.Write(mIarNumHypotheses);
            s.Write(mWn);
            s.Write(mRtkReceiverId);
            s.Write(mRtkHealth);
            s.Write(mRtkRate);
            s.Write(mNsats);
            s.Write((byte)mBaselineCoordsType);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeLastBaselineMs = s.ReadUInt32();
            this.mTow = s.ReadUInt32();
            this.mBaselineAMm = s.ReadInt32();
            this.mBaselineBMm = s.ReadInt32();
            this.mBaselineCMm = s.ReadInt32();
            this.mAccuracy = s.ReadUInt32();
            this.mIarNumHypotheses = s.ReadInt32();
            this.mWn = s.ReadUInt16();
            this.mRtkReceiverId = s.ReadByte();
            this.mRtkHealth = s.ReadByte();
            this.mRtkRate = s.ReadByte();
            this.mNsats = s.ReadByte();
            this.mBaselineCoordsType = (RtkBaselineCoordinateSystem)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeLastBaselineMs",
                Description = "Time since boot of last baseline message received.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Tow",
                Description = "GPS Time of Week of last baseline",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineAMm",
                Description = "Current baseline in ECEF x or NED north component.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineBMm",
                Description = "Current baseline in ECEF y or NED east component.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineCMm",
                Description = "Current baseline in ECEF z or NED down component.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Accuracy",
                Description = "Current estimate of baseline accuracy.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IarNumHypotheses",
                Description = "Current number of integer ambiguity hypotheses.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Wn",
                Description = "GPS Week Number of last baseline",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkReceiverId",
                Description = "Identification of connected RTK receiver.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkHealth",
                Description = "GPS-specific health report for RTK data.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkRate",
                Description = "Rate of baseline messages being received by GPS",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Nsats",
                Description = "Current number of sats used for RTK calculation.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineCoordsType",
                Description = "Coordinate system of baseline",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("RtkBaselineCoordinateSystem"),
            });

        }

        private UInt32 mTimeLastBaselineMs;
        private UInt32 mTow;
        private Int32 mBaselineAMm;
        private Int32 mBaselineBMm;
        private Int32 mBaselineCMm;
        private UInt32 mAccuracy;
        private Int32 mIarNumHypotheses;
        private UInt16 mWn;
        private byte mRtkReceiverId;
        private byte mRtkHealth;
        private byte mRtkRate;
        private byte mNsats;
        private RtkBaselineCoordinateSystem mBaselineCoordsType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
    /// </summary>
    public class UasGps2Rtk: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 40; }
        }
        /// <summary>
        /// Time since boot of last baseline message received.
        /// </summary>
        public UInt32 TimeLastBaselineMs {
            get { return mTimeLastBaselineMs; }
            set { mTimeLastBaselineMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Time of Week of last baseline
        /// </summary>
        public UInt32 Tow {
            get { return mTow; }
            set { mTow = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF x or NED north component.
        /// </summary>
        public Int32 BaselineAMm {
            get { return mBaselineAMm; }
            set { mBaselineAMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF y or NED east component.
        /// </summary>
        public Int32 BaselineBMm {
            get { return mBaselineBMm; }
            set { mBaselineBMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF z or NED down component.
        /// </summary>
        public Int32 BaselineCMm {
            get { return mBaselineCMm; }
            set { mBaselineCMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current estimate of baseline accuracy.
        /// </summary>
        public UInt32 Accuracy {
            get { return mAccuracy; }
            set { mAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current number of integer ambiguity hypotheses.
        /// </summary>
        public Int32 IarNumHypotheses {
            get { return mIarNumHypotheses; }
            set { mIarNumHypotheses = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Week Number of last baseline
        /// </summary>
        public UInt16 Wn {
            get { return mWn; }
            set { mWn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Identification of connected RTK receiver.
        /// </summary>
        public byte RtkReceiverId {
            get { return mRtkReceiverId; }
            set { mRtkReceiverId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS-specific health report for RTK data.
        /// </summary>
        public byte RtkHealth {
            get { return mRtkHealth; }
            set { mRtkHealth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Rate of baseline messages being received by GPS
        /// </summary>
        public byte RtkRate {
            get { return mRtkRate; }
            set { mRtkRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current number of sats used for RTK calculation.
        /// </summary>
        public byte Nsats {
            get { return mNsats; }
            set { mNsats = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate system of baseline
        /// </summary>
        public RtkBaselineCoordinateSystem BaselineCoordsType {
            get { return mBaselineCoordsType; }
            set { mBaselineCoordsType = value; NotifyUpdated(); }
        }

        public UasGps2Rtk()
        {
            mMessageId = 128;
            CrcExtra = 226;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeLastBaselineMs);
            s.Write(mTow);
            s.Write(mBaselineAMm);
            s.Write(mBaselineBMm);
            s.Write(mBaselineCMm);
            s.Write(mAccuracy);
            s.Write(mIarNumHypotheses);
            s.Write(mWn);
            s.Write(mRtkReceiverId);
            s.Write(mRtkHealth);
            s.Write(mRtkRate);
            s.Write(mNsats);
            s.Write((byte)mBaselineCoordsType);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeLastBaselineMs = s.ReadUInt32();
            this.mTow = s.ReadUInt32();
            this.mBaselineAMm = s.ReadInt32();
            this.mBaselineBMm = s.ReadInt32();
            this.mBaselineCMm = s.ReadInt32();
            this.mAccuracy = s.ReadUInt32();
            this.mIarNumHypotheses = s.ReadInt32();
            this.mWn = s.ReadUInt16();
            this.mRtkReceiverId = s.ReadByte();
            this.mRtkHealth = s.ReadByte();
            this.mRtkRate = s.ReadByte();
            this.mNsats = s.ReadByte();
            this.mBaselineCoordsType = (RtkBaselineCoordinateSystem)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeLastBaselineMs",
                Description = "Time since boot of last baseline message received.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Tow",
                Description = "GPS Time of Week of last baseline",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineAMm",
                Description = "Current baseline in ECEF x or NED north component.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineBMm",
                Description = "Current baseline in ECEF y or NED east component.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineCMm",
                Description = "Current baseline in ECEF z or NED down component.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Accuracy",
                Description = "Current estimate of baseline accuracy.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IarNumHypotheses",
                Description = "Current number of integer ambiguity hypotheses.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Wn",
                Description = "GPS Week Number of last baseline",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkReceiverId",
                Description = "Identification of connected RTK receiver.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkHealth",
                Description = "GPS-specific health report for RTK data.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkRate",
                Description = "Rate of baseline messages being received by GPS",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Nsats",
                Description = "Current number of sats used for RTK calculation.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineCoordsType",
                Description = "Coordinate system of baseline",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("RtkBaselineCoordinateSystem"),
            });

        }

        private UInt32 mTimeLastBaselineMs;
        private UInt32 mTow;
        private Int32 mBaselineAMm;
        private Int32 mBaselineBMm;
        private Int32 mBaselineCMm;
        private UInt32 mAccuracy;
        private Int32 mIarNumHypotheses;
        private UInt16 mWn;
        private byte mRtkReceiverId;
        private byte mRtkHealth;
        private byte mRtkRate;
        private byte mNsats;
        private RtkBaselineCoordinateSystem mBaselineCoordsType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described units
    /// </summary>
    public class UasScaledImu3: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 22; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis
        /// </summary>
        public Int16 Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis
        /// </summary>
        public Int16 Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis
        /// </summary>
        public Int16 Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field
        /// </summary>
        public Int16 Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field
        /// </summary>
        public Int16 Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field
        /// </summary>
        public Int16 Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        public UasScaledImu3()
        {
            mMessageId = 129;
            CrcExtra = 46;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
            this.mXgyro = s.ReadInt16();
            this.mYgyro = s.ReadInt16();
            this.mZgyro = s.ReadInt16();
            this.mXmag = s.ReadInt16();
            this.mYmag = s.ReadInt16();
            this.mZmag = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described units"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
        private Int16 mXgyro;
        private Int16 mYgyro;
        private Int16 mZgyro;
        private Int16 mXmag;
        private Int16 mYmag;
        private Int16 mZmag;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Handshake message to initiate, control and stop image streaming when using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html.
    /// </summary>
    public class UasDataTransmissionHandshake: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 16; }
        }
        /// <summary>
        /// total data size (set on ACK only).
        /// </summary>
        public UInt32 Size {
            get { return mSize; }
            set { mSize = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Width of a matrix or image.
        /// </summary>
        public UInt16 Width {
            get { return mWidth; }
            set { mWidth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Height of a matrix or image.
        /// </summary>
        public UInt16 Height {
            get { return mHeight; }
            set { mHeight = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of packets being sent (set on ACK only).
        /// </summary>
        public UInt16 Packets {
            get { return mPackets; }
            set { mPackets = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type of requested/acknowledged data.
        /// </summary>
        public MavlinkDataStreamType Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only).
        /// </summary>
        public byte Payload {
            get { return mPayload; }
            set { mPayload = value; NotifyUpdated(); }
        }

        /// <summary>
        /// JPEG quality. Values: [1-100].
        /// </summary>
        public byte JpgQuality {
            get { return mJpgQuality; }
            set { mJpgQuality = value; NotifyUpdated(); }
        }

        public UasDataTransmissionHandshake()
        {
            mMessageId = 130;
            CrcExtra = 29;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mSize);
            s.Write(mWidth);
            s.Write(mHeight);
            s.Write(mPackets);
            s.Write((byte)mType);
            s.Write(mPayload);
            s.Write(mJpgQuality);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSize = s.ReadUInt32();
            this.mWidth = s.ReadUInt16();
            this.mHeight = s.ReadUInt16();
            this.mPackets = s.ReadUInt16();
            this.mType = (MavlinkDataStreamType)s.ReadByte();
            this.mPayload = s.ReadByte();
            this.mJpgQuality = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Handshake message to initiate, control and stop image streaming when using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Size",
                Description = "total data size (set on ACK only).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Width",
                Description = "Width of a matrix or image.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Height",
                Description = "Height of a matrix or image.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Packets",
                Description = "Number of packets being sent (set on ACK only).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type of requested/acknowledged data.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavlinkDataStreamType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Payload",
                Description = "Payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "JpgQuality",
                Description = "JPEG quality. Values: [1-100].",
                NumElements = 1,
            });

        }

        private UInt32 mSize;
        private UInt16 mWidth;
        private UInt16 mHeight;
        private UInt16 mPackets;
        private MavlinkDataStreamType mType;
        private byte mPayload;
        private byte mJpgQuality;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Data packet for images sent using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html.
    /// </summary>
    public class UasEncapsulatedData: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 508; }
        }
        /// <summary>
        /// sequence number (starting with 0 on every transmission)
        /// </summary>
        public UInt16 Seqnr {
            get { return mSeqnr; }
            set { mSeqnr = value; NotifyUpdated(); }
        }

        /// <summary>
        /// image data bytes
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasEncapsulatedData()
        {
            mMessageId = 131;
            CrcExtra = 223;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mSeqnr);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
            s.Write(mData[90]); 
            s.Write(mData[91]); 
            s.Write(mData[92]); 
            s.Write(mData[93]); 
            s.Write(mData[94]); 
            s.Write(mData[95]); 
            s.Write(mData[96]); 
            s.Write(mData[97]); 
            s.Write(mData[98]); 
            s.Write(mData[99]); 
            s.Write(mData[100]); 
            s.Write(mData[101]); 
            s.Write(mData[102]); 
            s.Write(mData[103]); 
            s.Write(mData[104]); 
            s.Write(mData[105]); 
            s.Write(mData[106]); 
            s.Write(mData[107]); 
            s.Write(mData[108]); 
            s.Write(mData[109]); 
            s.Write(mData[110]); 
            s.Write(mData[111]); 
            s.Write(mData[112]); 
            s.Write(mData[113]); 
            s.Write(mData[114]); 
            s.Write(mData[115]); 
            s.Write(mData[116]); 
            s.Write(mData[117]); 
            s.Write(mData[118]); 
            s.Write(mData[119]); 
            s.Write(mData[120]); 
            s.Write(mData[121]); 
            s.Write(mData[122]); 
            s.Write(mData[123]); 
            s.Write(mData[124]); 
            s.Write(mData[125]); 
            s.Write(mData[126]); 
            s.Write(mData[127]); 
            s.Write(mData[128]); 
            s.Write(mData[129]); 
            s.Write(mData[130]); 
            s.Write(mData[131]); 
            s.Write(mData[132]); 
            s.Write(mData[133]); 
            s.Write(mData[134]); 
            s.Write(mData[135]); 
            s.Write(mData[136]); 
            s.Write(mData[137]); 
            s.Write(mData[138]); 
            s.Write(mData[139]); 
            s.Write(mData[140]); 
            s.Write(mData[141]); 
            s.Write(mData[142]); 
            s.Write(mData[143]); 
            s.Write(mData[144]); 
            s.Write(mData[145]); 
            s.Write(mData[146]); 
            s.Write(mData[147]); 
            s.Write(mData[148]); 
            s.Write(mData[149]); 
            s.Write(mData[150]); 
            s.Write(mData[151]); 
            s.Write(mData[152]); 
            s.Write(mData[153]); 
            s.Write(mData[154]); 
            s.Write(mData[155]); 
            s.Write(mData[156]); 
            s.Write(mData[157]); 
            s.Write(mData[158]); 
            s.Write(mData[159]); 
            s.Write(mData[160]); 
            s.Write(mData[161]); 
            s.Write(mData[162]); 
            s.Write(mData[163]); 
            s.Write(mData[164]); 
            s.Write(mData[165]); 
            s.Write(mData[166]); 
            s.Write(mData[167]); 
            s.Write(mData[168]); 
            s.Write(mData[169]); 
            s.Write(mData[170]); 
            s.Write(mData[171]); 
            s.Write(mData[172]); 
            s.Write(mData[173]); 
            s.Write(mData[174]); 
            s.Write(mData[175]); 
            s.Write(mData[176]); 
            s.Write(mData[177]); 
            s.Write(mData[178]); 
            s.Write(mData[179]); 
            s.Write(mData[180]); 
            s.Write(mData[181]); 
            s.Write(mData[182]); 
            s.Write(mData[183]); 
            s.Write(mData[184]); 
            s.Write(mData[185]); 
            s.Write(mData[186]); 
            s.Write(mData[187]); 
            s.Write(mData[188]); 
            s.Write(mData[189]); 
            s.Write(mData[190]); 
            s.Write(mData[191]); 
            s.Write(mData[192]); 
            s.Write(mData[193]); 
            s.Write(mData[194]); 
            s.Write(mData[195]); 
            s.Write(mData[196]); 
            s.Write(mData[197]); 
            s.Write(mData[198]); 
            s.Write(mData[199]); 
            s.Write(mData[200]); 
            s.Write(mData[201]); 
            s.Write(mData[202]); 
            s.Write(mData[203]); 
            s.Write(mData[204]); 
            s.Write(mData[205]); 
            s.Write(mData[206]); 
            s.Write(mData[207]); 
            s.Write(mData[208]); 
            s.Write(mData[209]); 
            s.Write(mData[210]); 
            s.Write(mData[211]); 
            s.Write(mData[212]); 
            s.Write(mData[213]); 
            s.Write(mData[214]); 
            s.Write(mData[215]); 
            s.Write(mData[216]); 
            s.Write(mData[217]); 
            s.Write(mData[218]); 
            s.Write(mData[219]); 
            s.Write(mData[220]); 
            s.Write(mData[221]); 
            s.Write(mData[222]); 
            s.Write(mData[223]); 
            s.Write(mData[224]); 
            s.Write(mData[225]); 
            s.Write(mData[226]); 
            s.Write(mData[227]); 
            s.Write(mData[228]); 
            s.Write(mData[229]); 
            s.Write(mData[230]); 
            s.Write(mData[231]); 
            s.Write(mData[232]); 
            s.Write(mData[233]); 
            s.Write(mData[234]); 
            s.Write(mData[235]); 
            s.Write(mData[236]); 
            s.Write(mData[237]); 
            s.Write(mData[238]); 
            s.Write(mData[239]); 
            s.Write(mData[240]); 
            s.Write(mData[241]); 
            s.Write(mData[242]); 
            s.Write(mData[243]); 
            s.Write(mData[244]); 
            s.Write(mData[245]); 
            s.Write(mData[246]); 
            s.Write(mData[247]); 
            s.Write(mData[248]); 
            s.Write(mData[249]); 
            s.Write(mData[250]); 
            s.Write(mData[251]); 
            s.Write(mData[252]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSeqnr = s.ReadUInt16();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
            this.mData[90] = s.ReadByte();
            this.mData[91] = s.ReadByte();
            this.mData[92] = s.ReadByte();
            this.mData[93] = s.ReadByte();
            this.mData[94] = s.ReadByte();
            this.mData[95] = s.ReadByte();
            this.mData[96] = s.ReadByte();
            this.mData[97] = s.ReadByte();
            this.mData[98] = s.ReadByte();
            this.mData[99] = s.ReadByte();
            this.mData[100] = s.ReadByte();
            this.mData[101] = s.ReadByte();
            this.mData[102] = s.ReadByte();
            this.mData[103] = s.ReadByte();
            this.mData[104] = s.ReadByte();
            this.mData[105] = s.ReadByte();
            this.mData[106] = s.ReadByte();
            this.mData[107] = s.ReadByte();
            this.mData[108] = s.ReadByte();
            this.mData[109] = s.ReadByte();
            this.mData[110] = s.ReadByte();
            this.mData[111] = s.ReadByte();
            this.mData[112] = s.ReadByte();
            this.mData[113] = s.ReadByte();
            this.mData[114] = s.ReadByte();
            this.mData[115] = s.ReadByte();
            this.mData[116] = s.ReadByte();
            this.mData[117] = s.ReadByte();
            this.mData[118] = s.ReadByte();
            this.mData[119] = s.ReadByte();
            this.mData[120] = s.ReadByte();
            this.mData[121] = s.ReadByte();
            this.mData[122] = s.ReadByte();
            this.mData[123] = s.ReadByte();
            this.mData[124] = s.ReadByte();
            this.mData[125] = s.ReadByte();
            this.mData[126] = s.ReadByte();
            this.mData[127] = s.ReadByte();
            this.mData[128] = s.ReadByte();
            this.mData[129] = s.ReadByte();
            this.mData[130] = s.ReadByte();
            this.mData[131] = s.ReadByte();
            this.mData[132] = s.ReadByte();
            this.mData[133] = s.ReadByte();
            this.mData[134] = s.ReadByte();
            this.mData[135] = s.ReadByte();
            this.mData[136] = s.ReadByte();
            this.mData[137] = s.ReadByte();
            this.mData[138] = s.ReadByte();
            this.mData[139] = s.ReadByte();
            this.mData[140] = s.ReadByte();
            this.mData[141] = s.ReadByte();
            this.mData[142] = s.ReadByte();
            this.mData[143] = s.ReadByte();
            this.mData[144] = s.ReadByte();
            this.mData[145] = s.ReadByte();
            this.mData[146] = s.ReadByte();
            this.mData[147] = s.ReadByte();
            this.mData[148] = s.ReadByte();
            this.mData[149] = s.ReadByte();
            this.mData[150] = s.ReadByte();
            this.mData[151] = s.ReadByte();
            this.mData[152] = s.ReadByte();
            this.mData[153] = s.ReadByte();
            this.mData[154] = s.ReadByte();
            this.mData[155] = s.ReadByte();
            this.mData[156] = s.ReadByte();
            this.mData[157] = s.ReadByte();
            this.mData[158] = s.ReadByte();
            this.mData[159] = s.ReadByte();
            this.mData[160] = s.ReadByte();
            this.mData[161] = s.ReadByte();
            this.mData[162] = s.ReadByte();
            this.mData[163] = s.ReadByte();
            this.mData[164] = s.ReadByte();
            this.mData[165] = s.ReadByte();
            this.mData[166] = s.ReadByte();
            this.mData[167] = s.ReadByte();
            this.mData[168] = s.ReadByte();
            this.mData[169] = s.ReadByte();
            this.mData[170] = s.ReadByte();
            this.mData[171] = s.ReadByte();
            this.mData[172] = s.ReadByte();
            this.mData[173] = s.ReadByte();
            this.mData[174] = s.ReadByte();
            this.mData[175] = s.ReadByte();
            this.mData[176] = s.ReadByte();
            this.mData[177] = s.ReadByte();
            this.mData[178] = s.ReadByte();
            this.mData[179] = s.ReadByte();
            this.mData[180] = s.ReadByte();
            this.mData[181] = s.ReadByte();
            this.mData[182] = s.ReadByte();
            this.mData[183] = s.ReadByte();
            this.mData[184] = s.ReadByte();
            this.mData[185] = s.ReadByte();
            this.mData[186] = s.ReadByte();
            this.mData[187] = s.ReadByte();
            this.mData[188] = s.ReadByte();
            this.mData[189] = s.ReadByte();
            this.mData[190] = s.ReadByte();
            this.mData[191] = s.ReadByte();
            this.mData[192] = s.ReadByte();
            this.mData[193] = s.ReadByte();
            this.mData[194] = s.ReadByte();
            this.mData[195] = s.ReadByte();
            this.mData[196] = s.ReadByte();
            this.mData[197] = s.ReadByte();
            this.mData[198] = s.ReadByte();
            this.mData[199] = s.ReadByte();
            this.mData[200] = s.ReadByte();
            this.mData[201] = s.ReadByte();
            this.mData[202] = s.ReadByte();
            this.mData[203] = s.ReadByte();
            this.mData[204] = s.ReadByte();
            this.mData[205] = s.ReadByte();
            this.mData[206] = s.ReadByte();
            this.mData[207] = s.ReadByte();
            this.mData[208] = s.ReadByte();
            this.mData[209] = s.ReadByte();
            this.mData[210] = s.ReadByte();
            this.mData[211] = s.ReadByte();
            this.mData[212] = s.ReadByte();
            this.mData[213] = s.ReadByte();
            this.mData[214] = s.ReadByte();
            this.mData[215] = s.ReadByte();
            this.mData[216] = s.ReadByte();
            this.mData[217] = s.ReadByte();
            this.mData[218] = s.ReadByte();
            this.mData[219] = s.ReadByte();
            this.mData[220] = s.ReadByte();
            this.mData[221] = s.ReadByte();
            this.mData[222] = s.ReadByte();
            this.mData[223] = s.ReadByte();
            this.mData[224] = s.ReadByte();
            this.mData[225] = s.ReadByte();
            this.mData[226] = s.ReadByte();
            this.mData[227] = s.ReadByte();
            this.mData[228] = s.ReadByte();
            this.mData[229] = s.ReadByte();
            this.mData[230] = s.ReadByte();
            this.mData[231] = s.ReadByte();
            this.mData[232] = s.ReadByte();
            this.mData[233] = s.ReadByte();
            this.mData[234] = s.ReadByte();
            this.mData[235] = s.ReadByte();
            this.mData[236] = s.ReadByte();
            this.mData[237] = s.ReadByte();
            this.mData[238] = s.ReadByte();
            this.mData[239] = s.ReadByte();
            this.mData[240] = s.ReadByte();
            this.mData[241] = s.ReadByte();
            this.mData[242] = s.ReadByte();
            this.mData[243] = s.ReadByte();
            this.mData[244] = s.ReadByte();
            this.mData[245] = s.ReadByte();
            this.mData[246] = s.ReadByte();
            this.mData[247] = s.ReadByte();
            this.mData[248] = s.ReadByte();
            this.mData[249] = s.ReadByte();
            this.mData[250] = s.ReadByte();
            this.mData[251] = s.ReadByte();
            this.mData[252] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Data packet for images sent using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seqnr",
                Description = "sequence number (starting with 0 on every transmission)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "image data bytes",
                NumElements = 253,
            });

        }

        private UInt16 mSeqnr;
        private byte[] mData = new byte[253];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Distance sensor information for an onboard rangefinder.
    /// </summary>
    public class UasDistanceSensor: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 18; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Minimum distance the sensor can measure
        /// </summary>
        public UInt16 MinDistance {
            get { return mMinDistance; }
            set { mMinDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum distance the sensor can measure
        /// </summary>
        public UInt16 MaxDistance {
            get { return mMaxDistance; }
            set { mMaxDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current distance reading
        /// </summary>
        public UInt16 CurrentDistance {
            get { return mCurrentDistance; }
            set { mCurrentDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type of distance sensor.
        /// </summary>
        public MavDistanceSensor Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard ID of the sensor
        /// </summary>
        public byte Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Direction the sensor faces. downward-facing: ROTATION_PITCH_270, upward-facing: ROTATION_PITCH_90, backward-facing: ROTATION_PITCH_180, forward-facing: ROTATION_NONE, left-facing: ROTATION_YAW_90, right-facing: ROTATION_YAW_270
        /// </summary>
        public MavSensorOrientation Orientation {
            get { return mOrientation; }
            set { mOrientation = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Measurement variance. Max standard deviation is 6cm. UINT8_MAX if unknown.
        /// </summary>
        public byte Covariance {
            get { return mCovariance; }
            set { mCovariance = value; NotifyUpdated(); }
        }

        public UasDistanceSensor()
        {
            mMessageId = 132;
            CrcExtra = 85;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mMinDistance);
            s.Write(mMaxDistance);
            s.Write(mCurrentDistance);
            s.Write((byte)mType);
            s.Write(mId);
            s.Write((byte)mOrientation);
            s.Write(mCovariance);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mMinDistance = s.ReadUInt16();
            this.mMaxDistance = s.ReadUInt16();
            this.mCurrentDistance = s.ReadUInt16();
            this.mType = (MavDistanceSensor)s.ReadByte();
            this.mId = s.ReadByte();
            this.mOrientation = (MavSensorOrientation)s.ReadByte();
            this.mCovariance = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Distance sensor information for an onboard rangefinder."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MinDistance",
                Description = "Minimum distance the sensor can measure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MaxDistance",
                Description = "Maximum distance the sensor can measure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentDistance",
                Description = "Current distance reading",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type of distance sensor.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavDistanceSensor"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Onboard ID of the sensor",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Orientation",
                Description = "Direction the sensor faces. downward-facing: ROTATION_PITCH_270, upward-facing: ROTATION_PITCH_90, backward-facing: ROTATION_PITCH_180, forward-facing: ROTATION_NONE, left-facing: ROTATION_YAW_90, right-facing: ROTATION_YAW_270",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSensorOrientation"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Covariance",
                Description = "Measurement variance. Max standard deviation is 6cm. UINT8_MAX if unknown.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private UInt16 mMinDistance;
        private UInt16 mMaxDistance;
        private UInt16 mCurrentDistance;
        private MavDistanceSensor mType;
        private byte mId;
        private MavSensorOrientation mOrientation;
        private byte mCovariance;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request for terrain data and terrain status. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
    /// </summary>
    public class UasTerrainRequest: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 18; }
        }
        /// <summary>
        /// Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
        /// </summary>
        public UInt64 Mask {
            get { return mMask; }
            set { mMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude of SW corner of first grid
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude of SW corner of first grid
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Grid spacing
        /// </summary>
        public UInt16 GridSpacing {
            get { return mGridSpacing; }
            set { mGridSpacing = value; NotifyUpdated(); }
        }

        public UasTerrainRequest()
        {
            mMessageId = 133;
            CrcExtra = 6;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mMask);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mGridSpacing);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mMask = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mGridSpacing = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request for terrain data and terrain status. See terrain protocol docs: https://mavlink.io/en/services/terrain.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Mask",
                Description = "Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude of SW corner of first grid",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude of SW corner of first grid",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GridSpacing",
                Description = "Grid spacing",
                NumElements = 1,
            });

        }

        private UInt64 mMask;
        private Int32 mLat;
        private Int32 mLon;
        private UInt16 mGridSpacing;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
    /// </summary>
    public class UasTerrainData: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 44; }
        }
        /// <summary>
        /// Latitude of SW corner of first grid
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude of SW corner of first grid
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Grid spacing
        /// </summary>
        public UInt16 GridSpacing {
            get { return mGridSpacing; }
            set { mGridSpacing = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Terrain data MSL
        /// </summary>
        public Int16[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        /// <summary>
        /// bit within the terrain request mask
        /// </summary>
        public byte Gridbit {
            get { return mGridbit; }
            set { mGridbit = value; NotifyUpdated(); }
        }

        public UasTerrainData()
        {
            mMessageId = 134;
            CrcExtra = 229;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mGridSpacing);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mGridbit);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mGridSpacing = s.ReadUInt16();
            this.mData[0] = s.ReadInt16();
            this.mData[1] = s.ReadInt16();
            this.mData[2] = s.ReadInt16();
            this.mData[3] = s.ReadInt16();
            this.mData[4] = s.ReadInt16();
            this.mData[5] = s.ReadInt16();
            this.mData[6] = s.ReadInt16();
            this.mData[7] = s.ReadInt16();
            this.mData[8] = s.ReadInt16();
            this.mData[9] = s.ReadInt16();
            this.mData[10] = s.ReadInt16();
            this.mData[11] = s.ReadInt16();
            this.mData[12] = s.ReadInt16();
            this.mData[13] = s.ReadInt16();
            this.mData[14] = s.ReadInt16();
            this.mData[15] = s.ReadInt16();
            this.mGridbit = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST. See terrain protocol docs: https://mavlink.io/en/services/terrain.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude of SW corner of first grid",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude of SW corner of first grid",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GridSpacing",
                Description = "Grid spacing",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "Terrain data MSL",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Gridbit",
                Description = "bit within the terrain request mask",
                NumElements = 1,
            });

        }

        private Int32 mLat;
        private Int32 mLon;
        private UInt16 mGridSpacing;
        private Int16[] mData = new Int16[16];
        private byte mGridbit;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request that the vehicle report terrain height at the given location (expected response is a TERRAIN_REPORT). Used by GCS to check if vehicle has all terrain data needed for a mission.
    /// </summary>
    public class UasTerrainCheck: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 8; }
        }
        /// <summary>
        /// Latitude
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        public UasTerrainCheck()
        {
            mMessageId = 135;
            CrcExtra = 203;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mLat);
            s.Write(mLon);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request that the vehicle report terrain height at the given location (expected response is a TERRAIN_REPORT). Used by GCS to check if vehicle has all terrain data needed for a mission."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude",
                NumElements = 1,
            });

        }

        private Int32 mLat;
        private Int32 mLon;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Streamed from drone to report progress of terrain map download (initiated by TERRAIN_REQUEST), or sent as a response to a TERRAIN_CHECK request. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
    /// </summary>
    public class UasTerrainReport: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 22; }
        }
        /// <summary>
        /// Latitude
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Terrain height MSL
        /// </summary>
        public float TerrainHeight {
            get { return mTerrainHeight; }
            set { mTerrainHeight = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current vehicle height above lat/lon terrain height
        /// </summary>
        public float CurrentHeight {
            get { return mCurrentHeight; }
            set { mCurrentHeight = value; NotifyUpdated(); }
        }

        /// <summary>
        /// grid spacing (zero if terrain at this location unavailable)
        /// </summary>
        public UInt16 Spacing {
            get { return mSpacing; }
            set { mSpacing = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of 4x4 terrain blocks waiting to be received or read from disk
        /// </summary>
        public UInt16 Pending {
            get { return mPending; }
            set { mPending = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of 4x4 terrain blocks in memory
        /// </summary>
        public UInt16 Loaded {
            get { return mLoaded; }
            set { mLoaded = value; NotifyUpdated(); }
        }

        public UasTerrainReport()
        {
            mMessageId = 136;
            CrcExtra = 1;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mTerrainHeight);
            s.Write(mCurrentHeight);
            s.Write(mSpacing);
            s.Write(mPending);
            s.Write(mLoaded);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mTerrainHeight = s.ReadSingle();
            this.mCurrentHeight = s.ReadSingle();
            this.mSpacing = s.ReadUInt16();
            this.mPending = s.ReadUInt16();
            this.mLoaded = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Streamed from drone to report progress of terrain map download (initiated by TERRAIN_REQUEST), or sent as a response to a TERRAIN_CHECK request. See terrain protocol docs: https://mavlink.io/en/services/terrain.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TerrainHeight",
                Description = "Terrain height MSL",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentHeight",
                Description = "Current vehicle height above lat/lon terrain height",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Spacing",
                Description = "grid spacing (zero if terrain at this location unavailable)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pending",
                Description = "Number of 4x4 terrain blocks waiting to be received or read from disk",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Loaded",
                Description = "Number of 4x4 terrain blocks in memory",
                NumElements = 1,
            });

        }

        private Int32 mLat;
        private Int32 mLon;
        private float mTerrainHeight;
        private float mCurrentHeight;
        private UInt16 mSpacing;
        private UInt16 mPending;
        private UInt16 mLoaded;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Barometer readings for 2nd barometer
    /// </summary>
    public class UasScaledPressure2: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 14; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure
        /// </summary>
        public float PressAbs {
            get { return mPressAbs; }
            set { mPressAbs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure
        /// </summary>
        public float PressDiff {
            get { return mPressDiff; }
            set { mPressDiff = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure temperature
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        public UasScaledPressure2()
        {
            mMessageId = 137;
            CrcExtra = 195;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mPressAbs);
            s.Write(mPressDiff);
            s.Write(mTemperature);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mPressAbs = s.ReadSingle();
            this.mPressDiff = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Barometer readings for 2nd barometer"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressAbs",
                Description = "Absolute pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff",
                Description = "Differential pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Absolute pressure temperature",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mPressAbs;
        private float mPressDiff;
        private Int16 mTemperature;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Motion capture attitude and position
    /// </summary>
    public class UasAttPosMocap: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 36; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X position (NED)
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y position (NED)
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z position (NED)
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        public UasAttPosMocap()
        {
            mMessageId = 138;
            CrcExtra = 109;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Motion capture attitude and position"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X position (NED)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y position (NED)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z position (NED)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mQ = new float[4];
        private float mX;
        private float mY;
        private float mZ;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set the vehicle attitude and body angular rates.
    /// </summary>
    public class UasSetActuatorControlTarget: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 46; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
        /// </summary>
        public float[] Controls {
            get { return mControls; }
            set { mControls = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Actuator group. The '_mlx' indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.
        /// </summary>
        public byte GroupMlx {
            get { return mGroupMlx; }
            set { mGroupMlx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasSetActuatorControlTarget()
        {
            mMessageId = 139;
            CrcExtra = 168;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mControls[0]); 
            s.Write(mControls[1]); 
            s.Write(mControls[2]); 
            s.Write(mControls[3]); 
            s.Write(mControls[4]); 
            s.Write(mControls[5]); 
            s.Write(mControls[6]); 
            s.Write(mControls[7]); 
            s.Write(mGroupMlx);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mControls[0] = s.ReadSingle();
            this.mControls[1] = s.ReadSingle();
            this.mControls[2] = s.ReadSingle();
            this.mControls[3] = s.ReadSingle();
            this.mControls[4] = s.ReadSingle();
            this.mControls[5] = s.ReadSingle();
            this.mControls[6] = s.ReadSingle();
            this.mControls[7] = s.ReadSingle();
            this.mGroupMlx = s.ReadByte();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set the vehicle attitude and body angular rates."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Controls",
                Description = "Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.",
                NumElements = 8,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GroupMlx",
                Description = "Actuator group. The '_mlx' indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mControls = new float[8];
        private byte mGroupMlx;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set the vehicle attitude and body angular rates.
    /// </summary>
    public class UasActuatorControlTarget: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 42; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
        /// </summary>
        public float[] Controls {
            get { return mControls; }
            set { mControls = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Actuator group. The '_mlx' indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.
        /// </summary>
        public byte GroupMlx {
            get { return mGroupMlx; }
            set { mGroupMlx = value; NotifyUpdated(); }
        }

        public UasActuatorControlTarget()
        {
            mMessageId = 140;
            CrcExtra = 181;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mControls[0]); 
            s.Write(mControls[1]); 
            s.Write(mControls[2]); 
            s.Write(mControls[3]); 
            s.Write(mControls[4]); 
            s.Write(mControls[5]); 
            s.Write(mControls[6]); 
            s.Write(mControls[7]); 
            s.Write(mGroupMlx);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mControls[0] = s.ReadSingle();
            this.mControls[1] = s.ReadSingle();
            this.mControls[2] = s.ReadSingle();
            this.mControls[3] = s.ReadSingle();
            this.mControls[4] = s.ReadSingle();
            this.mControls[5] = s.ReadSingle();
            this.mControls[6] = s.ReadSingle();
            this.mControls[7] = s.ReadSingle();
            this.mGroupMlx = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set the vehicle attitude and body angular rates."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Controls",
                Description = "Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.",
                NumElements = 8,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GroupMlx",
                Description = "Actuator group. The '_mlx' indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mControls = new float[8];
        private byte mGroupMlx;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The current system altitude.
    /// </summary>
    public class UasAltitude: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This altitude measure is initialized on system boot and monotonic (it is never reset, but represents the local altitude change). The only guarantee on this field is that it will never be reset and is consistent within a flight. The recommended value for this field is the uncorrected barometric altitude at boot time. This altitude will also drift and vary between flights.
        /// </summary>
        public float AltitudeMonotonic {
            get { return mAltitudeMonotonic; }
            set { mAltitudeMonotonic = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This altitude measure is strictly above mean sea level and might be non-monotonic (it might reset on events like GPS lock or when a new QNH value is set). It should be the altitude to which global altitude waypoints are compared to. Note that it is *not* the GPS altitude, however, most GPS modules already output MSL by default and not the WGS84 altitude.
        /// </summary>
        public float AltitudeAmsl {
            get { return mAltitudeAmsl; }
            set { mAltitudeAmsl = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This is the local altitude in the local coordinate frame. It is not the altitude above home, but in reference to the coordinate origin (0, 0, 0). It is up-positive.
        /// </summary>
        public float AltitudeLocal {
            get { return mAltitudeLocal; }
            set { mAltitudeLocal = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This is the altitude above the home position. It resets on each change of the current home position.
        /// </summary>
        public float AltitudeRelative {
            get { return mAltitudeRelative; }
            set { mAltitudeRelative = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This is the altitude above terrain. It might be fed by a terrain database or an altimeter. Values smaller than -1000 should be interpreted as unknown.
        /// </summary>
        public float AltitudeTerrain {
            get { return mAltitudeTerrain; }
            set { mAltitudeTerrain = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This is not the altitude, but the clear space below the system according to the fused clearance estimate. It generally should max out at the maximum range of e.g. the laser altimeter. It is generally a moving target. A negative value indicates no measurement available.
        /// </summary>
        public float BottomClearance {
            get { return mBottomClearance; }
            set { mBottomClearance = value; NotifyUpdated(); }
        }

        public UasAltitude()
        {
            mMessageId = 141;
            CrcExtra = 47;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mAltitudeMonotonic);
            s.Write(mAltitudeAmsl);
            s.Write(mAltitudeLocal);
            s.Write(mAltitudeRelative);
            s.Write(mAltitudeTerrain);
            s.Write(mBottomClearance);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mAltitudeMonotonic = s.ReadSingle();
            this.mAltitudeAmsl = s.ReadSingle();
            this.mAltitudeLocal = s.ReadSingle();
            this.mAltitudeRelative = s.ReadSingle();
            this.mAltitudeTerrain = s.ReadSingle();
            this.mBottomClearance = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The current system altitude."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeMonotonic",
                Description = "This altitude measure is initialized on system boot and monotonic (it is never reset, but represents the local altitude change). The only guarantee on this field is that it will never be reset and is consistent within a flight. The recommended value for this field is the uncorrected barometric altitude at boot time. This altitude will also drift and vary between flights.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeAmsl",
                Description = "This altitude measure is strictly above mean sea level and might be non-monotonic (it might reset on events like GPS lock or when a new QNH value is set). It should be the altitude to which global altitude waypoints are compared to. Note that it is *not* the GPS altitude, however, most GPS modules already output MSL by default and not the WGS84 altitude.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeLocal",
                Description = "This is the local altitude in the local coordinate frame. It is not the altitude above home, but in reference to the coordinate origin (0, 0, 0). It is up-positive.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeRelative",
                Description = "This is the altitude above the home position. It resets on each change of the current home position.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeTerrain",
                Description = "This is the altitude above terrain. It might be fed by a terrain database or an altimeter. Values smaller than -1000 should be interpreted as unknown.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BottomClearance",
                Description = "This is not the altitude, but the clear space below the system according to the fused clearance estimate. It generally should max out at the maximum range of e.g. the laser altimeter. It is generally a moving target. A negative value indicates no measurement available.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mAltitudeMonotonic;
        private float mAltitudeAmsl;
        private float mAltitudeLocal;
        private float mAltitudeRelative;
        private float mAltitudeTerrain;
        private float mBottomClearance;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The autopilot is requesting a resource (file, binary, other type of data)
    /// </summary>
    public class UasResourceRequest: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 486; }
        }
        /// <summary>
        /// Request ID. This ID should be re-used when sending back URI contents
        /// </summary>
        public byte RequestId {
            get { return mRequestId; }
            set { mRequestId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary
        /// </summary>
        public byte UriType {
            get { return mUriType; }
            set { mUriType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The requested unique resource identifier (URI). It is not necessarily a straight domain name (depends on the URI type enum)
        /// </summary>
        public byte[] Uri {
            get { return mUri; }
            set { mUri = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.
        /// </summary>
        public byte TransferType {
            get { return mTransferType; }
            set { mTransferType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The storage path the autopilot wants the URI to be stored in. Will only be valid if the transfer_type has a storage associated (e.g. MAVLink FTP).
        /// </summary>
        public byte[] Storage {
            get { return mStorage; }
            set { mStorage = value; NotifyUpdated(); }
        }

        public UasResourceRequest()
        {
            mMessageId = 142;
            CrcExtra = 72;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mRequestId);
            s.Write(mUriType);
            s.Write(mUri[0]); 
            s.Write(mUri[1]); 
            s.Write(mUri[2]); 
            s.Write(mUri[3]); 
            s.Write(mUri[4]); 
            s.Write(mUri[5]); 
            s.Write(mUri[6]); 
            s.Write(mUri[7]); 
            s.Write(mUri[8]); 
            s.Write(mUri[9]); 
            s.Write(mUri[10]); 
            s.Write(mUri[11]); 
            s.Write(mUri[12]); 
            s.Write(mUri[13]); 
            s.Write(mUri[14]); 
            s.Write(mUri[15]); 
            s.Write(mUri[16]); 
            s.Write(mUri[17]); 
            s.Write(mUri[18]); 
            s.Write(mUri[19]); 
            s.Write(mUri[20]); 
            s.Write(mUri[21]); 
            s.Write(mUri[22]); 
            s.Write(mUri[23]); 
            s.Write(mUri[24]); 
            s.Write(mUri[25]); 
            s.Write(mUri[26]); 
            s.Write(mUri[27]); 
            s.Write(mUri[28]); 
            s.Write(mUri[29]); 
            s.Write(mUri[30]); 
            s.Write(mUri[31]); 
            s.Write(mUri[32]); 
            s.Write(mUri[33]); 
            s.Write(mUri[34]); 
            s.Write(mUri[35]); 
            s.Write(mUri[36]); 
            s.Write(mUri[37]); 
            s.Write(mUri[38]); 
            s.Write(mUri[39]); 
            s.Write(mUri[40]); 
            s.Write(mUri[41]); 
            s.Write(mUri[42]); 
            s.Write(mUri[43]); 
            s.Write(mUri[44]); 
            s.Write(mUri[45]); 
            s.Write(mUri[46]); 
            s.Write(mUri[47]); 
            s.Write(mUri[48]); 
            s.Write(mUri[49]); 
            s.Write(mUri[50]); 
            s.Write(mUri[51]); 
            s.Write(mUri[52]); 
            s.Write(mUri[53]); 
            s.Write(mUri[54]); 
            s.Write(mUri[55]); 
            s.Write(mUri[56]); 
            s.Write(mUri[57]); 
            s.Write(mUri[58]); 
            s.Write(mUri[59]); 
            s.Write(mUri[60]); 
            s.Write(mUri[61]); 
            s.Write(mUri[62]); 
            s.Write(mUri[63]); 
            s.Write(mUri[64]); 
            s.Write(mUri[65]); 
            s.Write(mUri[66]); 
            s.Write(mUri[67]); 
            s.Write(mUri[68]); 
            s.Write(mUri[69]); 
            s.Write(mUri[70]); 
            s.Write(mUri[71]); 
            s.Write(mUri[72]); 
            s.Write(mUri[73]); 
            s.Write(mUri[74]); 
            s.Write(mUri[75]); 
            s.Write(mUri[76]); 
            s.Write(mUri[77]); 
            s.Write(mUri[78]); 
            s.Write(mUri[79]); 
            s.Write(mUri[80]); 
            s.Write(mUri[81]); 
            s.Write(mUri[82]); 
            s.Write(mUri[83]); 
            s.Write(mUri[84]); 
            s.Write(mUri[85]); 
            s.Write(mUri[86]); 
            s.Write(mUri[87]); 
            s.Write(mUri[88]); 
            s.Write(mUri[89]); 
            s.Write(mUri[90]); 
            s.Write(mUri[91]); 
            s.Write(mUri[92]); 
            s.Write(mUri[93]); 
            s.Write(mUri[94]); 
            s.Write(mUri[95]); 
            s.Write(mUri[96]); 
            s.Write(mUri[97]); 
            s.Write(mUri[98]); 
            s.Write(mUri[99]); 
            s.Write(mUri[100]); 
            s.Write(mUri[101]); 
            s.Write(mUri[102]); 
            s.Write(mUri[103]); 
            s.Write(mUri[104]); 
            s.Write(mUri[105]); 
            s.Write(mUri[106]); 
            s.Write(mUri[107]); 
            s.Write(mUri[108]); 
            s.Write(mUri[109]); 
            s.Write(mUri[110]); 
            s.Write(mUri[111]); 
            s.Write(mUri[112]); 
            s.Write(mUri[113]); 
            s.Write(mUri[114]); 
            s.Write(mUri[115]); 
            s.Write(mUri[116]); 
            s.Write(mUri[117]); 
            s.Write(mUri[118]); 
            s.Write(mUri[119]); 
            s.Write(mTransferType);
            s.Write(mStorage[0]); 
            s.Write(mStorage[1]); 
            s.Write(mStorage[2]); 
            s.Write(mStorage[3]); 
            s.Write(mStorage[4]); 
            s.Write(mStorage[5]); 
            s.Write(mStorage[6]); 
            s.Write(mStorage[7]); 
            s.Write(mStorage[8]); 
            s.Write(mStorage[9]); 
            s.Write(mStorage[10]); 
            s.Write(mStorage[11]); 
            s.Write(mStorage[12]); 
            s.Write(mStorage[13]); 
            s.Write(mStorage[14]); 
            s.Write(mStorage[15]); 
            s.Write(mStorage[16]); 
            s.Write(mStorage[17]); 
            s.Write(mStorage[18]); 
            s.Write(mStorage[19]); 
            s.Write(mStorage[20]); 
            s.Write(mStorage[21]); 
            s.Write(mStorage[22]); 
            s.Write(mStorage[23]); 
            s.Write(mStorage[24]); 
            s.Write(mStorage[25]); 
            s.Write(mStorage[26]); 
            s.Write(mStorage[27]); 
            s.Write(mStorage[28]); 
            s.Write(mStorage[29]); 
            s.Write(mStorage[30]); 
            s.Write(mStorage[31]); 
            s.Write(mStorage[32]); 
            s.Write(mStorage[33]); 
            s.Write(mStorage[34]); 
            s.Write(mStorage[35]); 
            s.Write(mStorage[36]); 
            s.Write(mStorage[37]); 
            s.Write(mStorage[38]); 
            s.Write(mStorage[39]); 
            s.Write(mStorage[40]); 
            s.Write(mStorage[41]); 
            s.Write(mStorage[42]); 
            s.Write(mStorage[43]); 
            s.Write(mStorage[44]); 
            s.Write(mStorage[45]); 
            s.Write(mStorage[46]); 
            s.Write(mStorage[47]); 
            s.Write(mStorage[48]); 
            s.Write(mStorage[49]); 
            s.Write(mStorage[50]); 
            s.Write(mStorage[51]); 
            s.Write(mStorage[52]); 
            s.Write(mStorage[53]); 
            s.Write(mStorage[54]); 
            s.Write(mStorage[55]); 
            s.Write(mStorage[56]); 
            s.Write(mStorage[57]); 
            s.Write(mStorage[58]); 
            s.Write(mStorage[59]); 
            s.Write(mStorage[60]); 
            s.Write(mStorage[61]); 
            s.Write(mStorage[62]); 
            s.Write(mStorage[63]); 
            s.Write(mStorage[64]); 
            s.Write(mStorage[65]); 
            s.Write(mStorage[66]); 
            s.Write(mStorage[67]); 
            s.Write(mStorage[68]); 
            s.Write(mStorage[69]); 
            s.Write(mStorage[70]); 
            s.Write(mStorage[71]); 
            s.Write(mStorage[72]); 
            s.Write(mStorage[73]); 
            s.Write(mStorage[74]); 
            s.Write(mStorage[75]); 
            s.Write(mStorage[76]); 
            s.Write(mStorage[77]); 
            s.Write(mStorage[78]); 
            s.Write(mStorage[79]); 
            s.Write(mStorage[80]); 
            s.Write(mStorage[81]); 
            s.Write(mStorage[82]); 
            s.Write(mStorage[83]); 
            s.Write(mStorage[84]); 
            s.Write(mStorage[85]); 
            s.Write(mStorage[86]); 
            s.Write(mStorage[87]); 
            s.Write(mStorage[88]); 
            s.Write(mStorage[89]); 
            s.Write(mStorage[90]); 
            s.Write(mStorage[91]); 
            s.Write(mStorage[92]); 
            s.Write(mStorage[93]); 
            s.Write(mStorage[94]); 
            s.Write(mStorage[95]); 
            s.Write(mStorage[96]); 
            s.Write(mStorage[97]); 
            s.Write(mStorage[98]); 
            s.Write(mStorage[99]); 
            s.Write(mStorage[100]); 
            s.Write(mStorage[101]); 
            s.Write(mStorage[102]); 
            s.Write(mStorage[103]); 
            s.Write(mStorage[104]); 
            s.Write(mStorage[105]); 
            s.Write(mStorage[106]); 
            s.Write(mStorage[107]); 
            s.Write(mStorage[108]); 
            s.Write(mStorage[109]); 
            s.Write(mStorage[110]); 
            s.Write(mStorage[111]); 
            s.Write(mStorage[112]); 
            s.Write(mStorage[113]); 
            s.Write(mStorage[114]); 
            s.Write(mStorage[115]); 
            s.Write(mStorage[116]); 
            s.Write(mStorage[117]); 
            s.Write(mStorage[118]); 
            s.Write(mStorage[119]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mRequestId = s.ReadByte();
            this.mUriType = s.ReadByte();
            this.mUri[0] = s.ReadByte();
            this.mUri[1] = s.ReadByte();
            this.mUri[2] = s.ReadByte();
            this.mUri[3] = s.ReadByte();
            this.mUri[4] = s.ReadByte();
            this.mUri[5] = s.ReadByte();
            this.mUri[6] = s.ReadByte();
            this.mUri[7] = s.ReadByte();
            this.mUri[8] = s.ReadByte();
            this.mUri[9] = s.ReadByte();
            this.mUri[10] = s.ReadByte();
            this.mUri[11] = s.ReadByte();
            this.mUri[12] = s.ReadByte();
            this.mUri[13] = s.ReadByte();
            this.mUri[14] = s.ReadByte();
            this.mUri[15] = s.ReadByte();
            this.mUri[16] = s.ReadByte();
            this.mUri[17] = s.ReadByte();
            this.mUri[18] = s.ReadByte();
            this.mUri[19] = s.ReadByte();
            this.mUri[20] = s.ReadByte();
            this.mUri[21] = s.ReadByte();
            this.mUri[22] = s.ReadByte();
            this.mUri[23] = s.ReadByte();
            this.mUri[24] = s.ReadByte();
            this.mUri[25] = s.ReadByte();
            this.mUri[26] = s.ReadByte();
            this.mUri[27] = s.ReadByte();
            this.mUri[28] = s.ReadByte();
            this.mUri[29] = s.ReadByte();
            this.mUri[30] = s.ReadByte();
            this.mUri[31] = s.ReadByte();
            this.mUri[32] = s.ReadByte();
            this.mUri[33] = s.ReadByte();
            this.mUri[34] = s.ReadByte();
            this.mUri[35] = s.ReadByte();
            this.mUri[36] = s.ReadByte();
            this.mUri[37] = s.ReadByte();
            this.mUri[38] = s.ReadByte();
            this.mUri[39] = s.ReadByte();
            this.mUri[40] = s.ReadByte();
            this.mUri[41] = s.ReadByte();
            this.mUri[42] = s.ReadByte();
            this.mUri[43] = s.ReadByte();
            this.mUri[44] = s.ReadByte();
            this.mUri[45] = s.ReadByte();
            this.mUri[46] = s.ReadByte();
            this.mUri[47] = s.ReadByte();
            this.mUri[48] = s.ReadByte();
            this.mUri[49] = s.ReadByte();
            this.mUri[50] = s.ReadByte();
            this.mUri[51] = s.ReadByte();
            this.mUri[52] = s.ReadByte();
            this.mUri[53] = s.ReadByte();
            this.mUri[54] = s.ReadByte();
            this.mUri[55] = s.ReadByte();
            this.mUri[56] = s.ReadByte();
            this.mUri[57] = s.ReadByte();
            this.mUri[58] = s.ReadByte();
            this.mUri[59] = s.ReadByte();
            this.mUri[60] = s.ReadByte();
            this.mUri[61] = s.ReadByte();
            this.mUri[62] = s.ReadByte();
            this.mUri[63] = s.ReadByte();
            this.mUri[64] = s.ReadByte();
            this.mUri[65] = s.ReadByte();
            this.mUri[66] = s.ReadByte();
            this.mUri[67] = s.ReadByte();
            this.mUri[68] = s.ReadByte();
            this.mUri[69] = s.ReadByte();
            this.mUri[70] = s.ReadByte();
            this.mUri[71] = s.ReadByte();
            this.mUri[72] = s.ReadByte();
            this.mUri[73] = s.ReadByte();
            this.mUri[74] = s.ReadByte();
            this.mUri[75] = s.ReadByte();
            this.mUri[76] = s.ReadByte();
            this.mUri[77] = s.ReadByte();
            this.mUri[78] = s.ReadByte();
            this.mUri[79] = s.ReadByte();
            this.mUri[80] = s.ReadByte();
            this.mUri[81] = s.ReadByte();
            this.mUri[82] = s.ReadByte();
            this.mUri[83] = s.ReadByte();
            this.mUri[84] = s.ReadByte();
            this.mUri[85] = s.ReadByte();
            this.mUri[86] = s.ReadByte();
            this.mUri[87] = s.ReadByte();
            this.mUri[88] = s.ReadByte();
            this.mUri[89] = s.ReadByte();
            this.mUri[90] = s.ReadByte();
            this.mUri[91] = s.ReadByte();
            this.mUri[92] = s.ReadByte();
            this.mUri[93] = s.ReadByte();
            this.mUri[94] = s.ReadByte();
            this.mUri[95] = s.ReadByte();
            this.mUri[96] = s.ReadByte();
            this.mUri[97] = s.ReadByte();
            this.mUri[98] = s.ReadByte();
            this.mUri[99] = s.ReadByte();
            this.mUri[100] = s.ReadByte();
            this.mUri[101] = s.ReadByte();
            this.mUri[102] = s.ReadByte();
            this.mUri[103] = s.ReadByte();
            this.mUri[104] = s.ReadByte();
            this.mUri[105] = s.ReadByte();
            this.mUri[106] = s.ReadByte();
            this.mUri[107] = s.ReadByte();
            this.mUri[108] = s.ReadByte();
            this.mUri[109] = s.ReadByte();
            this.mUri[110] = s.ReadByte();
            this.mUri[111] = s.ReadByte();
            this.mUri[112] = s.ReadByte();
            this.mUri[113] = s.ReadByte();
            this.mUri[114] = s.ReadByte();
            this.mUri[115] = s.ReadByte();
            this.mUri[116] = s.ReadByte();
            this.mUri[117] = s.ReadByte();
            this.mUri[118] = s.ReadByte();
            this.mUri[119] = s.ReadByte();
            this.mTransferType = s.ReadByte();
            this.mStorage[0] = s.ReadByte();
            this.mStorage[1] = s.ReadByte();
            this.mStorage[2] = s.ReadByte();
            this.mStorage[3] = s.ReadByte();
            this.mStorage[4] = s.ReadByte();
            this.mStorage[5] = s.ReadByte();
            this.mStorage[6] = s.ReadByte();
            this.mStorage[7] = s.ReadByte();
            this.mStorage[8] = s.ReadByte();
            this.mStorage[9] = s.ReadByte();
            this.mStorage[10] = s.ReadByte();
            this.mStorage[11] = s.ReadByte();
            this.mStorage[12] = s.ReadByte();
            this.mStorage[13] = s.ReadByte();
            this.mStorage[14] = s.ReadByte();
            this.mStorage[15] = s.ReadByte();
            this.mStorage[16] = s.ReadByte();
            this.mStorage[17] = s.ReadByte();
            this.mStorage[18] = s.ReadByte();
            this.mStorage[19] = s.ReadByte();
            this.mStorage[20] = s.ReadByte();
            this.mStorage[21] = s.ReadByte();
            this.mStorage[22] = s.ReadByte();
            this.mStorage[23] = s.ReadByte();
            this.mStorage[24] = s.ReadByte();
            this.mStorage[25] = s.ReadByte();
            this.mStorage[26] = s.ReadByte();
            this.mStorage[27] = s.ReadByte();
            this.mStorage[28] = s.ReadByte();
            this.mStorage[29] = s.ReadByte();
            this.mStorage[30] = s.ReadByte();
            this.mStorage[31] = s.ReadByte();
            this.mStorage[32] = s.ReadByte();
            this.mStorage[33] = s.ReadByte();
            this.mStorage[34] = s.ReadByte();
            this.mStorage[35] = s.ReadByte();
            this.mStorage[36] = s.ReadByte();
            this.mStorage[37] = s.ReadByte();
            this.mStorage[38] = s.ReadByte();
            this.mStorage[39] = s.ReadByte();
            this.mStorage[40] = s.ReadByte();
            this.mStorage[41] = s.ReadByte();
            this.mStorage[42] = s.ReadByte();
            this.mStorage[43] = s.ReadByte();
            this.mStorage[44] = s.ReadByte();
            this.mStorage[45] = s.ReadByte();
            this.mStorage[46] = s.ReadByte();
            this.mStorage[47] = s.ReadByte();
            this.mStorage[48] = s.ReadByte();
            this.mStorage[49] = s.ReadByte();
            this.mStorage[50] = s.ReadByte();
            this.mStorage[51] = s.ReadByte();
            this.mStorage[52] = s.ReadByte();
            this.mStorage[53] = s.ReadByte();
            this.mStorage[54] = s.ReadByte();
            this.mStorage[55] = s.ReadByte();
            this.mStorage[56] = s.ReadByte();
            this.mStorage[57] = s.ReadByte();
            this.mStorage[58] = s.ReadByte();
            this.mStorage[59] = s.ReadByte();
            this.mStorage[60] = s.ReadByte();
            this.mStorage[61] = s.ReadByte();
            this.mStorage[62] = s.ReadByte();
            this.mStorage[63] = s.ReadByte();
            this.mStorage[64] = s.ReadByte();
            this.mStorage[65] = s.ReadByte();
            this.mStorage[66] = s.ReadByte();
            this.mStorage[67] = s.ReadByte();
            this.mStorage[68] = s.ReadByte();
            this.mStorage[69] = s.ReadByte();
            this.mStorage[70] = s.ReadByte();
            this.mStorage[71] = s.ReadByte();
            this.mStorage[72] = s.ReadByte();
            this.mStorage[73] = s.ReadByte();
            this.mStorage[74] = s.ReadByte();
            this.mStorage[75] = s.ReadByte();
            this.mStorage[76] = s.ReadByte();
            this.mStorage[77] = s.ReadByte();
            this.mStorage[78] = s.ReadByte();
            this.mStorage[79] = s.ReadByte();
            this.mStorage[80] = s.ReadByte();
            this.mStorage[81] = s.ReadByte();
            this.mStorage[82] = s.ReadByte();
            this.mStorage[83] = s.ReadByte();
            this.mStorage[84] = s.ReadByte();
            this.mStorage[85] = s.ReadByte();
            this.mStorage[86] = s.ReadByte();
            this.mStorage[87] = s.ReadByte();
            this.mStorage[88] = s.ReadByte();
            this.mStorage[89] = s.ReadByte();
            this.mStorage[90] = s.ReadByte();
            this.mStorage[91] = s.ReadByte();
            this.mStorage[92] = s.ReadByte();
            this.mStorage[93] = s.ReadByte();
            this.mStorage[94] = s.ReadByte();
            this.mStorage[95] = s.ReadByte();
            this.mStorage[96] = s.ReadByte();
            this.mStorage[97] = s.ReadByte();
            this.mStorage[98] = s.ReadByte();
            this.mStorage[99] = s.ReadByte();
            this.mStorage[100] = s.ReadByte();
            this.mStorage[101] = s.ReadByte();
            this.mStorage[102] = s.ReadByte();
            this.mStorage[103] = s.ReadByte();
            this.mStorage[104] = s.ReadByte();
            this.mStorage[105] = s.ReadByte();
            this.mStorage[106] = s.ReadByte();
            this.mStorage[107] = s.ReadByte();
            this.mStorage[108] = s.ReadByte();
            this.mStorage[109] = s.ReadByte();
            this.mStorage[110] = s.ReadByte();
            this.mStorage[111] = s.ReadByte();
            this.mStorage[112] = s.ReadByte();
            this.mStorage[113] = s.ReadByte();
            this.mStorage[114] = s.ReadByte();
            this.mStorage[115] = s.ReadByte();
            this.mStorage[116] = s.ReadByte();
            this.mStorage[117] = s.ReadByte();
            this.mStorage[118] = s.ReadByte();
            this.mStorage[119] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The autopilot is requesting a resource (file, binary, other type of data)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RequestId",
                Description = "Request ID. This ID should be re-used when sending back URI contents",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "UriType",
                Description = "The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Uri",
                Description = "The requested unique resource identifier (URI). It is not necessarily a straight domain name (depends on the URI type enum)",
                NumElements = 120,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TransferType",
                Description = "The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Storage",
                Description = "The storage path the autopilot wants the URI to be stored in. Will only be valid if the transfer_type has a storage associated (e.g. MAVLink FTP).",
                NumElements = 120,
            });

        }

        private byte mRequestId;
        private byte mUriType;
        private byte[] mUri = new byte[120];
        private byte mTransferType;
        private byte[] mStorage = new byte[120];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Barometer readings for 3rd barometer
    /// </summary>
    public class UasScaledPressure3: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 14; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure
        /// </summary>
        public float PressAbs {
            get { return mPressAbs; }
            set { mPressAbs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure
        /// </summary>
        public float PressDiff {
            get { return mPressDiff; }
            set { mPressDiff = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure temperature
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        public UasScaledPressure3()
        {
            mMessageId = 143;
            CrcExtra = 131;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mPressAbs);
            s.Write(mPressDiff);
            s.Write(mTemperature);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mPressAbs = s.ReadSingle();
            this.mPressDiff = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Barometer readings for 3rd barometer"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressAbs",
                Description = "Absolute pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff",
                Description = "Differential pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Absolute pressure temperature",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mPressAbs;
        private float mPressDiff;
        private Int16 mTemperature;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Current motion information from a designated system
    /// </summary>
    public class UasFollowTarget: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 94; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt64 Timestamp {
            get { return mTimestamp; }
            set { mTimestamp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// button states or switches of a tracker device
        /// </summary>
        public UInt64 CustomState {
            get { return mCustomState; }
            set { mCustomState = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL)
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// target velocity (0,0,0) for unknown
        /// </summary>
        public float[] Vel {
            get { return mVel; }
            set { mVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// linear target acceleration (0,0,0) for unknown
        /// </summary>
        public float[] Acc {
            get { return mAcc; }
            set { mAcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// (0 0 0 0 for unknown)
        /// </summary>
        public float[] AttitudeQ {
            get { return mAttitudeQ; }
            set { mAttitudeQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// (0 0 0 for unknown)
        /// </summary>
        public float[] Rates {
            get { return mRates; }
            set { mRates = value; NotifyUpdated(); }
        }

        /// <summary>
        /// eph epv
        /// </summary>
        public float[] PositionCov {
            get { return mPositionCov; }
            set { mPositionCov = value; NotifyUpdated(); }
        }

        /// <summary>
        /// bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)
        /// </summary>
        public byte EstCapabilities {
            get { return mEstCapabilities; }
            set { mEstCapabilities = value; NotifyUpdated(); }
        }

        public UasFollowTarget()
        {
            mMessageId = 144;
            CrcExtra = 127;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimestamp);
            s.Write(mCustomState);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mVel[0]); 
            s.Write(mVel[1]); 
            s.Write(mVel[2]); 
            s.Write(mAcc[0]); 
            s.Write(mAcc[1]); 
            s.Write(mAcc[2]); 
            s.Write(mAttitudeQ[0]); 
            s.Write(mAttitudeQ[1]); 
            s.Write(mAttitudeQ[2]); 
            s.Write(mAttitudeQ[3]); 
            s.Write(mRates[0]); 
            s.Write(mRates[1]); 
            s.Write(mRates[2]); 
            s.Write(mPositionCov[0]); 
            s.Write(mPositionCov[1]); 
            s.Write(mPositionCov[2]); 
            s.Write(mEstCapabilities);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimestamp = s.ReadUInt64();
            this.mCustomState = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadSingle();
            this.mVel[0] = s.ReadSingle();
            this.mVel[1] = s.ReadSingle();
            this.mVel[2] = s.ReadSingle();
            this.mAcc[0] = s.ReadSingle();
            this.mAcc[1] = s.ReadSingle();
            this.mAcc[2] = s.ReadSingle();
            this.mAttitudeQ[0] = s.ReadSingle();
            this.mAttitudeQ[1] = s.ReadSingle();
            this.mAttitudeQ[2] = s.ReadSingle();
            this.mAttitudeQ[3] = s.ReadSingle();
            this.mRates[0] = s.ReadSingle();
            this.mRates[1] = s.ReadSingle();
            this.mRates[2] = s.ReadSingle();
            this.mPositionCov[0] = s.ReadSingle();
            this.mPositionCov[1] = s.ReadSingle();
            this.mPositionCov[2] = s.ReadSingle();
            this.mEstCapabilities = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Current motion information from a designated system"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Timestamp",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomState",
                Description = "button states or switches of a tracker device",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (MSL)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vel",
                Description = "target velocity (0,0,0) for unknown",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Acc",
                Description = "linear target acceleration (0,0,0) for unknown",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AttitudeQ",
                Description = "(0 0 0 0 for unknown)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rates",
                Description = "(0 0 0 for unknown)",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PositionCov",
                Description = "eph epv",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EstCapabilities",
                Description = "bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)",
                NumElements = 1,
            });

        }

        private UInt64 mTimestamp;
        private UInt64 mCustomState;
        private Int32 mLat;
        private Int32 mLon;
        private float mAlt;
        private float[] mVel = new float[3];
        private float[] mAcc = new float[3];
        private float[] mAttitudeQ = new float[4];
        private float[] mRates = new float[3];
        private float[] mPositionCov = new float[3];
        private byte mEstCapabilities;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The smoothed, monotonic system state used to feed the control loops of the system.
    /// </summary>
    public class UasControlSystemState: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 100; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration in body frame
        /// </summary>
        public float XAcc {
            get { return mXAcc; }
            set { mXAcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration in body frame
        /// </summary>
        public float YAcc {
            get { return mYAcc; }
            set { mYAcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration in body frame
        /// </summary>
        public float ZAcc {
            get { return mZAcc; }
            set { mZAcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in body frame
        /// </summary>
        public float XVel {
            get { return mXVel; }
            set { mXVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in body frame
        /// </summary>
        public float YVel {
            get { return mYVel; }
            set { mYVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in body frame
        /// </summary>
        public float ZVel {
            get { return mZVel; }
            set { mZVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X position in local frame
        /// </summary>
        public float XPos {
            get { return mXPos; }
            set { mXPos = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y position in local frame
        /// </summary>
        public float YPos {
            get { return mYPos; }
            set { mYPos = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z position in local frame
        /// </summary>
        public float ZPos {
            get { return mZPos; }
            set { mZPos = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Airspeed, set to -1 if unknown
        /// </summary>
        public float Airspeed {
            get { return mAirspeed; }
            set { mAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variance of body velocity estimate
        /// </summary>
        public float[] VelVariance {
            get { return mVelVariance; }
            set { mVelVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variance in local position
        /// </summary>
        public float[] PosVariance {
            get { return mPosVariance; }
            set { mPosVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The attitude, represented as Quaternion
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular rate in roll axis
        /// </summary>
        public float RollRate {
            get { return mRollRate; }
            set { mRollRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular rate in pitch axis
        /// </summary>
        public float PitchRate {
            get { return mPitchRate; }
            set { mPitchRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular rate in yaw axis
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        public UasControlSystemState()
        {
            mMessageId = 146;
            CrcExtra = 103;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mXAcc);
            s.Write(mYAcc);
            s.Write(mZAcc);
            s.Write(mXVel);
            s.Write(mYVel);
            s.Write(mZVel);
            s.Write(mXPos);
            s.Write(mYPos);
            s.Write(mZPos);
            s.Write(mAirspeed);
            s.Write(mVelVariance[0]); 
            s.Write(mVelVariance[1]); 
            s.Write(mVelVariance[2]); 
            s.Write(mPosVariance[0]); 
            s.Write(mPosVariance[1]); 
            s.Write(mPosVariance[2]); 
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mRollRate);
            s.Write(mPitchRate);
            s.Write(mYawRate);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mXAcc = s.ReadSingle();
            this.mYAcc = s.ReadSingle();
            this.mZAcc = s.ReadSingle();
            this.mXVel = s.ReadSingle();
            this.mYVel = s.ReadSingle();
            this.mZVel = s.ReadSingle();
            this.mXPos = s.ReadSingle();
            this.mYPos = s.ReadSingle();
            this.mZPos = s.ReadSingle();
            this.mAirspeed = s.ReadSingle();
            this.mVelVariance[0] = s.ReadSingle();
            this.mVelVariance[1] = s.ReadSingle();
            this.mVelVariance[2] = s.ReadSingle();
            this.mPosVariance[0] = s.ReadSingle();
            this.mPosVariance[1] = s.ReadSingle();
            this.mPosVariance[2] = s.ReadSingle();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mRollRate = s.ReadSingle();
            this.mPitchRate = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The smoothed, monotonic system state used to feed the control loops of the system."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "XAcc",
                Description = "X acceleration in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YAcc",
                Description = "Y acceleration in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ZAcc",
                Description = "Z acceleration in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "XVel",
                Description = "X velocity in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YVel",
                Description = "Y velocity in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ZVel",
                Description = "Z velocity in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "XPos",
                Description = "X position in local frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YPos",
                Description = "Y position in local frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ZPos",
                Description = "Z position in local frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Airspeed",
                Description = "Airspeed, set to -1 if unknown",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VelVariance",
                Description = "Variance of body velocity estimate",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosVariance",
                Description = "Variance in local position",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "The attitude, represented as Quaternion",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RollRate",
                Description = "Angular rate in roll axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PitchRate",
                Description = "Angular rate in pitch axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "Angular rate in yaw axis",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mXAcc;
        private float mYAcc;
        private float mZAcc;
        private float mXVel;
        private float mYVel;
        private float mZVel;
        private float mXPos;
        private float mYPos;
        private float mZPos;
        private float mAirspeed;
        private float[] mVelVariance = new float[3];
        private float[] mPosVariance = new float[3];
        private float[] mQ = new float[4];
        private float mRollRate;
        private float mPitchRate;
        private float mYawRate;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Battery information. Updates GCS with flight controller battery status. Smart batteries also use this message, but may additionally send SMART_BATTERY_INFO.
    /// </summary>
    public class UasBatteryStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 40; }
        }
        /// <summary>
        /// Consumed charge, -1: autopilot does not provide consumption estimate
        /// </summary>
        public Int32 CurrentConsumed {
            get { return mCurrentConsumed; }
            set { mCurrentConsumed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Consumed energy, -1: autopilot does not provide energy consumption estimate
        /// </summary>
        public Int32 EnergyConsumed {
            get { return mEnergyConsumed; }
            set { mEnergyConsumed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature of the battery. INT16_MAX for unknown temperature.
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery voltage of cells 1 to 10 (see voltages_ext for cells 11-14). Cells in this field above the valid cell count for this battery should have the UINT16_MAX value. If individual cell voltages are unknown or not measured for this battery, then the overall battery voltage should be filled in cell 0, with all others set to UINT16_MAX. If the voltage of the battery is greater than (UINT16_MAX - 1), then cell 0 should be set to (UINT16_MAX - 1), and cell 1 to the remaining voltage. This can be extended to multiple cells if the total voltage is greater than 2 * (UINT16_MAX - 1).
        /// </summary>
        public UInt16[] Voltages {
            get { return mVoltages; }
            set { mVoltages = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery current, -1: autopilot does not measure the current
        /// </summary>
        public Int16 CurrentBattery {
            get { return mCurrentBattery; }
            set { mCurrentBattery = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery ID
        /// </summary>
        public byte Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Function of the battery
        /// </summary>
        public MavBatteryFunction BatteryFunction {
            get { return mBatteryFunction; }
            set { mBatteryFunction = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type (chemistry) of the battery
        /// </summary>
        public MavBatteryType Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remaining battery energy. Values: [0-100], -1: autopilot does not estimate the remaining battery.
        /// </summary>
        public SByte BatteryRemaining {
            get { return mBatteryRemaining; }
            set { mBatteryRemaining = value; NotifyUpdated(); }
        }

        public UasBatteryStatus()
        {
            mMessageId = 147;
            CrcExtra = 154;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mCurrentConsumed);
            s.Write(mEnergyConsumed);
            s.Write(mTemperature);
            s.Write(mVoltages[0]); 
            s.Write(mVoltages[1]); 
            s.Write(mVoltages[2]); 
            s.Write(mVoltages[3]); 
            s.Write(mVoltages[4]); 
            s.Write(mVoltages[5]); 
            s.Write(mVoltages[6]); 
            s.Write(mVoltages[7]); 
            s.Write(mVoltages[8]); 
            s.Write(mVoltages[9]); 
            s.Write(mCurrentBattery);
            s.Write(mId);
            s.Write((byte)mBatteryFunction);
            s.Write((byte)mType);
            s.Write(mBatteryRemaining);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mCurrentConsumed = s.ReadInt32();
            this.mEnergyConsumed = s.ReadInt32();
            this.mTemperature = s.ReadInt16();
            this.mVoltages[0] = s.ReadUInt16();
            this.mVoltages[1] = s.ReadUInt16();
            this.mVoltages[2] = s.ReadUInt16();
            this.mVoltages[3] = s.ReadUInt16();
            this.mVoltages[4] = s.ReadUInt16();
            this.mVoltages[5] = s.ReadUInt16();
            this.mVoltages[6] = s.ReadUInt16();
            this.mVoltages[7] = s.ReadUInt16();
            this.mVoltages[8] = s.ReadUInt16();
            this.mVoltages[9] = s.ReadUInt16();
            this.mCurrentBattery = s.ReadInt16();
            this.mId = s.ReadByte();
            this.mBatteryFunction = (MavBatteryFunction)s.ReadByte();
            this.mType = (MavBatteryType)s.ReadByte();
            this.mBatteryRemaining = s.ReadSByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Battery information. Updates GCS with flight controller battery status. Smart batteries also use this message, but may additionally send SMART_BATTERY_INFO."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentConsumed",
                Description = "Consumed charge, -1: autopilot does not provide consumption estimate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EnergyConsumed",
                Description = "Consumed energy, -1: autopilot does not provide energy consumption estimate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature of the battery. INT16_MAX for unknown temperature.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Voltages",
                Description = "Battery voltage of cells 1 to 10 (see voltages_ext for cells 11-14). Cells in this field above the valid cell count for this battery should have the UINT16_MAX value. If individual cell voltages are unknown or not measured for this battery, then the overall battery voltage should be filled in cell 0, with all others set to UINT16_MAX. If the voltage of the battery is greater than (UINT16_MAX - 1), then cell 0 should be set to (UINT16_MAX - 1), and cell 1 to the remaining voltage. This can be extended to multiple cells if the total voltage is greater than 2 * (UINT16_MAX - 1).",
                NumElements = 10,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentBattery",
                Description = "Battery current, -1: autopilot does not measure the current",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Battery ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BatteryFunction",
                Description = "Function of the battery",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavBatteryFunction"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type (chemistry) of the battery",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavBatteryType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BatteryRemaining",
                Description = "Remaining battery energy. Values: [0-100], -1: autopilot does not estimate the remaining battery.",
                NumElements = 1,
            });

        }

        private Int32 mCurrentConsumed;
        private Int32 mEnergyConsumed;
        private Int16 mTemperature;
        private UInt16[] mVoltages = new UInt16[10];
        private Int16 mCurrentBattery;
        private byte mId;
        private MavBatteryFunction mBatteryFunction;
        private MavBatteryType mType;
        private SByte mBatteryRemaining;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Version and capability of autopilot software. This should be emitted in response to a request with MAV_CMD_REQUEST_MESSAGE.
    /// </summary>
    public class UasAutopilotVersion: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 84; }
        }
        /// <summary>
        /// Bitmap of capabilities
        /// </summary>
        public MavProtocolCapability Capabilities {
            get { return mCapabilities; }
            set { mCapabilities = value; NotifyUpdated(); }
        }

        /// <summary>
        /// UID if provided by hardware (see uid2)
        /// </summary>
        public UInt64 Uid {
            get { return mUid; }
            set { mUid = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Firmware version number
        /// </summary>
        public UInt32 FlightSwVersion {
            get { return mFlightSwVersion; }
            set { mFlightSwVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Middleware version number
        /// </summary>
        public UInt32 MiddlewareSwVersion {
            get { return mMiddlewareSwVersion; }
            set { mMiddlewareSwVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Operating system version number
        /// </summary>
        public UInt32 OsSwVersion {
            get { return mOsSwVersion; }
            set { mOsSwVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// HW / board version (last 8 bits should be silicon ID, if any). The first 16 bits of this field specify https://github.com/PX4/PX4-Bootloader/blob/master/board_types.txt
        /// </summary>
        public UInt32 BoardVersion {
            get { return mBoardVersion; }
            set { mBoardVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ID of the board vendor
        /// </summary>
        public UInt16 VendorId {
            get { return mVendorId; }
            set { mVendorId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ID of the product
        /// </summary>
        public UInt16 ProductId {
            get { return mProductId; }
            set { mProductId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
        /// </summary>
        public byte[] FlightCustomVersion {
            get { return mFlightCustomVersion; }
            set { mFlightCustomVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
        /// </summary>
        public byte[] MiddlewareCustomVersion {
            get { return mMiddlewareCustomVersion; }
            set { mMiddlewareCustomVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
        /// </summary>
        public byte[] OsCustomVersion {
            get { return mOsCustomVersion; }
            set { mOsCustomVersion = value; NotifyUpdated(); }
        }

        public UasAutopilotVersion()
        {
            mMessageId = 148;
            CrcExtra = 178;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write((UInt64)mCapabilities);
            s.Write(mUid);
            s.Write(mFlightSwVersion);
            s.Write(mMiddlewareSwVersion);
            s.Write(mOsSwVersion);
            s.Write(mBoardVersion);
            s.Write(mVendorId);
            s.Write(mProductId);
            s.Write(mFlightCustomVersion[0]); 
            s.Write(mFlightCustomVersion[1]); 
            s.Write(mFlightCustomVersion[2]); 
            s.Write(mFlightCustomVersion[3]); 
            s.Write(mFlightCustomVersion[4]); 
            s.Write(mFlightCustomVersion[5]); 
            s.Write(mFlightCustomVersion[6]); 
            s.Write(mFlightCustomVersion[7]); 
            s.Write(mMiddlewareCustomVersion[0]); 
            s.Write(mMiddlewareCustomVersion[1]); 
            s.Write(mMiddlewareCustomVersion[2]); 
            s.Write(mMiddlewareCustomVersion[3]); 
            s.Write(mMiddlewareCustomVersion[4]); 
            s.Write(mMiddlewareCustomVersion[5]); 
            s.Write(mMiddlewareCustomVersion[6]); 
            s.Write(mMiddlewareCustomVersion[7]); 
            s.Write(mOsCustomVersion[0]); 
            s.Write(mOsCustomVersion[1]); 
            s.Write(mOsCustomVersion[2]); 
            s.Write(mOsCustomVersion[3]); 
            s.Write(mOsCustomVersion[4]); 
            s.Write(mOsCustomVersion[5]); 
            s.Write(mOsCustomVersion[6]); 
            s.Write(mOsCustomVersion[7]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mCapabilities = (MavProtocolCapability)s.ReadUInt64();
            this.mUid = s.ReadUInt64();
            this.mFlightSwVersion = s.ReadUInt32();
            this.mMiddlewareSwVersion = s.ReadUInt32();
            this.mOsSwVersion = s.ReadUInt32();
            this.mBoardVersion = s.ReadUInt32();
            this.mVendorId = s.ReadUInt16();
            this.mProductId = s.ReadUInt16();
            this.mFlightCustomVersion[0] = s.ReadByte();
            this.mFlightCustomVersion[1] = s.ReadByte();
            this.mFlightCustomVersion[2] = s.ReadByte();
            this.mFlightCustomVersion[3] = s.ReadByte();
            this.mFlightCustomVersion[4] = s.ReadByte();
            this.mFlightCustomVersion[5] = s.ReadByte();
            this.mFlightCustomVersion[6] = s.ReadByte();
            this.mFlightCustomVersion[7] = s.ReadByte();
            this.mMiddlewareCustomVersion[0] = s.ReadByte();
            this.mMiddlewareCustomVersion[1] = s.ReadByte();
            this.mMiddlewareCustomVersion[2] = s.ReadByte();
            this.mMiddlewareCustomVersion[3] = s.ReadByte();
            this.mMiddlewareCustomVersion[4] = s.ReadByte();
            this.mMiddlewareCustomVersion[5] = s.ReadByte();
            this.mMiddlewareCustomVersion[6] = s.ReadByte();
            this.mMiddlewareCustomVersion[7] = s.ReadByte();
            this.mOsCustomVersion[0] = s.ReadByte();
            this.mOsCustomVersion[1] = s.ReadByte();
            this.mOsCustomVersion[2] = s.ReadByte();
            this.mOsCustomVersion[3] = s.ReadByte();
            this.mOsCustomVersion[4] = s.ReadByte();
            this.mOsCustomVersion[5] = s.ReadByte();
            this.mOsCustomVersion[6] = s.ReadByte();
            this.mOsCustomVersion[7] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Version and capability of autopilot software. This should be emitted in response to a request with MAV_CMD_REQUEST_MESSAGE."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Capabilities",
                Description = "Bitmap of capabilities",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavProtocolCapability"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Uid",
                Description = "UID if provided by hardware (see uid2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlightSwVersion",
                Description = "Firmware version number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MiddlewareSwVersion",
                Description = "Middleware version number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OsSwVersion",
                Description = "Operating system version number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BoardVersion",
                Description = "HW / board version (last 8 bits should be silicon ID, if any). The first 16 bits of this field specify https://github.com/PX4/PX4-Bootloader/blob/master/board_types.txt",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VendorId",
                Description = "ID of the board vendor",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ProductId",
                Description = "ID of the product",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlightCustomVersion",
                Description = "Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.",
                NumElements = 8,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MiddlewareCustomVersion",
                Description = "Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.",
                NumElements = 8,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OsCustomVersion",
                Description = "Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.",
                NumElements = 8,
            });

        }

        private MavProtocolCapability mCapabilities;
        private UInt64 mUid;
        private UInt32 mFlightSwVersion;
        private UInt32 mMiddlewareSwVersion;
        private UInt32 mOsSwVersion;
        private UInt32 mBoardVersion;
        private UInt16 mVendorId;
        private UInt16 mProductId;
        private byte[] mFlightCustomVersion = new byte[8];
        private byte[] mMiddlewareCustomVersion = new byte[8];
        private byte[] mOsCustomVersion = new byte[8];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The location of a landing target. See: https://mavlink.io/en/services/landing_target.html
    /// </summary>
    public class UasLandingTarget: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X-axis angular offset of the target from the center of the image
        /// </summary>
        public float AngleX {
            get { return mAngleX; }
            set { mAngleX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y-axis angular offset of the target from the center of the image
        /// </summary>
        public float AngleY {
            get { return mAngleY; }
            set { mAngleY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to the target from the vehicle
        /// </summary>
        public float Distance {
            get { return mDistance; }
            set { mDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Size of target along x-axis
        /// </summary>
        public float SizeX {
            get { return mSizeX; }
            set { mSizeX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Size of target along y-axis
        /// </summary>
        public float SizeY {
            get { return mSizeY; }
            set { mSizeY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The ID of the target if multiple targets are present
        /// </summary>
        public byte TargetNum {
            get { return mTargetNum; }
            set { mTargetNum = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate frame used for following fields.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        public UasLandingTarget()
        {
            mMessageId = 149;
            CrcExtra = 200;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mAngleX);
            s.Write(mAngleY);
            s.Write(mDistance);
            s.Write(mSizeX);
            s.Write(mSizeY);
            s.Write(mTargetNum);
            s.Write((byte)mFrame);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mAngleX = s.ReadSingle();
            this.mAngleY = s.ReadSingle();
            this.mDistance = s.ReadSingle();
            this.mSizeX = s.ReadSingle();
            this.mSizeY = s.ReadSingle();
            this.mTargetNum = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The location of a landing target. See: https://mavlink.io/en/services/landing_target.html"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AngleX",
                Description = "X-axis angular offset of the target from the center of the image",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AngleY",
                Description = "Y-axis angular offset of the target from the center of the image",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Distance",
                Description = "Distance to the target from the vehicle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SizeX",
                Description = "Size of target along x-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SizeY",
                Description = "Size of target along y-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetNum",
                Description = "The ID of the target if multiple targets are present",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "Coordinate frame used for following fields.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt64 mTimeUsec;
        private float mAngleX;
        private float mAngleY;
        private float mDistance;
        private float mSizeX;
        private float mSizeY;
        private byte mTargetNum;
        private MavFrame mFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of geo-fencing. Sent in extended status stream when fencing enabled.
    /// </summary>
    public class UasFenceStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 10; }
        }
        /// <summary>
        /// Time (since boot) of last breach.
        /// </summary>
        public UInt32 BreachTime {
            get { return mBreachTime; }
            set { mBreachTime = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of fence breaches.
        /// </summary>
        public UInt16 BreachCount {
            get { return mBreachCount; }
            set { mBreachCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Breach status (0 if currently inside fence, 1 if outside).
        /// </summary>
        public byte BreachStatus {
            get { return mBreachStatus; }
            set { mBreachStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Last breach type.
        /// </summary>
        public FenceBreach BreachType {
            get { return mBreachType; }
            set { mBreachType = value; NotifyUpdated(); }
        }

        public UasFenceStatus()
        {
            mMessageId = 162;
            CrcExtra = 189;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mBreachTime);
            s.Write(mBreachCount);
            s.Write(mBreachStatus);
            s.Write((byte)mBreachType);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mBreachTime = s.ReadUInt32();
            this.mBreachCount = s.ReadUInt16();
            this.mBreachStatus = s.ReadByte();
            this.mBreachType = (FenceBreach)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of geo-fencing. Sent in extended status stream when fencing enabled."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachTime",
                Description = "Time (since boot) of last breach.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachCount",
                Description = "Number of fence breaches.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachStatus",
                Description = "Breach status (0 if currently inside fence, 1 if outside).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachType",
                Description = "Last breach type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("FenceBreach"),
            });

        }

        private UInt32 mBreachTime;
        private UInt16 mBreachCount;
        private byte mBreachStatus;
        private FenceBreach mBreachType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports results of completed compass calibration. Sent until MAG_CAL_ACK received.
    /// </summary>
    public class UasMagCalReport: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 48; }
        }
        /// <summary>
        /// RMS milligauss residuals.
        /// </summary>
        public float Fitness {
            get { return mFitness; }
            set { mFitness = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X offset.
        /// </summary>
        public float OfsX {
            get { return mOfsX; }
            set { mOfsX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y offset.
        /// </summary>
        public float OfsY {
            get { return mOfsY; }
            set { mOfsY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z offset.
        /// </summary>
        public float OfsZ {
            get { return mOfsZ; }
            set { mOfsZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X diagonal (matrix 11).
        /// </summary>
        public float DiagX {
            get { return mDiagX; }
            set { mDiagX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y diagonal (matrix 22).
        /// </summary>
        public float DiagY {
            get { return mDiagY; }
            set { mDiagY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z diagonal (matrix 33).
        /// </summary>
        public float DiagZ {
            get { return mDiagZ; }
            set { mDiagZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X off-diagonal (matrix 12 and 21).
        /// </summary>
        public float OffdiagX {
            get { return mOffdiagX; }
            set { mOffdiagX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y off-diagonal (matrix 13 and 31).
        /// </summary>
        public float OffdiagY {
            get { return mOffdiagY; }
            set { mOffdiagY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z off-diagonal (matrix 32 and 23).
        /// </summary>
        public float OffdiagZ {
            get { return mOffdiagZ; }
            set { mOffdiagZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Compass being calibrated.
        /// </summary>
        public byte CompassId {
            get { return mCompassId; }
            set { mCompassId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask of compasses being calibrated.
        /// </summary>
        public byte CalMask {
            get { return mCalMask; }
            set { mCalMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Calibration Status.
        /// </summary>
        public MagCalStatus CalStatus {
            get { return mCalStatus; }
            set { mCalStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters.
        /// </summary>
        public byte Autosaved {
            get { return mAutosaved; }
            set { mAutosaved = value; NotifyUpdated(); }
        }

        public UasMagCalReport()
        {
            mMessageId = 192;
            CrcExtra = 36;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mFitness);
            s.Write(mOfsX);
            s.Write(mOfsY);
            s.Write(mOfsZ);
            s.Write(mDiagX);
            s.Write(mDiagY);
            s.Write(mDiagZ);
            s.Write(mOffdiagX);
            s.Write(mOffdiagY);
            s.Write(mOffdiagZ);
            s.Write(mCompassId);
            s.Write(mCalMask);
            s.Write((byte)mCalStatus);
            s.Write(mAutosaved);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mFitness = s.ReadSingle();
            this.mOfsX = s.ReadSingle();
            this.mOfsY = s.ReadSingle();
            this.mOfsZ = s.ReadSingle();
            this.mDiagX = s.ReadSingle();
            this.mDiagY = s.ReadSingle();
            this.mDiagZ = s.ReadSingle();
            this.mOffdiagX = s.ReadSingle();
            this.mOffdiagY = s.ReadSingle();
            this.mOffdiagZ = s.ReadSingle();
            this.mCompassId = s.ReadByte();
            this.mCalMask = s.ReadByte();
            this.mCalStatus = (MagCalStatus)s.ReadByte();
            this.mAutosaved = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports results of completed compass calibration. Sent until MAG_CAL_ACK received."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Fitness",
                Description = "RMS milligauss residuals.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OfsX",
                Description = "X offset.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OfsY",
                Description = "Y offset.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OfsZ",
                Description = "Z offset.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiagX",
                Description = "X diagonal (matrix 11).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiagY",
                Description = "Y diagonal (matrix 22).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiagZ",
                Description = "Z diagonal (matrix 33).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OffdiagX",
                Description = "X off-diagonal (matrix 12 and 21).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OffdiagY",
                Description = "Y off-diagonal (matrix 13 and 31).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OffdiagZ",
                Description = "Z off-diagonal (matrix 32 and 23).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CompassId",
                Description = "Compass being calibrated.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CalMask",
                Description = "Bitmask of compasses being calibrated.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CalStatus",
                Description = "Calibration Status.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MagCalStatus"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autosaved",
                Description = "0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters.",
                NumElements = 1,
            });

        }

        private float mFitness;
        private float mOfsX;
        private float mOfsY;
        private float mOfsZ;
        private float mDiagX;
        private float mDiagY;
        private float mDiagZ;
        private float mOffdiagX;
        private float mOffdiagY;
        private float mOffdiagZ;
        private byte mCompassId;
        private byte mCalMask;
        private MagCalStatus mCalStatus;
        private byte mAutosaved;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// EFI status output
    /// </summary>
    public class UasEfiStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 66; }
        }
        /// <summary>
        /// ECU index
        /// </summary>
        public float EcuIndex {
            get { return mEcuIndex; }
            set { mEcuIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RPM
        /// </summary>
        public float Rpm {
            get { return mRpm; }
            set { mRpm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Fuel consumed
        /// </summary>
        public float FuelConsumed {
            get { return mFuelConsumed; }
            set { mFuelConsumed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Fuel flow rate
        /// </summary>
        public float FuelFlow {
            get { return mFuelFlow; }
            set { mFuelFlow = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Engine load
        /// </summary>
        public float EngineLoad {
            get { return mEngineLoad; }
            set { mEngineLoad = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Throttle position
        /// </summary>
        public float ThrottlePosition {
            get { return mThrottlePosition; }
            set { mThrottlePosition = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Spark dwell time
        /// </summary>
        public float SparkDwellTime {
            get { return mSparkDwellTime; }
            set { mSparkDwellTime = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Barometric pressure
        /// </summary>
        public float BarometricPressure {
            get { return mBarometricPressure; }
            set { mBarometricPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Intake manifold pressure(
        /// </summary>
        public float IntakeManifoldPressure {
            get { return mIntakeManifoldPressure; }
            set { mIntakeManifoldPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Intake manifold temperature
        /// </summary>
        public float IntakeManifoldTemperature {
            get { return mIntakeManifoldTemperature; }
            set { mIntakeManifoldTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Cylinder head temperature
        /// </summary>
        public float CylinderHeadTemperature {
            get { return mCylinderHeadTemperature; }
            set { mCylinderHeadTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ignition timing (Crank angle degrees)
        /// </summary>
        public float IgnitionTiming {
            get { return mIgnitionTiming; }
            set { mIgnitionTiming = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Injection time
        /// </summary>
        public float InjectionTime {
            get { return mInjectionTime; }
            set { mInjectionTime = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Exhaust gas temperature
        /// </summary>
        public float ExhaustGasTemperature {
            get { return mExhaustGasTemperature; }
            set { mExhaustGasTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Output throttle
        /// </summary>
        public float ThrottleOut {
            get { return mThrottleOut; }
            set { mThrottleOut = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pressure/temperature compensation
        /// </summary>
        public float PtCompensation {
            get { return mPtCompensation; }
            set { mPtCompensation = value; NotifyUpdated(); }
        }

        /// <summary>
        /// EFI health status
        /// </summary>
        public byte Health {
            get { return mHealth; }
            set { mHealth = value; NotifyUpdated(); }
        }

        public UasEfiStatus()
        {
            mMessageId = 225;
            CrcExtra = 208;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mEcuIndex);
            s.Write(mRpm);
            s.Write(mFuelConsumed);
            s.Write(mFuelFlow);
            s.Write(mEngineLoad);
            s.Write(mThrottlePosition);
            s.Write(mSparkDwellTime);
            s.Write(mBarometricPressure);
            s.Write(mIntakeManifoldPressure);
            s.Write(mIntakeManifoldTemperature);
            s.Write(mCylinderHeadTemperature);
            s.Write(mIgnitionTiming);
            s.Write(mInjectionTime);
            s.Write(mExhaustGasTemperature);
            s.Write(mThrottleOut);
            s.Write(mPtCompensation);
            s.Write(mHealth);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mEcuIndex = s.ReadSingle();
            this.mRpm = s.ReadSingle();
            this.mFuelConsumed = s.ReadSingle();
            this.mFuelFlow = s.ReadSingle();
            this.mEngineLoad = s.ReadSingle();
            this.mThrottlePosition = s.ReadSingle();
            this.mSparkDwellTime = s.ReadSingle();
            this.mBarometricPressure = s.ReadSingle();
            this.mIntakeManifoldPressure = s.ReadSingle();
            this.mIntakeManifoldTemperature = s.ReadSingle();
            this.mCylinderHeadTemperature = s.ReadSingle();
            this.mIgnitionTiming = s.ReadSingle();
            this.mInjectionTime = s.ReadSingle();
            this.mExhaustGasTemperature = s.ReadSingle();
            this.mThrottleOut = s.ReadSingle();
            this.mPtCompensation = s.ReadSingle();
            this.mHealth = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "EFI status output"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EcuIndex",
                Description = "ECU index",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rpm",
                Description = "RPM",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FuelConsumed",
                Description = "Fuel consumed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FuelFlow",
                Description = "Fuel flow rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EngineLoad",
                Description = "Engine load",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ThrottlePosition",
                Description = "Throttle position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SparkDwellTime",
                Description = "Spark dwell time",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BarometricPressure",
                Description = "Barometric pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntakeManifoldPressure",
                Description = "Intake manifold pressure(",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntakeManifoldTemperature",
                Description = "Intake manifold temperature",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CylinderHeadTemperature",
                Description = "Cylinder head temperature",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IgnitionTiming",
                Description = "Ignition timing (Crank angle degrees)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "InjectionTime",
                Description = "Injection time",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ExhaustGasTemperature",
                Description = "Exhaust gas temperature",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ThrottleOut",
                Description = "Output throttle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PtCompensation",
                Description = "Pressure/temperature compensation",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Health",
                Description = "EFI health status",
                NumElements = 1,
            });

        }

        private float mEcuIndex;
        private float mRpm;
        private float mFuelConsumed;
        private float mFuelFlow;
        private float mEngineLoad;
        private float mThrottlePosition;
        private float mSparkDwellTime;
        private float mBarometricPressure;
        private float mIntakeManifoldPressure;
        private float mIntakeManifoldTemperature;
        private float mCylinderHeadTemperature;
        private float mIgnitionTiming;
        private float mInjectionTime;
        private float mExhaustGasTemperature;
        private float mThrottleOut;
        private float mPtCompensation;
        private byte mHealth;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS enum definition for further information. The innovation test ratios show the magnitude of the sensor innovation divided by the innovation check threshold. Under normal operation the innovation test ratios should be below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should be optional and controllable by the user.
    /// </summary>
    public class UasEstimatorStatus: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 42; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Velocity innovation test ratio
        /// </summary>
        public float VelRatio {
            get { return mVelRatio; }
            set { mVelRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal position innovation test ratio
        /// </summary>
        public float PosHorizRatio {
            get { return mPosHorizRatio; }
            set { mPosHorizRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical position innovation test ratio
        /// </summary>
        public float PosVertRatio {
            get { return mPosVertRatio; }
            set { mPosVertRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Magnetometer innovation test ratio
        /// </summary>
        public float MagRatio {
            get { return mMagRatio; }
            set { mMagRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Height above terrain innovation test ratio
        /// </summary>
        public float HaglRatio {
            get { return mHaglRatio; }
            set { mHaglRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True airspeed innovation test ratio
        /// </summary>
        public float TasRatio {
            get { return mTasRatio; }
            set { mTasRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal position 1-STD accuracy relative to the EKF local origin
        /// </summary>
        public float PosHorizAccuracy {
            get { return mPosHorizAccuracy; }
            set { mPosHorizAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical position 1-STD accuracy relative to the EKF local origin
        /// </summary>
        public float PosVertAccuracy {
            get { return mPosVertAccuracy; }
            set { mPosVertAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap indicating which EKF outputs are valid.
        /// </summary>
        public EstimatorStatusFlags Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        public UasEstimatorStatus()
        {
            mMessageId = 230;
            CrcExtra = 163;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mVelRatio);
            s.Write(mPosHorizRatio);
            s.Write(mPosVertRatio);
            s.Write(mMagRatio);
            s.Write(mHaglRatio);
            s.Write(mTasRatio);
            s.Write(mPosHorizAccuracy);
            s.Write(mPosVertAccuracy);
            s.Write((UInt16)mFlags);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mVelRatio = s.ReadSingle();
            this.mPosHorizRatio = s.ReadSingle();
            this.mPosVertRatio = s.ReadSingle();
            this.mMagRatio = s.ReadSingle();
            this.mHaglRatio = s.ReadSingle();
            this.mTasRatio = s.ReadSingle();
            this.mPosHorizAccuracy = s.ReadSingle();
            this.mPosVertAccuracy = s.ReadSingle();
            this.mFlags = (EstimatorStatusFlags)s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS enum definition for further information. The innovation test ratios show the magnitude of the sensor innovation divided by the innovation check threshold. Under normal operation the innovation test ratios should be below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should be optional and controllable by the user."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VelRatio",
                Description = "Velocity innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosHorizRatio",
                Description = "Horizontal position innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosVertRatio",
                Description = "Vertical position innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagRatio",
                Description = "Magnetometer innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HaglRatio",
                Description = "Height above terrain innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TasRatio",
                Description = "True airspeed innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosHorizAccuracy",
                Description = "Horizontal position 1-STD accuracy relative to the EKF local origin",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosVertAccuracy",
                Description = "Vertical position 1-STD accuracy relative to the EKF local origin",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "Bitmap indicating which EKF outputs are valid.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("EstimatorStatusFlags"),
            });

        }

        private UInt64 mTimeUsec;
        private float mVelRatio;
        private float mPosHorizRatio;
        private float mPosVertRatio;
        private float mMagRatio;
        private float mHaglRatio;
        private float mTasRatio;
        private float mPosHorizAccuracy;
        private float mPosVertAccuracy;
        private EstimatorStatusFlags mFlags;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Wind covariance estimate from vehicle.
    /// </summary>
    public class UasWindCov: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 40; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Wind in X (NED) direction
        /// </summary>
        public float WindX {
            get { return mWindX; }
            set { mWindX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Wind in Y (NED) direction
        /// </summary>
        public float WindY {
            get { return mWindY; }
            set { mWindY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Wind in Z (NED) direction
        /// </summary>
        public float WindZ {
            get { return mWindZ; }
            set { mWindZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.
        /// </summary>
        public float VarHoriz {
            get { return mVarHoriz; }
            set { mVarHoriz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.
        /// </summary>
        public float VarVert {
            get { return mVarVert; }
            set { mVarVert = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL) that this measurement was taken at
        /// </summary>
        public float WindAlt {
            get { return mWindAlt; }
            set { mWindAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal speed 1-STD accuracy
        /// </summary>
        public float HorizAccuracy {
            get { return mHorizAccuracy; }
            set { mHorizAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical speed 1-STD accuracy
        /// </summary>
        public float VertAccuracy {
            get { return mVertAccuracy; }
            set { mVertAccuracy = value; NotifyUpdated(); }
        }

        public UasWindCov()
        {
            mMessageId = 231;
            CrcExtra = 105;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mWindX);
            s.Write(mWindY);
            s.Write(mWindZ);
            s.Write(mVarHoriz);
            s.Write(mVarVert);
            s.Write(mWindAlt);
            s.Write(mHorizAccuracy);
            s.Write(mVertAccuracy);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mWindX = s.ReadSingle();
            this.mWindY = s.ReadSingle();
            this.mWindZ = s.ReadSingle();
            this.mVarHoriz = s.ReadSingle();
            this.mVarVert = s.ReadSingle();
            this.mWindAlt = s.ReadSingle();
            this.mHorizAccuracy = s.ReadSingle();
            this.mVertAccuracy = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Wind covariance estimate from vehicle."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindX",
                Description = "Wind in X (NED) direction",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindY",
                Description = "Wind in Y (NED) direction",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindZ",
                Description = "Wind in Z (NED) direction",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VarHoriz",
                Description = "Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VarVert",
                Description = "Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindAlt",
                Description = "Altitude (MSL) that this measurement was taken at",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HorizAccuracy",
                Description = "Horizontal speed 1-STD accuracy",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VertAccuracy",
                Description = "Vertical speed 1-STD accuracy",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mWindX;
        private float mWindY;
        private float mWindZ;
        private float mVarHoriz;
        private float mVarVert;
        private float mWindAlt;
        private float mHorizAccuracy;
        private float mVertAccuracy;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position estimate of the system.
    /// </summary>
    public class UasGpsInput: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 66; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS time (from start of GPS week)
        /// </summary>
        public UInt32 TimeWeekMs {
            get { return mTimeWeekMs; }
            set { mTimeWeekMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Positive for up.
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS HDOP horizontal dilution of position (unitless). If unknown, set to: UINT16_MAX
        /// </summary>
        public float Hdop {
            get { return mHdop; }
            set { mHdop = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS VDOP vertical dilution of position (unitless). If unknown, set to: UINT16_MAX
        /// </summary>
        public float Vdop {
            get { return mVdop; }
            set { mVdop = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in north direction in earth-fixed NED frame
        /// </summary>
        public float Vn {
            get { return mVn; }
            set { mVn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in east direction in earth-fixed NED frame
        /// </summary>
        public float Ve {
            get { return mVe; }
            set { mVe = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in down direction in earth-fixed NED frame
        /// </summary>
        public float Vd {
            get { return mVd; }
            set { mVd = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS speed accuracy
        /// </summary>
        public float SpeedAccuracy {
            get { return mSpeedAccuracy; }
            set { mSpeedAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS horizontal accuracy
        /// </summary>
        public float HorizAccuracy {
            get { return mHorizAccuracy; }
            set { mHorizAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS vertical accuracy
        /// </summary>
        public float VertAccuracy {
            get { return mVertAccuracy; }
            set { mVertAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap indicating which GPS input flags fields to ignore.  All other fields must be provided.
        /// </summary>
        public GpsInputIgnoreFlags IgnoreFlags {
            get { return mIgnoreFlags; }
            set { mIgnoreFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS week number
        /// </summary>
        public UInt16 TimeWeek {
            get { return mTimeWeek; }
            set { mTimeWeek = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ID of the GPS for multiple GPS inputs
        /// </summary>
        public byte GpsId {
            get { return mGpsId; }
            set { mGpsId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK
        /// </summary>
        public byte FixType {
            get { return mFixType; }
            set { mFixType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of satellites visible.
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        public UasGpsInput()
        {
            mMessageId = 232;
            CrcExtra = 151;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mTimeWeekMs);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mHdop);
            s.Write(mVdop);
            s.Write(mVn);
            s.Write(mVe);
            s.Write(mVd);
            s.Write(mSpeedAccuracy);
            s.Write(mHorizAccuracy);
            s.Write(mVertAccuracy);
            s.Write((UInt16)mIgnoreFlags);
            s.Write(mTimeWeek);
            s.Write(mGpsId);
            s.Write(mFixType);
            s.Write(mSatellitesVisible);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mTimeWeekMs = s.ReadUInt32();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadSingle();
            this.mHdop = s.ReadSingle();
            this.mVdop = s.ReadSingle();
            this.mVn = s.ReadSingle();
            this.mVe = s.ReadSingle();
            this.mVd = s.ReadSingle();
            this.mSpeedAccuracy = s.ReadSingle();
            this.mHorizAccuracy = s.ReadSingle();
            this.mVertAccuracy = s.ReadSingle();
            this.mIgnoreFlags = (GpsInputIgnoreFlags)s.ReadUInt16();
            this.mTimeWeek = s.ReadUInt16();
            this.mGpsId = s.ReadByte();
            this.mFixType = s.ReadByte();
            this.mSatellitesVisible = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position estimate of the system."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeWeekMs",
                Description = "GPS time (from start of GPS week)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (MSL). Positive for up.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Hdop",
                Description = "GPS HDOP horizontal dilution of position (unitless). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vdop",
                Description = "GPS VDOP vertical dilution of position (unitless). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vn",
                Description = "GPS velocity in north direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ve",
                Description = "GPS velocity in east direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vd",
                Description = "GPS velocity in down direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SpeedAccuracy",
                Description = "GPS speed accuracy",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HorizAccuracy",
                Description = "GPS horizontal accuracy",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VertAccuracy",
                Description = "GPS vertical accuracy",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IgnoreFlags",
                Description = "Bitmap indicating which GPS input flags fields to ignore.  All other fields must be provided.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("GpsInputIgnoreFlags"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeWeek",
                Description = "GPS week number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GpsId",
                Description = "ID of the GPS for multiple GPS inputs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FixType",
                Description = "0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mTimeWeekMs;
        private Int32 mLat;
        private Int32 mLon;
        private float mAlt;
        private float mHdop;
        private float mVdop;
        private float mVn;
        private float mVe;
        private float mVd;
        private float mSpeedAccuracy;
        private float mHorizAccuracy;
        private float mVertAccuracy;
        private GpsInputIgnoreFlags mIgnoreFlags;
        private UInt16 mTimeWeek;
        private byte mGpsId;
        private byte mFixType;
        private byte mSatellitesVisible;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// RTCM message for injecting into the onboard GPS (used for DGPS)
    /// </summary>
    public class UasGpsRtcmData: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 364; }
        }
        /// <summary>
        /// LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.
        /// </summary>
        public byte Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// data length
        /// </summary>
        public byte Len {
            get { return mLen; }
            set { mLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RTCM message (may be fragmented)
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasGpsRtcmData()
        {
            mMessageId = 233;
            CrcExtra = 35;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mFlags);
            s.Write(mLen);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
            s.Write(mData[90]); 
            s.Write(mData[91]); 
            s.Write(mData[92]); 
            s.Write(mData[93]); 
            s.Write(mData[94]); 
            s.Write(mData[95]); 
            s.Write(mData[96]); 
            s.Write(mData[97]); 
            s.Write(mData[98]); 
            s.Write(mData[99]); 
            s.Write(mData[100]); 
            s.Write(mData[101]); 
            s.Write(mData[102]); 
            s.Write(mData[103]); 
            s.Write(mData[104]); 
            s.Write(mData[105]); 
            s.Write(mData[106]); 
            s.Write(mData[107]); 
            s.Write(mData[108]); 
            s.Write(mData[109]); 
            s.Write(mData[110]); 
            s.Write(mData[111]); 
            s.Write(mData[112]); 
            s.Write(mData[113]); 
            s.Write(mData[114]); 
            s.Write(mData[115]); 
            s.Write(mData[116]); 
            s.Write(mData[117]); 
            s.Write(mData[118]); 
            s.Write(mData[119]); 
            s.Write(mData[120]); 
            s.Write(mData[121]); 
            s.Write(mData[122]); 
            s.Write(mData[123]); 
            s.Write(mData[124]); 
            s.Write(mData[125]); 
            s.Write(mData[126]); 
            s.Write(mData[127]); 
            s.Write(mData[128]); 
            s.Write(mData[129]); 
            s.Write(mData[130]); 
            s.Write(mData[131]); 
            s.Write(mData[132]); 
            s.Write(mData[133]); 
            s.Write(mData[134]); 
            s.Write(mData[135]); 
            s.Write(mData[136]); 
            s.Write(mData[137]); 
            s.Write(mData[138]); 
            s.Write(mData[139]); 
            s.Write(mData[140]); 
            s.Write(mData[141]); 
            s.Write(mData[142]); 
            s.Write(mData[143]); 
            s.Write(mData[144]); 
            s.Write(mData[145]); 
            s.Write(mData[146]); 
            s.Write(mData[147]); 
            s.Write(mData[148]); 
            s.Write(mData[149]); 
            s.Write(mData[150]); 
            s.Write(mData[151]); 
            s.Write(mData[152]); 
            s.Write(mData[153]); 
            s.Write(mData[154]); 
            s.Write(mData[155]); 
            s.Write(mData[156]); 
            s.Write(mData[157]); 
            s.Write(mData[158]); 
            s.Write(mData[159]); 
            s.Write(mData[160]); 
            s.Write(mData[161]); 
            s.Write(mData[162]); 
            s.Write(mData[163]); 
            s.Write(mData[164]); 
            s.Write(mData[165]); 
            s.Write(mData[166]); 
            s.Write(mData[167]); 
            s.Write(mData[168]); 
            s.Write(mData[169]); 
            s.Write(mData[170]); 
            s.Write(mData[171]); 
            s.Write(mData[172]); 
            s.Write(mData[173]); 
            s.Write(mData[174]); 
            s.Write(mData[175]); 
            s.Write(mData[176]); 
            s.Write(mData[177]); 
            s.Write(mData[178]); 
            s.Write(mData[179]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mFlags = s.ReadByte();
            this.mLen = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
            this.mData[90] = s.ReadByte();
            this.mData[91] = s.ReadByte();
            this.mData[92] = s.ReadByte();
            this.mData[93] = s.ReadByte();
            this.mData[94] = s.ReadByte();
            this.mData[95] = s.ReadByte();
            this.mData[96] = s.ReadByte();
            this.mData[97] = s.ReadByte();
            this.mData[98] = s.ReadByte();
            this.mData[99] = s.ReadByte();
            this.mData[100] = s.ReadByte();
            this.mData[101] = s.ReadByte();
            this.mData[102] = s.ReadByte();
            this.mData[103] = s.ReadByte();
            this.mData[104] = s.ReadByte();
            this.mData[105] = s.ReadByte();
            this.mData[106] = s.ReadByte();
            this.mData[107] = s.ReadByte();
            this.mData[108] = s.ReadByte();
            this.mData[109] = s.ReadByte();
            this.mData[110] = s.ReadByte();
            this.mData[111] = s.ReadByte();
            this.mData[112] = s.ReadByte();
            this.mData[113] = s.ReadByte();
            this.mData[114] = s.ReadByte();
            this.mData[115] = s.ReadByte();
            this.mData[116] = s.ReadByte();
            this.mData[117] = s.ReadByte();
            this.mData[118] = s.ReadByte();
            this.mData[119] = s.ReadByte();
            this.mData[120] = s.ReadByte();
            this.mData[121] = s.ReadByte();
            this.mData[122] = s.ReadByte();
            this.mData[123] = s.ReadByte();
            this.mData[124] = s.ReadByte();
            this.mData[125] = s.ReadByte();
            this.mData[126] = s.ReadByte();
            this.mData[127] = s.ReadByte();
            this.mData[128] = s.ReadByte();
            this.mData[129] = s.ReadByte();
            this.mData[130] = s.ReadByte();
            this.mData[131] = s.ReadByte();
            this.mData[132] = s.ReadByte();
            this.mData[133] = s.ReadByte();
            this.mData[134] = s.ReadByte();
            this.mData[135] = s.ReadByte();
            this.mData[136] = s.ReadByte();
            this.mData[137] = s.ReadByte();
            this.mData[138] = s.ReadByte();
            this.mData[139] = s.ReadByte();
            this.mData[140] = s.ReadByte();
            this.mData[141] = s.ReadByte();
            this.mData[142] = s.ReadByte();
            this.mData[143] = s.ReadByte();
            this.mData[144] = s.ReadByte();
            this.mData[145] = s.ReadByte();
            this.mData[146] = s.ReadByte();
            this.mData[147] = s.ReadByte();
            this.mData[148] = s.ReadByte();
            this.mData[149] = s.ReadByte();
            this.mData[150] = s.ReadByte();
            this.mData[151] = s.ReadByte();
            this.mData[152] = s.ReadByte();
            this.mData[153] = s.ReadByte();
            this.mData[154] = s.ReadByte();
            this.mData[155] = s.ReadByte();
            this.mData[156] = s.ReadByte();
            this.mData[157] = s.ReadByte();
            this.mData[158] = s.ReadByte();
            this.mData[159] = s.ReadByte();
            this.mData[160] = s.ReadByte();
            this.mData[161] = s.ReadByte();
            this.mData[162] = s.ReadByte();
            this.mData[163] = s.ReadByte();
            this.mData[164] = s.ReadByte();
            this.mData[165] = s.ReadByte();
            this.mData[166] = s.ReadByte();
            this.mData[167] = s.ReadByte();
            this.mData[168] = s.ReadByte();
            this.mData[169] = s.ReadByte();
            this.mData[170] = s.ReadByte();
            this.mData[171] = s.ReadByte();
            this.mData[172] = s.ReadByte();
            this.mData[173] = s.ReadByte();
            this.mData[174] = s.ReadByte();
            this.mData[175] = s.ReadByte();
            this.mData[176] = s.ReadByte();
            this.mData[177] = s.ReadByte();
            this.mData[178] = s.ReadByte();
            this.mData[179] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "RTCM message for injecting into the onboard GPS (used for DGPS)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Len",
                Description = "data length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "RTCM message (may be fragmented)",
                NumElements = 180,
            });

        }

        private byte mFlags;
        private byte mLen;
        private byte[] mData = new byte[180];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message appropriate for high latency connections like Iridium
    /// </summary>
    public class UasHighLatency: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 54; }
        }
        /// <summary>
        /// A bitfield for use for autopilot-specific flags.
        /// </summary>
        public UInt32 CustomMode {
            get { return mCustomMode; }
            set { mCustomMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// roll
        /// </summary>
        public Int16 Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// pitch
        /// </summary>
        public Int16 Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// heading
        /// </summary>
        public UInt16 Heading {
            get { return mHeading; }
            set { mHeading = value; NotifyUpdated(); }
        }

        /// <summary>
        /// heading setpoint
        /// </summary>
        public Int16 HeadingSp {
            get { return mHeadingSp; }
            set { mHeadingSp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude above mean sea level
        /// </summary>
        public Int16 AltitudeAmsl {
            get { return mAltitudeAmsl; }
            set { mAltitudeAmsl = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude setpoint relative to the home position
        /// </summary>
        public Int16 AltitudeSp {
            get { return mAltitudeSp; }
            set { mAltitudeSp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// distance to target
        /// </summary>
        public UInt16 WpDistance {
            get { return mWpDistance; }
            set { mWpDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap of enabled system modes.
        /// </summary>
        public MavModeFlag BaseMode {
            get { return mBaseMode; }
            set { mBaseMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.
        /// </summary>
        public MavLandedState LandedState {
            get { return mLandedState; }
            set { mLandedState = value; NotifyUpdated(); }
        }

        /// <summary>
        /// throttle (percentage)
        /// </summary>
        public SByte Throttle {
            get { return mThrottle; }
            set { mThrottle = value; NotifyUpdated(); }
        }

        /// <summary>
        /// airspeed
        /// </summary>
        public byte Airspeed {
            get { return mAirspeed; }
            set { mAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// airspeed setpoint
        /// </summary>
        public byte AirspeedSp {
            get { return mAirspeedSp; }
            set { mAirspeedSp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// groundspeed
        /// </summary>
        public byte Groundspeed {
            get { return mGroundspeed; }
            set { mGroundspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// climb rate
        /// </summary>
        public SByte ClimbRate {
            get { return mClimbRate; }
            set { mClimbRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of satellites visible. If unknown, set to UINT8_MAX
        /// </summary>
        public byte GpsNsat {
            get { return mGpsNsat; }
            set { mGpsNsat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Fix type.
        /// </summary>
        public GpsFixType GpsFixType {
            get { return mGpsFixType; }
            set { mGpsFixType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remaining battery (percentage)
        /// </summary>
        public byte BatteryRemaining {
            get { return mBatteryRemaining; }
            set { mBatteryRemaining = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot temperature (degrees C)
        /// </summary>
        public SByte Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Air temperature (degrees C) from airspeed sensor
        /// </summary>
        public SByte TemperatureAir {
            get { return mTemperatureAir; }
            set { mTemperatureAir = value; NotifyUpdated(); }
        }

        /// <summary>
        /// failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)
        /// </summary>
        public byte Failsafe {
            get { return mFailsafe; }
            set { mFailsafe = value; NotifyUpdated(); }
        }

        /// <summary>
        /// current waypoint number
        /// </summary>
        public byte WpNum {
            get { return mWpNum; }
            set { mWpNum = value; NotifyUpdated(); }
        }

        public UasHighLatency()
        {
            mMessageId = 234;
            CrcExtra = 150;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mCustomMode);
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mHeading);
            s.Write(mHeadingSp);
            s.Write(mAltitudeAmsl);
            s.Write(mAltitudeSp);
            s.Write(mWpDistance);
            s.Write((byte)mBaseMode);
            s.Write((byte)mLandedState);
            s.Write(mThrottle);
            s.Write(mAirspeed);
            s.Write(mAirspeedSp);
            s.Write(mGroundspeed);
            s.Write(mClimbRate);
            s.Write(mGpsNsat);
            s.Write((byte)mGpsFixType);
            s.Write(mBatteryRemaining);
            s.Write(mTemperature);
            s.Write(mTemperatureAir);
            s.Write(mFailsafe);
            s.Write(mWpNum);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mCustomMode = s.ReadUInt32();
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mRoll = s.ReadInt16();
            this.mPitch = s.ReadInt16();
            this.mHeading = s.ReadUInt16();
            this.mHeadingSp = s.ReadInt16();
            this.mAltitudeAmsl = s.ReadInt16();
            this.mAltitudeSp = s.ReadInt16();
            this.mWpDistance = s.ReadUInt16();
            this.mBaseMode = (MavModeFlag)s.ReadByte();
            this.mLandedState = (MavLandedState)s.ReadByte();
            this.mThrottle = s.ReadSByte();
            this.mAirspeed = s.ReadByte();
            this.mAirspeedSp = s.ReadByte();
            this.mGroundspeed = s.ReadByte();
            this.mClimbRate = s.ReadSByte();
            this.mGpsNsat = s.ReadByte();
            this.mGpsFixType = (GpsFixType)s.ReadByte();
            this.mBatteryRemaining = s.ReadByte();
            this.mTemperature = s.ReadSByte();
            this.mTemperatureAir = s.ReadSByte();
            this.mFailsafe = s.ReadByte();
            this.mWpNum = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message appropriate for high latency connections like Iridium"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomMode",
                Description = "A bitfield for use for autopilot-specific flags.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "roll",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "pitch",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Heading",
                Description = "heading",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HeadingSp",
                Description = "heading setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeAmsl",
                Description = "Altitude above mean sea level",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeSp",
                Description = "Altitude setpoint relative to the home position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WpDistance",
                Description = "distance to target",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaseMode",
                Description = "Bitmap of enabled system modes.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavModeFlag"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LandedState",
                Description = "The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavLandedState"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Throttle",
                Description = "throttle (percentage)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Airspeed",
                Description = "airspeed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AirspeedSp",
                Description = "airspeed setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Groundspeed",
                Description = "groundspeed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ClimbRate",
                Description = "climb rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GpsNsat",
                Description = "Number of satellites visible. If unknown, set to UINT8_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GpsFixType",
                Description = "GPS Fix type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("GpsFixType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BatteryRemaining",
                Description = "Remaining battery (percentage)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Autopilot temperature (degrees C)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TemperatureAir",
                Description = "Air temperature (degrees C) from airspeed sensor",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Failsafe",
                Description = "failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WpNum",
                Description = "current waypoint number",
                NumElements = 1,
            });

        }

        private UInt32 mCustomMode;
        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int16 mRoll;
        private Int16 mPitch;
        private UInt16 mHeading;
        private Int16 mHeadingSp;
        private Int16 mAltitudeAmsl;
        private Int16 mAltitudeSp;
        private UInt16 mWpDistance;
        private MavModeFlag mBaseMode;
        private MavLandedState mLandedState;
        private SByte mThrottle;
        private byte mAirspeed;
        private byte mAirspeedSp;
        private byte mGroundspeed;
        private SByte mClimbRate;
        private byte mGpsNsat;
        private GpsFixType mGpsFixType;
        private byte mBatteryRemaining;
        private SByte mTemperature;
        private SByte mTemperatureAir;
        private byte mFailsafe;
        private byte mWpNum;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message appropriate for high latency connections like Iridium (version 2)
    /// </summary>
    public class UasHighLatency2: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 60; }
        }
        /// <summary>
        /// Timestamp (milliseconds since boot or Unix epoch)
        /// </summary>
        public UInt32 Timestamp {
            get { return mTimestamp; }
            set { mTimestamp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// A bitfield for use for autopilot-specific flags (2 byte version).
        /// </summary>
        public UInt16 CustomMode {
            get { return mCustomMode; }
            set { mCustomMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude above mean sea level
        /// </summary>
        public Int16 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude setpoint
        /// </summary>
        public Int16 TargetAltitude {
            get { return mTargetAltitude; }
            set { mTargetAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to target waypoint or position
        /// </summary>
        public UInt16 TargetDistance {
            get { return mTargetDistance; }
            set { mTargetDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current waypoint number
        /// </summary>
        public UInt16 WpNum {
            get { return mWpNum; }
            set { mWpNum = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap of failure flags.
        /// </summary>
        public HlFailureFlag FailureFlags {
            get { return mFailureFlags; }
            set { mFailureFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type of the MAV (quadrotor, helicopter, etc.)
        /// </summary>
        public MavType Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.
        /// </summary>
        public MavAutopilot Autopilot {
            get { return mAutopilot; }
            set { mAutopilot = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Heading
        /// </summary>
        public byte Heading {
            get { return mHeading; }
            set { mHeading = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Heading setpoint
        /// </summary>
        public byte TargetHeading {
            get { return mTargetHeading; }
            set { mTargetHeading = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Throttle
        /// </summary>
        public byte Throttle {
            get { return mThrottle; }
            set { mThrottle = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Airspeed
        /// </summary>
        public byte Airspeed {
            get { return mAirspeed; }
            set { mAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Airspeed setpoint
        /// </summary>
        public byte AirspeedSp {
            get { return mAirspeedSp; }
            set { mAirspeedSp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Groundspeed
        /// </summary>
        public byte Groundspeed {
            get { return mGroundspeed; }
            set { mGroundspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Windspeed
        /// </summary>
        public byte Windspeed {
            get { return mWindspeed; }
            set { mWindspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Wind heading
        /// </summary>
        public byte WindHeading {
            get { return mWindHeading; }
            set { mWindHeading = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum error horizontal position since last message
        /// </summary>
        public byte Eph {
            get { return mEph; }
            set { mEph = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum error vertical position since last message
        /// </summary>
        public byte Epv {
            get { return mEpv; }
            set { mEpv = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Air temperature from airspeed sensor
        /// </summary>
        public SByte TemperatureAir {
            get { return mTemperatureAir; }
            set { mTemperatureAir = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum climb rate magnitude since last message
        /// </summary>
        public SByte ClimbRate {
            get { return mClimbRate; }
            set { mClimbRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery level (-1 if field not provided).
        /// </summary>
        public SByte Battery {
            get { return mBattery; }
            set { mBattery = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Field for custom payload.
        /// </summary>
        public SByte Custom0 {
            get { return mCustom0; }
            set { mCustom0 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Field for custom payload.
        /// </summary>
        public SByte Custom1 {
            get { return mCustom1; }
            set { mCustom1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Field for custom payload.
        /// </summary>
        public SByte Custom2 {
            get { return mCustom2; }
            set { mCustom2 = value; NotifyUpdated(); }
        }

        public UasHighLatency2()
        {
            mMessageId = 235;
            CrcExtra = 179;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimestamp);
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mCustomMode);
            s.Write(mAltitude);
            s.Write(mTargetAltitude);
            s.Write(mTargetDistance);
            s.Write(mWpNum);
            s.Write((UInt16)mFailureFlags);
            s.Write((byte)mType);
            s.Write((byte)mAutopilot);
            s.Write(mHeading);
            s.Write(mTargetHeading);
            s.Write(mThrottle);
            s.Write(mAirspeed);
            s.Write(mAirspeedSp);
            s.Write(mGroundspeed);
            s.Write(mWindspeed);
            s.Write(mWindHeading);
            s.Write(mEph);
            s.Write(mEpv);
            s.Write(mTemperatureAir);
            s.Write(mClimbRate);
            s.Write(mBattery);
            s.Write(mCustom0);
            s.Write(mCustom1);
            s.Write(mCustom2);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimestamp = s.ReadUInt32();
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mCustomMode = s.ReadUInt16();
            this.mAltitude = s.ReadInt16();
            this.mTargetAltitude = s.ReadInt16();
            this.mTargetDistance = s.ReadUInt16();
            this.mWpNum = s.ReadUInt16();
            this.mFailureFlags = (HlFailureFlag)s.ReadUInt16();
            this.mType = (MavType)s.ReadByte();
            this.mAutopilot = (MavAutopilot)s.ReadByte();
            this.mHeading = s.ReadByte();
            this.mTargetHeading = s.ReadByte();
            this.mThrottle = s.ReadByte();
            this.mAirspeed = s.ReadByte();
            this.mAirspeedSp = s.ReadByte();
            this.mGroundspeed = s.ReadByte();
            this.mWindspeed = s.ReadByte();
            this.mWindHeading = s.ReadByte();
            this.mEph = s.ReadByte();
            this.mEpv = s.ReadByte();
            this.mTemperatureAir = s.ReadSByte();
            this.mClimbRate = s.ReadSByte();
            this.mBattery = s.ReadSByte();
            this.mCustom0 = s.ReadSByte();
            this.mCustom1 = s.ReadSByte();
            this.mCustom2 = s.ReadSByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message appropriate for high latency connections like Iridium (version 2)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Timestamp",
                Description = "Timestamp (milliseconds since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomMode",
                Description = "A bitfield for use for autopilot-specific flags (2 byte version).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude above mean sea level",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetAltitude",
                Description = "Altitude setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetDistance",
                Description = "Distance to target waypoint or position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WpNum",
                Description = "Current waypoint number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FailureFlags",
                Description = "Bitmap of failure flags.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("HlFailureFlag"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type of the MAV (quadrotor, helicopter, etc.)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autopilot",
                Description = "Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavAutopilot"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Heading",
                Description = "Heading",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetHeading",
                Description = "Heading setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Throttle",
                Description = "Throttle",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Airspeed",
                Description = "Airspeed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AirspeedSp",
                Description = "Airspeed setpoint",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Groundspeed",
                Description = "Groundspeed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Windspeed",
                Description = "Windspeed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindHeading",
                Description = "Wind heading",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Eph",
                Description = "Maximum error horizontal position since last message",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Epv",
                Description = "Maximum error vertical position since last message",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TemperatureAir",
                Description = "Air temperature from airspeed sensor",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ClimbRate",
                Description = "Maximum climb rate magnitude since last message",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Battery",
                Description = "Battery level (-1 if field not provided).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Custom0",
                Description = "Field for custom payload.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Custom1",
                Description = "Field for custom payload.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Custom2",
                Description = "Field for custom payload.",
                NumElements = 1,
            });

        }

        private UInt32 mTimestamp;
        private Int32 mLatitude;
        private Int32 mLongitude;
        private UInt16 mCustomMode;
        private Int16 mAltitude;
        private Int16 mTargetAltitude;
        private UInt16 mTargetDistance;
        private UInt16 mWpNum;
        private HlFailureFlag mFailureFlags;
        private MavType mType;
        private MavAutopilot mAutopilot;
        private byte mHeading;
        private byte mTargetHeading;
        private byte mThrottle;
        private byte mAirspeed;
        private byte mAirspeedSp;
        private byte mGroundspeed;
        private byte mWindspeed;
        private byte mWindHeading;
        private byte mEph;
        private byte mEpv;
        private SByte mTemperatureAir;
        private SByte mClimbRate;
        private SByte mBattery;
        private SByte mCustom0;
        private SByte mCustom1;
        private SByte mCustom2;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Vibration levels and accelerometer clipping
    /// </summary>
    public class UasVibration: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 32; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vibration levels on X-axis
        /// </summary>
        public float VibrationX {
            get { return mVibrationX; }
            set { mVibrationX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vibration levels on Y-axis
        /// </summary>
        public float VibrationY {
            get { return mVibrationY; }
            set { mVibrationY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vibration levels on Z-axis
        /// </summary>
        public float VibrationZ {
            get { return mVibrationZ; }
            set { mVibrationZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// first accelerometer clipping count
        /// </summary>
        public UInt32 Clipping0 {
            get { return mClipping0; }
            set { mClipping0 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// second accelerometer clipping count
        /// </summary>
        public UInt32 Clipping1 {
            get { return mClipping1; }
            set { mClipping1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// third accelerometer clipping count
        /// </summary>
        public UInt32 Clipping2 {
            get { return mClipping2; }
            set { mClipping2 = value; NotifyUpdated(); }
        }

        public UasVibration()
        {
            mMessageId = 241;
            CrcExtra = 90;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mVibrationX);
            s.Write(mVibrationY);
            s.Write(mVibrationZ);
            s.Write(mClipping0);
            s.Write(mClipping1);
            s.Write(mClipping2);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mVibrationX = s.ReadSingle();
            this.mVibrationY = s.ReadSingle();
            this.mVibrationZ = s.ReadSingle();
            this.mClipping0 = s.ReadUInt32();
            this.mClipping1 = s.ReadUInt32();
            this.mClipping2 = s.ReadUInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Vibration levels and accelerometer clipping"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VibrationX",
                Description = "Vibration levels on X-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VibrationY",
                Description = "Vibration levels on Y-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VibrationZ",
                Description = "Vibration levels on Z-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Clipping0",
                Description = "first accelerometer clipping count",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Clipping1",
                Description = "second accelerometer clipping count",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Clipping2",
                Description = "third accelerometer clipping count",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mVibrationX;
        private float mVibrationY;
        private float mVibrationZ;
        private UInt32 mClipping0;
        private UInt32 mClipping1;
        private UInt32 mClipping2;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
    /// </summary>
    public class UasHomePosition: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 52; }
        }
        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Positive for up.
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position of this position in the local coordinate frame
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position of this position in the local coordinate frame
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position of this position in the local coordinate frame
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachX {
            get { return mApproachX; }
            set { mApproachX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachY {
            get { return mApproachY; }
            set { mApproachY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachZ {
            get { return mApproachZ; }
            set { mApproachZ = value; NotifyUpdated(); }
        }

        public UasHomePosition()
        {
            mMessageId = 242;
            CrcExtra = 104;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mAltitude);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mApproachX);
            s.Write(mApproachY);
            s.Write(mApproachZ);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mApproachX = s.ReadSingle();
            this.mApproachY = s.ReadSingle();
            this.mApproachZ = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (MSL). Positive for up.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Local X position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Local Y position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Local Z position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachX",
                Description = "Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachY",
                Description = "Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachZ",
                Description = "Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

        }

        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int32 mAltitude;
        private float mX;
        private float mY;
        private float mZ;
        private float[] mQ = new float[4];
        private float mApproachX;
        private float mApproachY;
        private float mApproachZ;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
    /// </summary>
    public class UasSetHomePosition: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 54; }
        }
        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL). Positive for up.
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position of this position in the local coordinate frame
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position of this position in the local coordinate frame
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position of this position in the local coordinate frame
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachX {
            get { return mApproachX; }
            set { mApproachX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachY {
            get { return mApproachY; }
            set { mApproachY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachZ {
            get { return mApproachZ; }
            set { mApproachZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID.
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        public UasSetHomePosition()
        {
            mMessageId = 243;
            CrcExtra = 85;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mAltitude);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mApproachX);
            s.Write(mApproachY);
            s.Write(mApproachZ);
            s.Write(mTargetSystem);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mApproachX = s.ReadSingle();
            this.mApproachY = s.ReadSingle();
            this.mApproachZ = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude (WGS84)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (MSL). Positive for up.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Local X position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Local Y position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Local Z position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachX",
                Description = "Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachY",
                Description = "Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachZ",
                Description = "Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID.",
                NumElements = 1,
            });

        }

        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int32 mAltitude;
        private float mX;
        private float mY;
        private float mZ;
        private float[] mQ = new float[4];
        private float mApproachX;
        private float mApproachY;
        private float mApproachZ;
        private byte mTargetSystem;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The interval between messages for a particular MAVLink message ID. This message is the response to the MAV_CMD_GET_MESSAGE_INTERVAL command. This interface replaces DATA_STREAM.
    /// </summary>
    public class UasMessageInterval: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 6; }
        }
        /// <summary>
        /// The interval between two messages. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.
        /// </summary>
        public Int32 IntervalUs {
            get { return mIntervalUs; }
            set { mIntervalUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The ID of the requested MAVLink message. v1.0 is limited to 254 messages.
        /// </summary>
        public UInt16 MessageId {
            get { return mMessageId; }
            set { mMessageId = value; NotifyUpdated(); }
        }

        public UasMessageInterval()
        {
            mMessageId = 244;
            CrcExtra = 95;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mIntervalUs);
            s.Write(mMessageId);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mIntervalUs = s.ReadInt32();
            this.mMessageId = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The interval between messages for a particular MAVLink message ID. This message is the response to the MAV_CMD_GET_MESSAGE_INTERVAL command. This interface replaces DATA_STREAM."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntervalUs",
                Description = "The interval between two messages. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessageId",
                Description = "The ID of the requested MAVLink message. v1.0 is limited to 254 messages.",
                NumElements = 1,
            });

        }

        private Int32 mIntervalUs;
        private UInt16 mMessageId;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Provides state for additional features
    /// </summary>
    public class UasExtendedSysState: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 4; }
        }
        /// <summary>
        /// The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration.
        /// </summary>
        public MavVtolState VtolState {
            get { return mVtolState; }
            set { mVtolState = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.
        /// </summary>
        public MavLandedState LandedState {
            get { return mLandedState; }
            set { mLandedState = value; NotifyUpdated(); }
        }

        public UasExtendedSysState()
        {
            mMessageId = 245;
            CrcExtra = 130;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write((byte)mVtolState);
            s.Write((byte)mLandedState);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mVtolState = (MavVtolState)s.ReadByte();
            this.mLandedState = (MavLandedState)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Provides state for additional features"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VtolState",
                Description = "The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavVtolState"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LandedState",
                Description = "The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavLandedState"),
            });

        }

        private MavVtolState mVtolState;
        private MavLandedState mLandedState;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The location and information of an ADSB vehicle
    /// </summary>
    public class UasAdsbVehicle: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 50; }
        }
        /// <summary>
        /// ICAO address
        /// </summary>
        public UInt32 IcaoAddress {
            get { return mIcaoAddress; }
            set { mIcaoAddress = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude(ASL)
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Course over ground
        /// </summary>
        public UInt16 Heading {
            get { return mHeading; }
            set { mHeading = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The horizontal velocity
        /// </summary>
        public UInt16 HorVelocity {
            get { return mHorVelocity; }
            set { mHorVelocity = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The vertical velocity. Positive is up
        /// </summary>
        public Int16 VerVelocity {
            get { return mVerVelocity; }
            set { mVerVelocity = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmap to indicate various statuses including valid data fields
        /// </summary>
        public AdsbFlags Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Squawk code
        /// </summary>
        public UInt16 Squawk {
            get { return mSquawk; }
            set { mSquawk = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ADSB altitude type.
        /// </summary>
        public AdsbAltitudeType AltitudeType {
            get { return mAltitudeType; }
            set { mAltitudeType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The callsign, 8+null
        /// </summary>
        public char[] Callsign {
            get { return mCallsign; }
            set { mCallsign = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ADSB emitter type.
        /// </summary>
        public AdsbEmitterType EmitterType {
            get { return mEmitterType; }
            set { mEmitterType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Time since last communication in seconds
        /// </summary>
        public byte Tslc {
            get { return mTslc; }
            set { mTslc = value; NotifyUpdated(); }
        }

        public UasAdsbVehicle()
        {
            mMessageId = 246;
            CrcExtra = 184;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mIcaoAddress);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAltitude);
            s.Write(mHeading);
            s.Write(mHorVelocity);
            s.Write(mVerVelocity);
            s.Write((UInt16)mFlags);
            s.Write(mSquawk);
            s.Write((byte)mAltitudeType);
            s.Write(mCallsign[0]); 
            s.Write(mCallsign[1]); 
            s.Write(mCallsign[2]); 
            s.Write(mCallsign[3]); 
            s.Write(mCallsign[4]); 
            s.Write(mCallsign[5]); 
            s.Write(mCallsign[6]); 
            s.Write(mCallsign[7]); 
            s.Write(mCallsign[8]); 
            s.Write((byte)mEmitterType);
            s.Write(mTslc);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mIcaoAddress = s.ReadUInt32();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
            this.mHeading = s.ReadUInt16();
            this.mHorVelocity = s.ReadUInt16();
            this.mVerVelocity = s.ReadInt16();
            this.mFlags = (AdsbFlags)s.ReadUInt16();
            this.mSquawk = s.ReadUInt16();
            this.mAltitudeType = (AdsbAltitudeType)s.ReadByte();
            this.mCallsign[0] = s.ReadChar();
            this.mCallsign[1] = s.ReadChar();
            this.mCallsign[2] = s.ReadChar();
            this.mCallsign[3] = s.ReadChar();
            this.mCallsign[4] = s.ReadChar();
            this.mCallsign[5] = s.ReadChar();
            this.mCallsign[6] = s.ReadChar();
            this.mCallsign[7] = s.ReadChar();
            this.mCallsign[8] = s.ReadChar();
            this.mEmitterType = (AdsbEmitterType)s.ReadByte();
            this.mTslc = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The location and information of an ADSB vehicle"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IcaoAddress",
                Description = "ICAO address",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude(ASL)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Heading",
                Description = "Course over ground",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HorVelocity",
                Description = "The horizontal velocity",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VerVelocity",
                Description = "The vertical velocity. Positive is up",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "Bitmap to indicate various statuses including valid data fields",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("AdsbFlags"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Squawk",
                Description = "Squawk code",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeType",
                Description = "ADSB altitude type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("AdsbAltitudeType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Callsign",
                Description = "The callsign, 8+null",
                NumElements = 9,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EmitterType",
                Description = "ADSB emitter type.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("AdsbEmitterType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Tslc",
                Description = "Time since last communication in seconds",
                NumElements = 1,
            });

        }

        private UInt32 mIcaoAddress;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAltitude;
        private UInt16 mHeading;
        private UInt16 mHorVelocity;
        private Int16 mVerVelocity;
        private AdsbFlags mFlags;
        private UInt16 mSquawk;
        private AdsbAltitudeType mAltitudeType;
        private char[] mCallsign = new char[9];
        private AdsbEmitterType mEmitterType;
        private byte mTslc;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Information about a potential collision
    /// </summary>
    public class UasCollision: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 22; }
        }
        /// <summary>
        /// Unique identifier, domain based on src field
        /// </summary>
        public UInt32 Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Estimated time until collision occurs
        /// </summary>
        public float TimeToMinimumDelta {
            get { return mTimeToMinimumDelta; }
            set { mTimeToMinimumDelta = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Closest vertical distance between vehicle and object
        /// </summary>
        public float AltitudeMinimumDelta {
            get { return mAltitudeMinimumDelta; }
            set { mAltitudeMinimumDelta = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Closest horizontal distance between vehicle and object
        /// </summary>
        public float HorizontalMinimumDelta {
            get { return mHorizontalMinimumDelta; }
            set { mHorizontalMinimumDelta = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Collision data source
        /// </summary>
        public MavCollisionSrc Src {
            get { return mSrc; }
            set { mSrc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Action that is being taken to avoid this collision
        /// </summary>
        public MavCollisionAction Action {
            get { return mAction; }
            set { mAction = value; NotifyUpdated(); }
        }

        /// <summary>
        /// How concerned the aircraft is about this collision
        /// </summary>
        public MavCollisionThreatLevel ThreatLevel {
            get { return mThreatLevel; }
            set { mThreatLevel = value; NotifyUpdated(); }
        }

        public UasCollision()
        {
            mMessageId = 247;
            CrcExtra = 81;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mId);
            s.Write(mTimeToMinimumDelta);
            s.Write(mAltitudeMinimumDelta);
            s.Write(mHorizontalMinimumDelta);
            s.Write((byte)mSrc);
            s.Write((byte)mAction);
            s.Write((byte)mThreatLevel);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mId = s.ReadUInt32();
            this.mTimeToMinimumDelta = s.ReadSingle();
            this.mAltitudeMinimumDelta = s.ReadSingle();
            this.mHorizontalMinimumDelta = s.ReadSingle();
            this.mSrc = (MavCollisionSrc)s.ReadByte();
            this.mAction = (MavCollisionAction)s.ReadByte();
            this.mThreatLevel = (MavCollisionThreatLevel)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Information about a potential collision"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Unique identifier, domain based on src field",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeToMinimumDelta",
                Description = "Estimated time until collision occurs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeMinimumDelta",
                Description = "Closest vertical distance between vehicle and object",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HorizontalMinimumDelta",
                Description = "Closest horizontal distance between vehicle and object",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Src",
                Description = "Collision data source",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCollisionSrc"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Action",
                Description = "Action that is being taken to avoid this collision",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCollisionAction"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ThreatLevel",
                Description = "How concerned the aircraft is about this collision",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCollisionThreatLevel"),
            });

        }

        private UInt32 mId;
        private float mTimeToMinimumDelta;
        private float mAltitudeMinimumDelta;
        private float mHorizontalMinimumDelta;
        private MavCollisionSrc mSrc;
        private MavCollisionAction mAction;
        private MavCollisionThreatLevel mThreatLevel;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message implementing parts of the V2 payload specs in V1 frames for transitional support.
    /// </summary>
    public class UasV2Extension: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 506; }
        }
        /// <summary>
        /// A code that identifies the software component that understands this message (analogous to USB device classes or mime type strings). If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/definition_files/extension_message_ids.xml. Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
        /// </summary>
        public UInt16 MessageType {
            get { return mMessageType; }
            set { mMessageType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Network ID (0 for broadcast)
        /// </summary>
        public byte TargetNetwork {
            get { return mTargetNetwork; }
            set { mTargetNetwork = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID (0 for broadcast)
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID (0 for broadcast)
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variable length payload. The length must be encoded in the payload as part of the message_type protocol, e.g. by including the length as payload data, or by terminating the payload data with a non-zero marker. This is required in order to reconstruct zero-terminated payloads that are (or otherwise would be) trimmed by MAVLink 2 empty-byte truncation. The entire content of the payload block is opaque unless you understand the encoding message_type. The particular encoding used can be extension specific and might not always be documented as part of the MAVLink specification.
        /// </summary>
        public byte[] Payload {
            get { return mPayload; }
            set { mPayload = value; NotifyUpdated(); }
        }

        public UasV2Extension()
        {
            mMessageId = 248;
            CrcExtra = 8;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mMessageType);
            s.Write(mTargetNetwork);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mPayload[0]); 
            s.Write(mPayload[1]); 
            s.Write(mPayload[2]); 
            s.Write(mPayload[3]); 
            s.Write(mPayload[4]); 
            s.Write(mPayload[5]); 
            s.Write(mPayload[6]); 
            s.Write(mPayload[7]); 
            s.Write(mPayload[8]); 
            s.Write(mPayload[9]); 
            s.Write(mPayload[10]); 
            s.Write(mPayload[11]); 
            s.Write(mPayload[12]); 
            s.Write(mPayload[13]); 
            s.Write(mPayload[14]); 
            s.Write(mPayload[15]); 
            s.Write(mPayload[16]); 
            s.Write(mPayload[17]); 
            s.Write(mPayload[18]); 
            s.Write(mPayload[19]); 
            s.Write(mPayload[20]); 
            s.Write(mPayload[21]); 
            s.Write(mPayload[22]); 
            s.Write(mPayload[23]); 
            s.Write(mPayload[24]); 
            s.Write(mPayload[25]); 
            s.Write(mPayload[26]); 
            s.Write(mPayload[27]); 
            s.Write(mPayload[28]); 
            s.Write(mPayload[29]); 
            s.Write(mPayload[30]); 
            s.Write(mPayload[31]); 
            s.Write(mPayload[32]); 
            s.Write(mPayload[33]); 
            s.Write(mPayload[34]); 
            s.Write(mPayload[35]); 
            s.Write(mPayload[36]); 
            s.Write(mPayload[37]); 
            s.Write(mPayload[38]); 
            s.Write(mPayload[39]); 
            s.Write(mPayload[40]); 
            s.Write(mPayload[41]); 
            s.Write(mPayload[42]); 
            s.Write(mPayload[43]); 
            s.Write(mPayload[44]); 
            s.Write(mPayload[45]); 
            s.Write(mPayload[46]); 
            s.Write(mPayload[47]); 
            s.Write(mPayload[48]); 
            s.Write(mPayload[49]); 
            s.Write(mPayload[50]); 
            s.Write(mPayload[51]); 
            s.Write(mPayload[52]); 
            s.Write(mPayload[53]); 
            s.Write(mPayload[54]); 
            s.Write(mPayload[55]); 
            s.Write(mPayload[56]); 
            s.Write(mPayload[57]); 
            s.Write(mPayload[58]); 
            s.Write(mPayload[59]); 
            s.Write(mPayload[60]); 
            s.Write(mPayload[61]); 
            s.Write(mPayload[62]); 
            s.Write(mPayload[63]); 
            s.Write(mPayload[64]); 
            s.Write(mPayload[65]); 
            s.Write(mPayload[66]); 
            s.Write(mPayload[67]); 
            s.Write(mPayload[68]); 
            s.Write(mPayload[69]); 
            s.Write(mPayload[70]); 
            s.Write(mPayload[71]); 
            s.Write(mPayload[72]); 
            s.Write(mPayload[73]); 
            s.Write(mPayload[74]); 
            s.Write(mPayload[75]); 
            s.Write(mPayload[76]); 
            s.Write(mPayload[77]); 
            s.Write(mPayload[78]); 
            s.Write(mPayload[79]); 
            s.Write(mPayload[80]); 
            s.Write(mPayload[81]); 
            s.Write(mPayload[82]); 
            s.Write(mPayload[83]); 
            s.Write(mPayload[84]); 
            s.Write(mPayload[85]); 
            s.Write(mPayload[86]); 
            s.Write(mPayload[87]); 
            s.Write(mPayload[88]); 
            s.Write(mPayload[89]); 
            s.Write(mPayload[90]); 
            s.Write(mPayload[91]); 
            s.Write(mPayload[92]); 
            s.Write(mPayload[93]); 
            s.Write(mPayload[94]); 
            s.Write(mPayload[95]); 
            s.Write(mPayload[96]); 
            s.Write(mPayload[97]); 
            s.Write(mPayload[98]); 
            s.Write(mPayload[99]); 
            s.Write(mPayload[100]); 
            s.Write(mPayload[101]); 
            s.Write(mPayload[102]); 
            s.Write(mPayload[103]); 
            s.Write(mPayload[104]); 
            s.Write(mPayload[105]); 
            s.Write(mPayload[106]); 
            s.Write(mPayload[107]); 
            s.Write(mPayload[108]); 
            s.Write(mPayload[109]); 
            s.Write(mPayload[110]); 
            s.Write(mPayload[111]); 
            s.Write(mPayload[112]); 
            s.Write(mPayload[113]); 
            s.Write(mPayload[114]); 
            s.Write(mPayload[115]); 
            s.Write(mPayload[116]); 
            s.Write(mPayload[117]); 
            s.Write(mPayload[118]); 
            s.Write(mPayload[119]); 
            s.Write(mPayload[120]); 
            s.Write(mPayload[121]); 
            s.Write(mPayload[122]); 
            s.Write(mPayload[123]); 
            s.Write(mPayload[124]); 
            s.Write(mPayload[125]); 
            s.Write(mPayload[126]); 
            s.Write(mPayload[127]); 
            s.Write(mPayload[128]); 
            s.Write(mPayload[129]); 
            s.Write(mPayload[130]); 
            s.Write(mPayload[131]); 
            s.Write(mPayload[132]); 
            s.Write(mPayload[133]); 
            s.Write(mPayload[134]); 
            s.Write(mPayload[135]); 
            s.Write(mPayload[136]); 
            s.Write(mPayload[137]); 
            s.Write(mPayload[138]); 
            s.Write(mPayload[139]); 
            s.Write(mPayload[140]); 
            s.Write(mPayload[141]); 
            s.Write(mPayload[142]); 
            s.Write(mPayload[143]); 
            s.Write(mPayload[144]); 
            s.Write(mPayload[145]); 
            s.Write(mPayload[146]); 
            s.Write(mPayload[147]); 
            s.Write(mPayload[148]); 
            s.Write(mPayload[149]); 
            s.Write(mPayload[150]); 
            s.Write(mPayload[151]); 
            s.Write(mPayload[152]); 
            s.Write(mPayload[153]); 
            s.Write(mPayload[154]); 
            s.Write(mPayload[155]); 
            s.Write(mPayload[156]); 
            s.Write(mPayload[157]); 
            s.Write(mPayload[158]); 
            s.Write(mPayload[159]); 
            s.Write(mPayload[160]); 
            s.Write(mPayload[161]); 
            s.Write(mPayload[162]); 
            s.Write(mPayload[163]); 
            s.Write(mPayload[164]); 
            s.Write(mPayload[165]); 
            s.Write(mPayload[166]); 
            s.Write(mPayload[167]); 
            s.Write(mPayload[168]); 
            s.Write(mPayload[169]); 
            s.Write(mPayload[170]); 
            s.Write(mPayload[171]); 
            s.Write(mPayload[172]); 
            s.Write(mPayload[173]); 
            s.Write(mPayload[174]); 
            s.Write(mPayload[175]); 
            s.Write(mPayload[176]); 
            s.Write(mPayload[177]); 
            s.Write(mPayload[178]); 
            s.Write(mPayload[179]); 
            s.Write(mPayload[180]); 
            s.Write(mPayload[181]); 
            s.Write(mPayload[182]); 
            s.Write(mPayload[183]); 
            s.Write(mPayload[184]); 
            s.Write(mPayload[185]); 
            s.Write(mPayload[186]); 
            s.Write(mPayload[187]); 
            s.Write(mPayload[188]); 
            s.Write(mPayload[189]); 
            s.Write(mPayload[190]); 
            s.Write(mPayload[191]); 
            s.Write(mPayload[192]); 
            s.Write(mPayload[193]); 
            s.Write(mPayload[194]); 
            s.Write(mPayload[195]); 
            s.Write(mPayload[196]); 
            s.Write(mPayload[197]); 
            s.Write(mPayload[198]); 
            s.Write(mPayload[199]); 
            s.Write(mPayload[200]); 
            s.Write(mPayload[201]); 
            s.Write(mPayload[202]); 
            s.Write(mPayload[203]); 
            s.Write(mPayload[204]); 
            s.Write(mPayload[205]); 
            s.Write(mPayload[206]); 
            s.Write(mPayload[207]); 
            s.Write(mPayload[208]); 
            s.Write(mPayload[209]); 
            s.Write(mPayload[210]); 
            s.Write(mPayload[211]); 
            s.Write(mPayload[212]); 
            s.Write(mPayload[213]); 
            s.Write(mPayload[214]); 
            s.Write(mPayload[215]); 
            s.Write(mPayload[216]); 
            s.Write(mPayload[217]); 
            s.Write(mPayload[218]); 
            s.Write(mPayload[219]); 
            s.Write(mPayload[220]); 
            s.Write(mPayload[221]); 
            s.Write(mPayload[222]); 
            s.Write(mPayload[223]); 
            s.Write(mPayload[224]); 
            s.Write(mPayload[225]); 
            s.Write(mPayload[226]); 
            s.Write(mPayload[227]); 
            s.Write(mPayload[228]); 
            s.Write(mPayload[229]); 
            s.Write(mPayload[230]); 
            s.Write(mPayload[231]); 
            s.Write(mPayload[232]); 
            s.Write(mPayload[233]); 
            s.Write(mPayload[234]); 
            s.Write(mPayload[235]); 
            s.Write(mPayload[236]); 
            s.Write(mPayload[237]); 
            s.Write(mPayload[238]); 
            s.Write(mPayload[239]); 
            s.Write(mPayload[240]); 
            s.Write(mPayload[241]); 
            s.Write(mPayload[242]); 
            s.Write(mPayload[243]); 
            s.Write(mPayload[244]); 
            s.Write(mPayload[245]); 
            s.Write(mPayload[246]); 
            s.Write(mPayload[247]); 
            s.Write(mPayload[248]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mMessageType = s.ReadUInt16();
            this.mTargetNetwork = s.ReadByte();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mPayload[0] = s.ReadByte();
            this.mPayload[1] = s.ReadByte();
            this.mPayload[2] = s.ReadByte();
            this.mPayload[3] = s.ReadByte();
            this.mPayload[4] = s.ReadByte();
            this.mPayload[5] = s.ReadByte();
            this.mPayload[6] = s.ReadByte();
            this.mPayload[7] = s.ReadByte();
            this.mPayload[8] = s.ReadByte();
            this.mPayload[9] = s.ReadByte();
            this.mPayload[10] = s.ReadByte();
            this.mPayload[11] = s.ReadByte();
            this.mPayload[12] = s.ReadByte();
            this.mPayload[13] = s.ReadByte();
            this.mPayload[14] = s.ReadByte();
            this.mPayload[15] = s.ReadByte();
            this.mPayload[16] = s.ReadByte();
            this.mPayload[17] = s.ReadByte();
            this.mPayload[18] = s.ReadByte();
            this.mPayload[19] = s.ReadByte();
            this.mPayload[20] = s.ReadByte();
            this.mPayload[21] = s.ReadByte();
            this.mPayload[22] = s.ReadByte();
            this.mPayload[23] = s.ReadByte();
            this.mPayload[24] = s.ReadByte();
            this.mPayload[25] = s.ReadByte();
            this.mPayload[26] = s.ReadByte();
            this.mPayload[27] = s.ReadByte();
            this.mPayload[28] = s.ReadByte();
            this.mPayload[29] = s.ReadByte();
            this.mPayload[30] = s.ReadByte();
            this.mPayload[31] = s.ReadByte();
            this.mPayload[32] = s.ReadByte();
            this.mPayload[33] = s.ReadByte();
            this.mPayload[34] = s.ReadByte();
            this.mPayload[35] = s.ReadByte();
            this.mPayload[36] = s.ReadByte();
            this.mPayload[37] = s.ReadByte();
            this.mPayload[38] = s.ReadByte();
            this.mPayload[39] = s.ReadByte();
            this.mPayload[40] = s.ReadByte();
            this.mPayload[41] = s.ReadByte();
            this.mPayload[42] = s.ReadByte();
            this.mPayload[43] = s.ReadByte();
            this.mPayload[44] = s.ReadByte();
            this.mPayload[45] = s.ReadByte();
            this.mPayload[46] = s.ReadByte();
            this.mPayload[47] = s.ReadByte();
            this.mPayload[48] = s.ReadByte();
            this.mPayload[49] = s.ReadByte();
            this.mPayload[50] = s.ReadByte();
            this.mPayload[51] = s.ReadByte();
            this.mPayload[52] = s.ReadByte();
            this.mPayload[53] = s.ReadByte();
            this.mPayload[54] = s.ReadByte();
            this.mPayload[55] = s.ReadByte();
            this.mPayload[56] = s.ReadByte();
            this.mPayload[57] = s.ReadByte();
            this.mPayload[58] = s.ReadByte();
            this.mPayload[59] = s.ReadByte();
            this.mPayload[60] = s.ReadByte();
            this.mPayload[61] = s.ReadByte();
            this.mPayload[62] = s.ReadByte();
            this.mPayload[63] = s.ReadByte();
            this.mPayload[64] = s.ReadByte();
            this.mPayload[65] = s.ReadByte();
            this.mPayload[66] = s.ReadByte();
            this.mPayload[67] = s.ReadByte();
            this.mPayload[68] = s.ReadByte();
            this.mPayload[69] = s.ReadByte();
            this.mPayload[70] = s.ReadByte();
            this.mPayload[71] = s.ReadByte();
            this.mPayload[72] = s.ReadByte();
            this.mPayload[73] = s.ReadByte();
            this.mPayload[74] = s.ReadByte();
            this.mPayload[75] = s.ReadByte();
            this.mPayload[76] = s.ReadByte();
            this.mPayload[77] = s.ReadByte();
            this.mPayload[78] = s.ReadByte();
            this.mPayload[79] = s.ReadByte();
            this.mPayload[80] = s.ReadByte();
            this.mPayload[81] = s.ReadByte();
            this.mPayload[82] = s.ReadByte();
            this.mPayload[83] = s.ReadByte();
            this.mPayload[84] = s.ReadByte();
            this.mPayload[85] = s.ReadByte();
            this.mPayload[86] = s.ReadByte();
            this.mPayload[87] = s.ReadByte();
            this.mPayload[88] = s.ReadByte();
            this.mPayload[89] = s.ReadByte();
            this.mPayload[90] = s.ReadByte();
            this.mPayload[91] = s.ReadByte();
            this.mPayload[92] = s.ReadByte();
            this.mPayload[93] = s.ReadByte();
            this.mPayload[94] = s.ReadByte();
            this.mPayload[95] = s.ReadByte();
            this.mPayload[96] = s.ReadByte();
            this.mPayload[97] = s.ReadByte();
            this.mPayload[98] = s.ReadByte();
            this.mPayload[99] = s.ReadByte();
            this.mPayload[100] = s.ReadByte();
            this.mPayload[101] = s.ReadByte();
            this.mPayload[102] = s.ReadByte();
            this.mPayload[103] = s.ReadByte();
            this.mPayload[104] = s.ReadByte();
            this.mPayload[105] = s.ReadByte();
            this.mPayload[106] = s.ReadByte();
            this.mPayload[107] = s.ReadByte();
            this.mPayload[108] = s.ReadByte();
            this.mPayload[109] = s.ReadByte();
            this.mPayload[110] = s.ReadByte();
            this.mPayload[111] = s.ReadByte();
            this.mPayload[112] = s.ReadByte();
            this.mPayload[113] = s.ReadByte();
            this.mPayload[114] = s.ReadByte();
            this.mPayload[115] = s.ReadByte();
            this.mPayload[116] = s.ReadByte();
            this.mPayload[117] = s.ReadByte();
            this.mPayload[118] = s.ReadByte();
            this.mPayload[119] = s.ReadByte();
            this.mPayload[120] = s.ReadByte();
            this.mPayload[121] = s.ReadByte();
            this.mPayload[122] = s.ReadByte();
            this.mPayload[123] = s.ReadByte();
            this.mPayload[124] = s.ReadByte();
            this.mPayload[125] = s.ReadByte();
            this.mPayload[126] = s.ReadByte();
            this.mPayload[127] = s.ReadByte();
            this.mPayload[128] = s.ReadByte();
            this.mPayload[129] = s.ReadByte();
            this.mPayload[130] = s.ReadByte();
            this.mPayload[131] = s.ReadByte();
            this.mPayload[132] = s.ReadByte();
            this.mPayload[133] = s.ReadByte();
            this.mPayload[134] = s.ReadByte();
            this.mPayload[135] = s.ReadByte();
            this.mPayload[136] = s.ReadByte();
            this.mPayload[137] = s.ReadByte();
            this.mPayload[138] = s.ReadByte();
            this.mPayload[139] = s.ReadByte();
            this.mPayload[140] = s.ReadByte();
            this.mPayload[141] = s.ReadByte();
            this.mPayload[142] = s.ReadByte();
            this.mPayload[143] = s.ReadByte();
            this.mPayload[144] = s.ReadByte();
            this.mPayload[145] = s.ReadByte();
            this.mPayload[146] = s.ReadByte();
            this.mPayload[147] = s.ReadByte();
            this.mPayload[148] = s.ReadByte();
            this.mPayload[149] = s.ReadByte();
            this.mPayload[150] = s.ReadByte();
            this.mPayload[151] = s.ReadByte();
            this.mPayload[152] = s.ReadByte();
            this.mPayload[153] = s.ReadByte();
            this.mPayload[154] = s.ReadByte();
            this.mPayload[155] = s.ReadByte();
            this.mPayload[156] = s.ReadByte();
            this.mPayload[157] = s.ReadByte();
            this.mPayload[158] = s.ReadByte();
            this.mPayload[159] = s.ReadByte();
            this.mPayload[160] = s.ReadByte();
            this.mPayload[161] = s.ReadByte();
            this.mPayload[162] = s.ReadByte();
            this.mPayload[163] = s.ReadByte();
            this.mPayload[164] = s.ReadByte();
            this.mPayload[165] = s.ReadByte();
            this.mPayload[166] = s.ReadByte();
            this.mPayload[167] = s.ReadByte();
            this.mPayload[168] = s.ReadByte();
            this.mPayload[169] = s.ReadByte();
            this.mPayload[170] = s.ReadByte();
            this.mPayload[171] = s.ReadByte();
            this.mPayload[172] = s.ReadByte();
            this.mPayload[173] = s.ReadByte();
            this.mPayload[174] = s.ReadByte();
            this.mPayload[175] = s.ReadByte();
            this.mPayload[176] = s.ReadByte();
            this.mPayload[177] = s.ReadByte();
            this.mPayload[178] = s.ReadByte();
            this.mPayload[179] = s.ReadByte();
            this.mPayload[180] = s.ReadByte();
            this.mPayload[181] = s.ReadByte();
            this.mPayload[182] = s.ReadByte();
            this.mPayload[183] = s.ReadByte();
            this.mPayload[184] = s.ReadByte();
            this.mPayload[185] = s.ReadByte();
            this.mPayload[186] = s.ReadByte();
            this.mPayload[187] = s.ReadByte();
            this.mPayload[188] = s.ReadByte();
            this.mPayload[189] = s.ReadByte();
            this.mPayload[190] = s.ReadByte();
            this.mPayload[191] = s.ReadByte();
            this.mPayload[192] = s.ReadByte();
            this.mPayload[193] = s.ReadByte();
            this.mPayload[194] = s.ReadByte();
            this.mPayload[195] = s.ReadByte();
            this.mPayload[196] = s.ReadByte();
            this.mPayload[197] = s.ReadByte();
            this.mPayload[198] = s.ReadByte();
            this.mPayload[199] = s.ReadByte();
            this.mPayload[200] = s.ReadByte();
            this.mPayload[201] = s.ReadByte();
            this.mPayload[202] = s.ReadByte();
            this.mPayload[203] = s.ReadByte();
            this.mPayload[204] = s.ReadByte();
            this.mPayload[205] = s.ReadByte();
            this.mPayload[206] = s.ReadByte();
            this.mPayload[207] = s.ReadByte();
            this.mPayload[208] = s.ReadByte();
            this.mPayload[209] = s.ReadByte();
            this.mPayload[210] = s.ReadByte();
            this.mPayload[211] = s.ReadByte();
            this.mPayload[212] = s.ReadByte();
            this.mPayload[213] = s.ReadByte();
            this.mPayload[214] = s.ReadByte();
            this.mPayload[215] = s.ReadByte();
            this.mPayload[216] = s.ReadByte();
            this.mPayload[217] = s.ReadByte();
            this.mPayload[218] = s.ReadByte();
            this.mPayload[219] = s.ReadByte();
            this.mPayload[220] = s.ReadByte();
            this.mPayload[221] = s.ReadByte();
            this.mPayload[222] = s.ReadByte();
            this.mPayload[223] = s.ReadByte();
            this.mPayload[224] = s.ReadByte();
            this.mPayload[225] = s.ReadByte();
            this.mPayload[226] = s.ReadByte();
            this.mPayload[227] = s.ReadByte();
            this.mPayload[228] = s.ReadByte();
            this.mPayload[229] = s.ReadByte();
            this.mPayload[230] = s.ReadByte();
            this.mPayload[231] = s.ReadByte();
            this.mPayload[232] = s.ReadByte();
            this.mPayload[233] = s.ReadByte();
            this.mPayload[234] = s.ReadByte();
            this.mPayload[235] = s.ReadByte();
            this.mPayload[236] = s.ReadByte();
            this.mPayload[237] = s.ReadByte();
            this.mPayload[238] = s.ReadByte();
            this.mPayload[239] = s.ReadByte();
            this.mPayload[240] = s.ReadByte();
            this.mPayload[241] = s.ReadByte();
            this.mPayload[242] = s.ReadByte();
            this.mPayload[243] = s.ReadByte();
            this.mPayload[244] = s.ReadByte();
            this.mPayload[245] = s.ReadByte();
            this.mPayload[246] = s.ReadByte();
            this.mPayload[247] = s.ReadByte();
            this.mPayload[248] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message implementing parts of the V2 payload specs in V1 frames for transitional support."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessageType",
                Description = "A code that identifies the software component that understands this message (analogous to USB device classes or mime type strings). If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/definition_files/extension_message_ids.xml. Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetNetwork",
                Description = "Network ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Payload",
                Description = "Variable length payload. The length must be encoded in the payload as part of the message_type protocol, e.g. by including the length as payload data, or by terminating the payload data with a non-zero marker. This is required in order to reconstruct zero-terminated payloads that are (or otherwise would be) trimmed by MAVLink 2 empty-byte truncation. The entire content of the payload block is opaque unless you understand the encoding message_type. The particular encoding used can be extension specific and might not always be documented as part of the MAVLink specification.",
                NumElements = 249,
            });

        }

        private UInt16 mMessageType;
        private byte mTargetNetwork;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte[] mPayload = new byte[249];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    /// </summary>
    public class UasMemoryVect: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 70; }
        }
        /// <summary>
        /// Starting address of the debug variables
        /// </summary>
        public UInt16 Address {
            get { return mAddress; }
            set { mAddress = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
        /// </summary>
        public byte Ver {
            get { return mVer; }
            set { mVer = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
        /// </summary>
        public byte Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Memory contents at specified address
        /// </summary>
        public SByte[] Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        public UasMemoryVect()
        {
            mMessageId = 249;
            CrcExtra = 204;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mAddress);
            s.Write(mVer);
            s.Write(mType);
            s.Write(mValue[0]); 
            s.Write(mValue[1]); 
            s.Write(mValue[2]); 
            s.Write(mValue[3]); 
            s.Write(mValue[4]); 
            s.Write(mValue[5]); 
            s.Write(mValue[6]); 
            s.Write(mValue[7]); 
            s.Write(mValue[8]); 
            s.Write(mValue[9]); 
            s.Write(mValue[10]); 
            s.Write(mValue[11]); 
            s.Write(mValue[12]); 
            s.Write(mValue[13]); 
            s.Write(mValue[14]); 
            s.Write(mValue[15]); 
            s.Write(mValue[16]); 
            s.Write(mValue[17]); 
            s.Write(mValue[18]); 
            s.Write(mValue[19]); 
            s.Write(mValue[20]); 
            s.Write(mValue[21]); 
            s.Write(mValue[22]); 
            s.Write(mValue[23]); 
            s.Write(mValue[24]); 
            s.Write(mValue[25]); 
            s.Write(mValue[26]); 
            s.Write(mValue[27]); 
            s.Write(mValue[28]); 
            s.Write(mValue[29]); 
            s.Write(mValue[30]); 
            s.Write(mValue[31]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mAddress = s.ReadUInt16();
            this.mVer = s.ReadByte();
            this.mType = s.ReadByte();
            this.mValue[0] = s.ReadSByte();
            this.mValue[1] = s.ReadSByte();
            this.mValue[2] = s.ReadSByte();
            this.mValue[3] = s.ReadSByte();
            this.mValue[4] = s.ReadSByte();
            this.mValue[5] = s.ReadSByte();
            this.mValue[6] = s.ReadSByte();
            this.mValue[7] = s.ReadSByte();
            this.mValue[8] = s.ReadSByte();
            this.mValue[9] = s.ReadSByte();
            this.mValue[10] = s.ReadSByte();
            this.mValue[11] = s.ReadSByte();
            this.mValue[12] = s.ReadSByte();
            this.mValue[13] = s.ReadSByte();
            this.mValue[14] = s.ReadSByte();
            this.mValue[15] = s.ReadSByte();
            this.mValue[16] = s.ReadSByte();
            this.mValue[17] = s.ReadSByte();
            this.mValue[18] = s.ReadSByte();
            this.mValue[19] = s.ReadSByte();
            this.mValue[20] = s.ReadSByte();
            this.mValue[21] = s.ReadSByte();
            this.mValue[22] = s.ReadSByte();
            this.mValue[23] = s.ReadSByte();
            this.mValue[24] = s.ReadSByte();
            this.mValue[25] = s.ReadSByte();
            this.mValue[26] = s.ReadSByte();
            this.mValue[27] = s.ReadSByte();
            this.mValue[28] = s.ReadSByte();
            this.mValue[29] = s.ReadSByte();
            this.mValue[30] = s.ReadSByte();
            this.mValue[31] = s.ReadSByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Address",
                Description = "Starting address of the debug variables",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ver",
                Description = "Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "Memory contents at specified address",
                NumElements = 32,
            });

        }

        private UInt16 mAddress;
        private byte mVer;
        private byte mType;
        private SByte[] mValue = new SByte[32];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// To debug something using a named 3D vector.
    /// </summary>
    public class UasDebugVect: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 40; }
        }
        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// x
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Name
        /// </summary>
        public char[] Name {
            get { return mName; }
            set { mName = value; NotifyUpdated(); }
        }

        public UasDebugVect()
        {
            mMessageId = 250;
            CrcExtra = 49;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mName[0]); 
            s.Write(mName[1]); 
            s.Write(mName[2]); 
            s.Write(mName[3]); 
            s.Write(mName[4]); 
            s.Write(mName[5]); 
            s.Write(mName[6]); 
            s.Write(mName[7]); 
            s.Write(mName[8]); 
            s.Write(mName[9]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mName[0] = s.ReadChar();
            this.mName[1] = s.ReadChar();
            this.mName[2] = s.ReadChar();
            this.mName[3] = s.ReadChar();
            this.mName[4] = s.ReadChar();
            this.mName[5] = s.ReadChar();
            this.mName[6] = s.ReadChar();
            this.mName[7] = s.ReadChar();
            this.mName[8] = s.ReadChar();
            this.mName[9] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "To debug something using a named 3D vector."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "x",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "y",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "z",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Name",
                Description = "Name",
                NumElements = 10,
            });

        }

        private UInt64 mTimeUsec;
        private float mX;
        private float mY;
        private float mZ;
        private char[] mName = new char[10];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    /// </summary>
    public class UasNamedValueFloat: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 28; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Floating point value
        /// </summary>
        public float Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Name of the debug variable
        /// </summary>
        public char[] Name {
            get { return mName; }
            set { mName = value; NotifyUpdated(); }
        }

        public UasNamedValueFloat()
        {
            mMessageId = 251;
            CrcExtra = 170;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mValue);
            s.Write(mName[0]); 
            s.Write(mName[1]); 
            s.Write(mName[2]); 
            s.Write(mName[3]); 
            s.Write(mName[4]); 
            s.Write(mName[5]); 
            s.Write(mName[6]); 
            s.Write(mName[7]); 
            s.Write(mName[8]); 
            s.Write(mName[9]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mValue = s.ReadSingle();
            this.mName[0] = s.ReadChar();
            this.mName[1] = s.ReadChar();
            this.mName[2] = s.ReadChar();
            this.mName[3] = s.ReadChar();
            this.mName[4] = s.ReadChar();
            this.mName[5] = s.ReadChar();
            this.mName[6] = s.ReadChar();
            this.mName[7] = s.ReadChar();
            this.mName[8] = s.ReadChar();
            this.mName[9] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "Floating point value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Name",
                Description = "Name of the debug variable",
                NumElements = 10,
            });

        }

        private UInt32 mTimeBootMs;
        private float mValue;
        private char[] mName = new char[10];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    /// </summary>
    public class UasNamedValueInt: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 28; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Signed integer value
        /// </summary>
        public Int32 Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Name of the debug variable
        /// </summary>
        public char[] Name {
            get { return mName; }
            set { mName = value; NotifyUpdated(); }
        }

        public UasNamedValueInt()
        {
            mMessageId = 252;
            CrcExtra = 44;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mValue);
            s.Write(mName[0]); 
            s.Write(mName[1]); 
            s.Write(mName[2]); 
            s.Write(mName[3]); 
            s.Write(mName[4]); 
            s.Write(mName[5]); 
            s.Write(mName[6]); 
            s.Write(mName[7]); 
            s.Write(mName[8]); 
            s.Write(mName[9]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mValue = s.ReadInt32();
            this.mName[0] = s.ReadChar();
            this.mName[1] = s.ReadChar();
            this.mName[2] = s.ReadChar();
            this.mName[3] = s.ReadChar();
            this.mName[4] = s.ReadChar();
            this.mName[5] = s.ReadChar();
            this.mName[6] = s.ReadChar();
            this.mName[7] = s.ReadChar();
            this.mName[8] = s.ReadChar();
            this.mName[9] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "Signed integer value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Name",
                Description = "Name of the debug variable",
                NumElements = 10,
            });

        }

        private UInt32 mTimeBootMs;
        private Int32 mValue;
        private char[] mName = new char[10];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz).
    /// </summary>
    public class UasStatustext: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 102; }
        }
        /// <summary>
        /// Severity of status. Relies on the definitions within RFC-5424.
        /// </summary>
        public MavSeverity Severity {
            get { return mSeverity; }
            set { mSeverity = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Status text message, without null termination character
        /// </summary>
        public char[] Text {
            get { return mText; }
            set { mText = value; NotifyUpdated(); }
        }

        public UasStatustext()
        {
            mMessageId = 253;
            CrcExtra = 83;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write((byte)mSeverity);
            s.Write(mText[0]); 
            s.Write(mText[1]); 
            s.Write(mText[2]); 
            s.Write(mText[3]); 
            s.Write(mText[4]); 
            s.Write(mText[5]); 
            s.Write(mText[6]); 
            s.Write(mText[7]); 
            s.Write(mText[8]); 
            s.Write(mText[9]); 
            s.Write(mText[10]); 
            s.Write(mText[11]); 
            s.Write(mText[12]); 
            s.Write(mText[13]); 
            s.Write(mText[14]); 
            s.Write(mText[15]); 
            s.Write(mText[16]); 
            s.Write(mText[17]); 
            s.Write(mText[18]); 
            s.Write(mText[19]); 
            s.Write(mText[20]); 
            s.Write(mText[21]); 
            s.Write(mText[22]); 
            s.Write(mText[23]); 
            s.Write(mText[24]); 
            s.Write(mText[25]); 
            s.Write(mText[26]); 
            s.Write(mText[27]); 
            s.Write(mText[28]); 
            s.Write(mText[29]); 
            s.Write(mText[30]); 
            s.Write(mText[31]); 
            s.Write(mText[32]); 
            s.Write(mText[33]); 
            s.Write(mText[34]); 
            s.Write(mText[35]); 
            s.Write(mText[36]); 
            s.Write(mText[37]); 
            s.Write(mText[38]); 
            s.Write(mText[39]); 
            s.Write(mText[40]); 
            s.Write(mText[41]); 
            s.Write(mText[42]); 
            s.Write(mText[43]); 
            s.Write(mText[44]); 
            s.Write(mText[45]); 
            s.Write(mText[46]); 
            s.Write(mText[47]); 
            s.Write(mText[48]); 
            s.Write(mText[49]); 
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mSeverity = (MavSeverity)s.ReadByte();
            this.mText[0] = s.ReadChar();
            this.mText[1] = s.ReadChar();
            this.mText[2] = s.ReadChar();
            this.mText[3] = s.ReadChar();
            this.mText[4] = s.ReadChar();
            this.mText[5] = s.ReadChar();
            this.mText[6] = s.ReadChar();
            this.mText[7] = s.ReadChar();
            this.mText[8] = s.ReadChar();
            this.mText[9] = s.ReadChar();
            this.mText[10] = s.ReadChar();
            this.mText[11] = s.ReadChar();
            this.mText[12] = s.ReadChar();
            this.mText[13] = s.ReadChar();
            this.mText[14] = s.ReadChar();
            this.mText[15] = s.ReadChar();
            this.mText[16] = s.ReadChar();
            this.mText[17] = s.ReadChar();
            this.mText[18] = s.ReadChar();
            this.mText[19] = s.ReadChar();
            this.mText[20] = s.ReadChar();
            this.mText[21] = s.ReadChar();
            this.mText[22] = s.ReadChar();
            this.mText[23] = s.ReadChar();
            this.mText[24] = s.ReadChar();
            this.mText[25] = s.ReadChar();
            this.mText[26] = s.ReadChar();
            this.mText[27] = s.ReadChar();
            this.mText[28] = s.ReadChar();
            this.mText[29] = s.ReadChar();
            this.mText[30] = s.ReadChar();
            this.mText[31] = s.ReadChar();
            this.mText[32] = s.ReadChar();
            this.mText[33] = s.ReadChar();
            this.mText[34] = s.ReadChar();
            this.mText[35] = s.ReadChar();
            this.mText[36] = s.ReadChar();
            this.mText[37] = s.ReadChar();
            this.mText[38] = s.ReadChar();
            this.mText[39] = s.ReadChar();
            this.mText[40] = s.ReadChar();
            this.mText[41] = s.ReadChar();
            this.mText[42] = s.ReadChar();
            this.mText[43] = s.ReadChar();
            this.mText[44] = s.ReadChar();
            this.mText[45] = s.ReadChar();
            this.mText[46] = s.ReadChar();
            this.mText[47] = s.ReadChar();
            this.mText[48] = s.ReadChar();
            this.mText[49] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Severity",
                Description = "Severity of status. Relies on the definitions within RFC-5424.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSeverity"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Text",
                Description = "Status text message, without null termination character",
                NumElements = 50,
            });

        }

        private MavSeverity mSeverity;
        private char[] mText = new char[50];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N.
    /// </summary>
    public class UasDebug: UasMessage
    {
        /// <summary>
        /// Message packet size
        /// </summary>
        public override uint PacketSize {
            get { return 10; }
        }
        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// DEBUG value
        /// </summary>
        public float Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// index of debug variable
        /// </summary>
        public byte Ind {
            get { return mInd; }
            set { mInd = value; NotifyUpdated(); }
        }

        public UasDebug()
        {
            mMessageId = 254;
            CrcExtra = 46;
        }

        internal override void SerializeBody(BinaryWriter s, WireProtocolVersion wireProtocolVersion)
        {
            s.Write(mTimeBootMs);
            s.Write(mValue);
            s.Write(mInd);
        }

        internal override void DeserializeBody(BinaryReader s, WireProtocolVersion wireProtocolVersion)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mValue = s.ReadSingle();
            this.mInd = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (time since system boot).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "DEBUG value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ind",
                Description = "index of debug variable",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mValue;
        private byte mInd;
    }


    // ___________________________________________________________________________________


    public class UasSummary
    {
        public static UasMessage CreateFromId(byte id)
        {
            switch (id)
            {
               case 0: return new UasHeartbeat();
               case 1: return new UasSysStatus();
               case 2: return new UasSystemTime();
               case 4: return new UasPing();
               case 5: return new UasChangeOperatorControl();
               case 6: return new UasChangeOperatorControlAck();
               case 7: return new UasAuthKey();
               case 8: return new UasLinkNodeStatus();
               case 11: return new UasSetMode();
               case 20: return new UasParamRequestRead();
               case 21: return new UasParamRequestList();
               case 22: return new UasParamValue();
               case 23: return new UasParamSet();
               case 24: return new UasGpsRawInt();
               case 25: return new UasGpsStatus();
               case 26: return new UasScaledImu();
               case 27: return new UasRawImu();
               case 28: return new UasRawPressure();
               case 29: return new UasScaledPressure();
               case 30: return new UasAttitude();
               case 31: return new UasAttitudeQuaternion();
               case 32: return new UasLocalPositionNed();
               case 33: return new UasGlobalPositionInt();
               case 34: return new UasRcChannelsScaled();
               case 35: return new UasRcChannelsRaw();
               case 36: return new UasServoOutputRaw();
               case 37: return new UasMissionRequestPartialList();
               case 38: return new UasMissionWritePartialList();
               case 39: return new UasMissionItem();
               case 40: return new UasMissionRequest();
               case 41: return new UasMissionSetCurrent();
               case 42: return new UasMissionCurrent();
               case 43: return new UasMissionRequestList();
               case 44: return new UasMissionCount();
               case 45: return new UasMissionClearAll();
               case 46: return new UasMissionItemReached();
               case 47: return new UasMissionAck();
               case 48: return new UasSetGpsGlobalOrigin();
               case 49: return new UasGpsGlobalOrigin();
               case 50: return new UasParamMapRc();
               case 51: return new UasMissionRequestInt();
               case 54: return new UasSafetySetAllowedArea();
               case 55: return new UasSafetyAllowedArea();
               case 61: return new UasAttitudeQuaternionCov();
               case 62: return new UasNavControllerOutput();
               case 63: return new UasGlobalPositionIntCov();
               case 64: return new UasLocalPositionNedCov();
               case 65: return new UasRcChannels();
               case 66: return new UasRequestDataStream();
               case 67: return new UasDataStream();
               case 69: return new UasManualControl();
               case 70: return new UasRcChannelsOverride();
               case 73: return new UasMissionItemInt();
               case 74: return new UasVfrHud();
               case 75: return new UasCommandInt();
               case 76: return new UasCommandLong();
               case 77: return new UasCommandAck();
               case 80: return new UasCommandCancel();
               case 81: return new UasManualSetpoint();
               case 82: return new UasSetAttitudeTarget();
               case 83: return new UasAttitudeTarget();
               case 84: return new UasSetPositionTargetLocalNed();
               case 85: return new UasPositionTargetLocalNed();
               case 86: return new UasSetPositionTargetGlobalInt();
               case 87: return new UasPositionTargetGlobalInt();
               case 89: return new UasLocalPositionNedSystemGlobalOffset();
               case 90: return new UasHilState();
               case 91: return new UasHilControls();
               case 92: return new UasHilRcInputsRaw();
               case 93: return new UasHilActuatorControls();
               case 100: return new UasOpticalFlow();
               case 101: return new UasGlobalVisionPositionEstimate();
               case 102: return new UasVisionPositionEstimate();
               case 103: return new UasVisionSpeedEstimate();
               case 104: return new UasViconPositionEstimate();
               case 105: return new UasHighresImu();
               case 106: return new UasOpticalFlowRad();
               case 107: return new UasHilSensor();
               case 108: return new UasSimState();
               case 109: return new UasRadioStatus();
               case 110: return new UasFileTransferProtocol();
               case 111: return new UasTimesync();
               case 112: return new UasCameraTrigger();
               case 113: return new UasHilGps();
               case 114: return new UasHilOpticalFlow();
               case 115: return new UasHilStateQuaternion();
               case 116: return new UasScaledImu2();
               case 117: return new UasLogRequestList();
               case 118: return new UasLogEntry();
               case 119: return new UasLogRequestData();
               case 120: return new UasLogData();
               case 121: return new UasLogErase();
               case 122: return new UasLogRequestEnd();
               case 123: return new UasGpsInjectData();
               case 124: return new UasGps2Raw();
               case 125: return new UasPowerStatus();
               case 126: return new UasSerialControl();
               case 127: return new UasGpsRtk();
               case 128: return new UasGps2Rtk();
               case 129: return new UasScaledImu3();
               case 130: return new UasDataTransmissionHandshake();
               case 131: return new UasEncapsulatedData();
               case 132: return new UasDistanceSensor();
               case 133: return new UasTerrainRequest();
               case 134: return new UasTerrainData();
               case 135: return new UasTerrainCheck();
               case 136: return new UasTerrainReport();
               case 137: return new UasScaledPressure2();
               case 138: return new UasAttPosMocap();
               case 139: return new UasSetActuatorControlTarget();
               case 140: return new UasActuatorControlTarget();
               case 141: return new UasAltitude();
               case 142: return new UasResourceRequest();
               case 143: return new UasScaledPressure3();
               case 144: return new UasFollowTarget();
               case 146: return new UasControlSystemState();
               case 147: return new UasBatteryStatus();
               case 148: return new UasAutopilotVersion();
               case 149: return new UasLandingTarget();
               case 162: return new UasFenceStatus();
               case 192: return new UasMagCalReport();
               case 225: return new UasEfiStatus();
               case 230: return new UasEstimatorStatus();
               case 231: return new UasWindCov();
               case 232: return new UasGpsInput();
               case 233: return new UasGpsRtcmData();
               case 234: return new UasHighLatency();
               case 235: return new UasHighLatency2();
               case 241: return new UasVibration();
               case 242: return new UasHomePosition();
               case 243: return new UasSetHomePosition();
               case 244: return new UasMessageInterval();
               case 245: return new UasExtendedSysState();
               case 246: return new UasAdsbVehicle();
               case 247: return new UasCollision();
               case 248: return new UasV2Extension();
               case 249: return new UasMemoryVect();
               case 250: return new UasDebugVect();
               case 251: return new UasNamedValueFloat();
               case 252: return new UasNamedValueInt();
               case 253: return new UasStatustext();
               case 254: return new UasDebug();
               default: return null;
            }
        }

        public static byte GetCrcExtraForId(byte id)
        {
            switch (id)
            {
               case 0: return 50;
               case 1: return 124;
               case 2: return 137;
               case 4: return 237;
               case 5: return 217;
               case 6: return 104;
               case 7: return 119;
               case 8: return 117;
               case 11: return 89;
               case 20: return 214;
               case 21: return 159;
               case 22: return 220;
               case 23: return 168;
               case 24: return 24;
               case 25: return 23;
               case 26: return 170;
               case 27: return 144;
               case 28: return 67;
               case 29: return 115;
               case 30: return 39;
               case 31: return 246;
               case 32: return 185;
               case 33: return 104;
               case 34: return 237;
               case 35: return 244;
               case 36: return 222;
               case 37: return 212;
               case 38: return 9;
               case 39: return 254;
               case 40: return 230;
               case 41: return 28;
               case 42: return 28;
               case 43: return 132;
               case 44: return 221;
               case 45: return 232;
               case 46: return 11;
               case 47: return 153;
               case 48: return 41;
               case 49: return 39;
               case 50: return 78;
               case 51: return 196;
               case 54: return 15;
               case 55: return 3;
               case 61: return 167;
               case 62: return 183;
               case 63: return 119;
               case 64: return 191;
               case 65: return 118;
               case 66: return 148;
               case 67: return 21;
               case 69: return 243;
               case 70: return 124;
               case 73: return 38;
               case 74: return 20;
               case 75: return 158;
               case 76: return 152;
               case 77: return 143;
               case 80: return 14;
               case 81: return 106;
               case 82: return 49;
               case 83: return 22;
               case 84: return 143;
               case 85: return 140;
               case 86: return 5;
               case 87: return 150;
               case 89: return 231;
               case 90: return 183;
               case 91: return 63;
               case 92: return 54;
               case 93: return 47;
               case 100: return 175;
               case 101: return 102;
               case 102: return 158;
               case 103: return 208;
               case 104: return 56;
               case 105: return 93;
               case 106: return 138;
               case 107: return 108;
               case 108: return 32;
               case 109: return 185;
               case 110: return 84;
               case 111: return 34;
               case 112: return 174;
               case 113: return 124;
               case 114: return 237;
               case 115: return 4;
               case 116: return 76;
               case 117: return 128;
               case 118: return 56;
               case 119: return 116;
               case 120: return 134;
               case 121: return 237;
               case 122: return 203;
               case 123: return 250;
               case 124: return 87;
               case 125: return 203;
               case 126: return 220;
               case 127: return 25;
               case 128: return 226;
               case 129: return 46;
               case 130: return 29;
               case 131: return 223;
               case 132: return 85;
               case 133: return 6;
               case 134: return 229;
               case 135: return 203;
               case 136: return 1;
               case 137: return 195;
               case 138: return 109;
               case 139: return 168;
               case 140: return 181;
               case 141: return 47;
               case 142: return 72;
               case 143: return 131;
               case 144: return 127;
               case 146: return 103;
               case 147: return 154;
               case 148: return 178;
               case 149: return 200;
               case 162: return 189;
               case 192: return 36;
               case 225: return 208;
               case 230: return 163;
               case 231: return 105;
               case 232: return 151;
               case 233: return 35;
               case 234: return 150;
               case 235: return 179;
               case 241: return 90;
               case 242: return 104;
               case 243: return 85;
               case 244: return 95;
               case 245: return 130;
               case 246: return 184;
               case 247: return 81;
               case 248: return 8;
               case 249: return 204;
               case 250: return 49;
               case 251: return 170;
               case 252: return 44;
               case 253: return 83;
               case 254: return 46;
               default: return 0;
            }
        }
        private static Dictionary<string, UasEnumMetadata> mEnums;

        public static UasEnumMetadata GetEnumMetadata(string enumName)
        {
            if (mEnums == null) InitEnumMetadata();

            return mEnums[enumName];
        }

        private static void InitEnumMetadata()
        {
            UasEnumMetadata en = null;
            UasEnumEntryMetadata ent = null;
            mEnums = new Dictionary<string, UasEnumMetadata>();

            en = new UasEnumMetadata() {
                Name = "MavAutopilot",
                Description = "Micro air vehicle / autopilot classes. This identifies the individual model.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Generic",
                Description = "Generic autopilot, full support for everything",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Reserved",
                Description = "Reserved for future use.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Slugs",
                Description = "SLUGS autopilot, http://slugsuav.soe.ucsc.edu",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Ardupilotmega",
                Description = "ArduPilot - Plane/Copter/Rover/Sub/Tracker, https://ardupilot.org",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Openpilot",
                Description = "OpenPilot, http://openpilot.org",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "GenericWaypointsOnly",
                Description = "Generic autopilot only supporting simple waypoints",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "GenericWaypointsAndSimpleNavigationOnly",
                Description = "Generic autopilot supporting waypoints and other simple navigation commands",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "GenericMissionFull",
                Description = "Generic autopilot supporting the full mission command set",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Invalid",
                Description = "No valid autopilot, e.g. a GCS or other MAVLink component",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Ppz",
                Description = "PPZ UAV - http://nongnu.org/paparazzi",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Udb",
                Description = "UAV Dev Board",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Fp",
                Description = "FlexiPilot",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Px4",
                Description = "PX4 Autopilot - http://px4.io/",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Smaccmpilot",
                Description = "SMACCMPilot - http://smaccmpilot.org",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Autoquad",
                Description = "AutoQuad -- http://autoquad.org",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Armazila",
                Description = "Armazila -- http://armazila.com",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Aerob",
                Description = "Aerob -- http://aerob.ru",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "Asluav",
                Description = "ASLUAV autopilot -- http://www.asl.ethz.ch",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "Smartap",
                Description = "SmartAP Autopilot - http://sky-drones.com",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "Airrails",
                Description = "AirRails - http://uaventure.com",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "Reflex",
                Description = "Fusion Reflex - https://fusion.engineering",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavType",
                Description = "MAVLINK component type reported in HEARTBEAT message. Flight controllers must report the type of the vehicle on which they are mounted (e.g. MAV_TYPE_OCTOROTOR). All other components must report a value appropriate for their type (e.g. a camera must use MAV_TYPE_CAMERA).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Generic",
                Description = "Generic micro air vehicle",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "FixedWing",
                Description = "Fixed wing aircraft.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Quadrotor",
                Description = "Quadrotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Coaxial",
                Description = "Coaxial helicopter",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Helicopter",
                Description = "Normal helicopter with tail rotor.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "AntennaTracker",
                Description = "Ground installation",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Gcs",
                Description = "Operator control unit / ground control station",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Airship",
                Description = "Airship, controlled",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "FreeBalloon",
                Description = "Free balloon, uncontrolled",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Rocket",
                Description = "Rocket",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "GroundRover",
                Description = "Ground rover",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "SurfaceBoat",
                Description = "Surface vessel, boat, ship",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Submarine",
                Description = "Submarine",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Hexarotor",
                Description = "Hexarotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Octorotor",
                Description = "Octorotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Tricopter",
                Description = "Tricopter",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "FlappingWing",
                Description = "Flapping wing",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "Kite",
                Description = "Kite",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "OnboardController",
                Description = "Onboard companion controller",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "VtolDuorotor",
                Description = "Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "VtolQuadrotor",
                Description = "Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 21,
                Name = "VtolTiltrotor",
                Description = "Tiltrotor VTOL",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 22,
                Name = "VtolReserved2",
                Description = "VTOL reserved 2",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 23,
                Name = "VtolReserved3",
                Description = "VTOL reserved 3",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 24,
                Name = "VtolReserved4",
                Description = "VTOL reserved 4",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 25,
                Name = "VtolReserved5",
                Description = "VTOL reserved 5",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 26,
                Name = "Gimbal",
                Description = "Gimbal",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 27,
                Name = "Adsb",
                Description = "ADSB system",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 28,
                Name = "Parafoil",
                Description = "Steerable, nonrigid airfoil",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 29,
                Name = "Dodecarotor",
                Description = "Dodecarotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30,
                Name = "Camera",
                Description = "Camera",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31,
                Name = "ChargingStation",
                Description = "Charging station",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Flarm",
                Description = "FLARM collision avoidance system",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 33,
                Name = "Servo",
                Description = "Servo",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 34,
                Name = "Odid",
                Description = "Open Drone ID. See https://mavlink.io/en/services/opendroneid.html.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 35,
                Name = "Decarotor",
                Description = "Decarotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 36,
                Name = "Battery",
                Description = "Battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 37,
                Name = "Parachute",
                Description = "Parachute",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavModeFlag",
                Description = "These flags encode the MAV mode.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "SafetyArmed",
                Description = "0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM shall be used instead. The flag can still be used to report the armed state.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "ManualInputEnabled",
                Description = "0b01000000 remote control input is enabled.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "HilEnabled",
                Description = "0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software is full operational.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "StabilizeEnabled",
                Description = "0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further control inputs to move around.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "GuidedEnabled",
                Description = "0b00001000 guided mode enabled, system flies waypoints / mission items.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "AutoEnabled",
                Description = "0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not, depends on the actual implementation.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "TestEnabled",
                Description = "0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CustomModeEnabled",
                Description = "0b00000001 Reserved for future use.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavModeFlagDecodePosition",
                Description = "These values encode the bit positions of the decode position. These values can be used to read the value of a flag bit by combining the base_mode variable with AND with the flag position value. The result will be either 0 or 1, depending on if the flag is set or not.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "Safety",
                Description = "First bit:  10000000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "Manual",
                Description = "Second bit: 01000000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Hil",
                Description = "Third bit:  00100000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Stabilize",
                Description = "Fourth bit: 00010000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Guided",
                Description = "Fifth bit:  00001000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Auto",
                Description = "Sixth bit:   00000100",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Test",
                Description = "Seventh bit: 00000010",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CustomMode",
                Description = "Eighth bit: 00000001",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavState",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Uninit",
                Description = "Uninitialized system, state is unknown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Boot",
                Description = "System is booting up.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Calibrating",
                Description = "System is calibrating and not flight-ready.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Standby",
                Description = "System is grounded and on standby. It can be launched any time.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Active",
                Description = "System is active and might be already airborne. Motors are engaged.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Critical",
                Description = "System is in a non-normal flight mode. It can however still navigate.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Emergency",
                Description = "System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in mayday and going down.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Poweroff",
                Description = "System just initialized its power-down sequence, will shut down now.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "FlightTermination",
                Description = "System is terminating itself.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavComponent",
                Description = "Component ids (values) for the different types and instances of onboard hardware/software that might make up a MAVLink system (autopilot, cameras, servos, GPS systems, avoidance systems etc.).       Components must use the appropriate ID in their source address when sending messages. Components can also use IDs to determine if they are the intended recipient of an incoming message. The MAV_COMP_ID_ALL value is used to indicate messages that must be processed by all components.       When creating new entries, components that can have multiple instances (e.g. cameras, servos etc.) should be allocated sequential values. An appropriate number of values should be left free after these components to allow the number of instances to be expanded.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MavCompIdAll",
                Description = "Target id (target_component) used to broadcast messages to all components of the receiving system. Components should attempt to process messages with this component ID and forward to components on any other interfaces. Note: This is not a valid *source* component id for a message.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavCompIdAutopilot1",
                Description = "System flight controller component ('autopilot'). Only one autopilot is expected in a particular system.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 25,
                Name = "MavCompIdUser1",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 26,
                Name = "MavCompIdUser2",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 27,
                Name = "MavCompIdUser3",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 28,
                Name = "MavCompIdUser4",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 29,
                Name = "MavCompIdUser5",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30,
                Name = "MavCompIdUser6",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31,
                Name = "MavCompIdUser7",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "MavCompIdUser8",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 33,
                Name = "MavCompIdUser9",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 34,
                Name = "MavCompIdUser10",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 35,
                Name = "MavCompIdUser11",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 36,
                Name = "MavCompIdUser12",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 37,
                Name = "MavCompIdUser13",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 38,
                Name = "MavCompIdUser14",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 39,
                Name = "MavCompIdUser15",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 40,
                Name = "MavCompIdUser16",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 41,
                Name = "MavCompIdUser17",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42,
                Name = "MavCompIdUser18",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 43,
                Name = "MavCompIdUser19",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 44,
                Name = "MavCompIdUser20",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 45,
                Name = "MavCompIdUser21",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 46,
                Name = "MavCompIdUser22",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 47,
                Name = "MavCompIdUser23",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 48,
                Name = "MavCompIdUser24",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 49,
                Name = "MavCompIdUser25",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 50,
                Name = "MavCompIdUser26",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 51,
                Name = "MavCompIdUser27",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 52,
                Name = "MavCompIdUser28",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 53,
                Name = "MavCompIdUser29",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 54,
                Name = "MavCompIdUser30",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 55,
                Name = "MavCompIdUser31",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 56,
                Name = "MavCompIdUser32",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 57,
                Name = "MavCompIdUser33",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 58,
                Name = "MavCompIdUser34",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 59,
                Name = "MavCompIdUser35",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 60,
                Name = "MavCompIdUser36",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 61,
                Name = "MavCompIdUser37",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 62,
                Name = "MavCompIdUser38",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 63,
                Name = "MavCompIdUser39",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "MavCompIdUser40",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 65,
                Name = "MavCompIdUser41",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 66,
                Name = "MavCompIdUser42",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 67,
                Name = "MavCompIdUser43",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 68,
                Name = "MavCompIdTelemetryRadio",
                Description = "Telemetry radio (e.g. SiK radio, or other component that emits RADIO_STATUS messages).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 69,
                Name = "MavCompIdUser45",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 70,
                Name = "MavCompIdUser46",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 71,
                Name = "MavCompIdUser47",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 72,
                Name = "MavCompIdUser48",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 73,
                Name = "MavCompIdUser49",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 74,
                Name = "MavCompIdUser50",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 75,
                Name = "MavCompIdUser51",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 76,
                Name = "MavCompIdUser52",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 77,
                Name = "MavCompIdUser53",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 78,
                Name = "MavCompIdUser54",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 79,
                Name = "MavCompIdUser55",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 80,
                Name = "MavCompIdUser56",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 81,
                Name = "MavCompIdUser57",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 82,
                Name = "MavCompIdUser58",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 83,
                Name = "MavCompIdUser59",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 84,
                Name = "MavCompIdUser60",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 85,
                Name = "MavCompIdUser61",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 86,
                Name = "MavCompIdUser62",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 87,
                Name = "MavCompIdUser63",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 88,
                Name = "MavCompIdUser64",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 89,
                Name = "MavCompIdUser65",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 90,
                Name = "MavCompIdUser66",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 91,
                Name = "MavCompIdUser67",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 92,
                Name = "MavCompIdUser68",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 93,
                Name = "MavCompIdUser69",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 94,
                Name = "MavCompIdUser70",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 95,
                Name = "MavCompIdUser71",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 96,
                Name = "MavCompIdUser72",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 97,
                Name = "MavCompIdUser73",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 98,
                Name = "MavCompIdUser74",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 99,
                Name = "MavCompIdUser75",
                Description = "Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 100,
                Name = "MavCompIdCamera",
                Description = "Camera #1.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 101,
                Name = "MavCompIdCamera2",
                Description = "Camera #2.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 102,
                Name = "MavCompIdCamera3",
                Description = "Camera #3.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 103,
                Name = "MavCompIdCamera4",
                Description = "Camera #4.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 104,
                Name = "MavCompIdCamera5",
                Description = "Camera #5.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 105,
                Name = "MavCompIdCamera6",
                Description = "Camera #6.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 140,
                Name = "MavCompIdServo1",
                Description = "Servo #1.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 141,
                Name = "MavCompIdServo2",
                Description = "Servo #2.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 142,
                Name = "MavCompIdServo3",
                Description = "Servo #3.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 143,
                Name = "MavCompIdServo4",
                Description = "Servo #4.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 144,
                Name = "MavCompIdServo5",
                Description = "Servo #5.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 145,
                Name = "MavCompIdServo6",
                Description = "Servo #6.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 146,
                Name = "MavCompIdServo7",
                Description = "Servo #7.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 147,
                Name = "MavCompIdServo8",
                Description = "Servo #8.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 148,
                Name = "MavCompIdServo9",
                Description = "Servo #9.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 149,
                Name = "MavCompIdServo10",
                Description = "Servo #10.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 150,
                Name = "MavCompIdServo11",
                Description = "Servo #11.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 151,
                Name = "MavCompIdServo12",
                Description = "Servo #12.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 152,
                Name = "MavCompIdServo13",
                Description = "Servo #13.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 153,
                Name = "MavCompIdServo14",
                Description = "Servo #14.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 154,
                Name = "MavCompIdGimbal",
                Description = "Gimbal #1.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 155,
                Name = "MavCompIdLog",
                Description = "Logging component.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 156,
                Name = "MavCompIdAdsb",
                Description = "Automatic Dependent Surveillance-Broadcast (ADS-B) component.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 157,
                Name = "MavCompIdOsd",
                Description = "On Screen Display (OSD) devices for video links.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 158,
                Name = "MavCompIdPeripheral",
                Description = "Generic autopilot peripheral component ID. Meant for devices that do not implement the parameter microservice.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 159,
                Name = "MavCompIdQx1Gimbal",
                Description = "Gimbal ID for QX1.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 160,
                Name = "MavCompIdFlarm",
                Description = "FLARM collision alert component.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 161,
                Name = "MavCompIdParachute",
                Description = "Parachute component.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 171,
                Name = "MavCompIdGimbal2",
                Description = "Gimbal #2.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 172,
                Name = "MavCompIdGimbal3",
                Description = "Gimbal #3.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 173,
                Name = "MavCompIdGimbal4",
                Description = "Gimbal #4",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 174,
                Name = "MavCompIdGimbal5",
                Description = "Gimbal #5.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 175,
                Name = "MavCompIdGimbal6",
                Description = "Gimbal #6.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 180,
                Name = "MavCompIdBattery",
                Description = "Battery #1.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 181,
                Name = "MavCompIdBattery2",
                Description = "Battery #2.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 190,
                Name = "MavCompIdMissionplanner",
                Description = "Component that can generate/supply a mission flight plan (e.g. GCS or developer API).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 191,
                Name = "MavCompIdOnboardComputer",
                Description = "Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 192,
                Name = "MavCompIdOnboardComputer2",
                Description = "Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 193,
                Name = "MavCompIdOnboardComputer3",
                Description = "Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 194,
                Name = "MavCompIdOnboardComputer4",
                Description = "Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 195,
                Name = "MavCompIdPathplanner",
                Description = "Component that finds an optimal path between points based on a certain constraint (e.g. minimum snap, shortest path, cost, etc.).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 196,
                Name = "MavCompIdObstacleAvoidance",
                Description = "Component that plans a collision free path between two points.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 197,
                Name = "MavCompIdVisualInertialOdometry",
                Description = "Component that provides position estimates using VIO techniques.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 198,
                Name = "MavCompIdPairingManager",
                Description = "Component that manages pairing of vehicle and GCS.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 200,
                Name = "MavCompIdImu",
                Description = "Inertial Measurement Unit (IMU) #1.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 201,
                Name = "MavCompIdImu2",
                Description = "Inertial Measurement Unit (IMU) #2.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 202,
                Name = "MavCompIdImu3",
                Description = "Inertial Measurement Unit (IMU) #3.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 220,
                Name = "MavCompIdGps",
                Description = "GPS #1.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 221,
                Name = "MavCompIdGps2",
                Description = "GPS #2.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 236,
                Name = "MavCompIdOdidTxrx1",
                Description = "Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 237,
                Name = "MavCompIdOdidTxrx2",
                Description = "Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 238,
                Name = "MavCompIdOdidTxrx3",
                Description = "Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 240,
                Name = "MavCompIdUdpBridge",
                Description = "Component to bridge MAVLink to UDP (i.e. from a UART).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 241,
                Name = "MavCompIdUartBridge",
                Description = "Component to bridge to UART (i.e. from UDP).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 242,
                Name = "MavCompIdTunnelNode",
                Description = "Component handling TUNNEL messages (e.g. vendor specific GUI of a component).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 250,
                Name = "MavCompIdSystemControl",
                Description = "Component for handling system messages (e.g. to ARM, takeoff, etc.).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FirmwareVersionType",
                Description = "These values define the type of firmware release.  These values indicate the first version or release of this type.  For example the first alpha release would be 64, the second would be 65.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Dev",
                Description = "development release",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "Alpha",
                Description = "alpha release",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "Beta",
                Description = "beta release",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 192,
                Name = "Rc",
                Description = "release candidate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 255,
                Name = "Official",
                Description = "official stable release",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "HlFailureFlag",
                Description = "Flags to report failure cases over the high latency telemtry.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Gps",
                Description = "GPS failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "DifferentialPressure",
                Description = "Differential pressure sensor failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "AbsolutePressure",
                Description = "Absolute pressure sensor failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "_3dAccel",
                Description = "Accelerometer sensor failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "_3dGyro",
                Description = "Gyroscope sensor failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "_3dMag",
                Description = "Magnetometer sensor failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "Terrain",
                Description = "Terrain subsystem failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "Battery",
                Description = "Battery failure/critical low battery.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "RcReceiver",
                Description = "RC receiver failure/no rc connection.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "OffboardLink",
                Description = "Offboard link failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "Engine",
                Description = "Engine failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "Geofence",
                Description = "Geofence violation.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "Estimator",
                Description = "Estimator failure, for example measurement rejection or large variances.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8192,
                Name = "Mission",
                Description = "Mission failure.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavGoto",
                Description = "Actions that may be specified in MAV_CMD_OVERRIDE_GOTO to override mission execution.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "DoHold",
                Description = "Hold at the current position.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "DoContinue",
                Description = "Continue with the next item in mission execution.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HoldAtCurrentPosition",
                Description = "Hold at the current position of the system",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "HoldAtSpecifiedPosition",
                Description = "Hold at the position specified in the parameters of the DO_HOLD action",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavMode",
                Description = "These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it                simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Preflight",
                Description = "System is not ready to fly, booting, calibrating, etc. No flag is set.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 80,
                Name = "StabilizeDisarmed",
                Description = "System is allowed to be active, under assisted RC control.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 208,
                Name = "StabilizeArmed",
                Description = "System is allowed to be active, under assisted RC control.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "ManualDisarmed",
                Description = "System is allowed to be active, under manual (RC) control, no stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 192,
                Name = "ManualArmed",
                Description = "System is allowed to be active, under manual (RC) control, no stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 88,
                Name = "GuidedDisarmed",
                Description = "System is allowed to be active, under autonomous control, manual setpoint",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 216,
                Name = "GuidedArmed",
                Description = "System is allowed to be active, under autonomous control, manual setpoint",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 92,
                Name = "AutoDisarmed",
                Description = "System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 220,
                Name = "AutoArmed",
                Description = "System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 66,
                Name = "TestDisarmed",
                Description = "UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 194,
                Name = "TestArmed",
                Description = "UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavSysStatusSensor",
                Description = "These encode the sensors whose status is sent as part of the SYS_STATUS message.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_3dGyro",
                Description = "0x01 3D gyro",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_3dAccel",
                Description = "0x02 3D accelerometer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_3dMag",
                Description = "0x04 3D magnetometer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "AbsolutePressure",
                Description = "0x08 absolute pressure",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "DifferentialPressure",
                Description = "0x10 differential pressure",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Gps",
                Description = "0x20 GPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "OpticalFlow",
                Description = "0x40 optical flow",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "VisionPosition",
                Description = "0x80 computer vision position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "LaserPosition",
                Description = "0x100 laser based position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "ExternalGroundTruth",
                Description = "0x200 external ground truth (Vicon or Leica)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "AngularRateControl",
                Description = "0x400 3D angular rate control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "AttitudeStabilization",
                Description = "0x800 attitude stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "YawPosition",
                Description = "0x1000 yaw position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8192,
                Name = "ZAltitudeControl",
                Description = "0x2000 z/altitude control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16384,
                Name = "XyPositionControl",
                Description = "0x4000 x/y position control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32768,
                Name = "MotorOutputs",
                Description = "0x8000 motor outputs / control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 65536,
                Name = "RcReceiver",
                Description = "0x10000 rc receiver",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 131072,
                Name = "_3dGyro2",
                Description = "0x20000 2nd 3D gyro",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 262144,
                Name = "_3dAccel2",
                Description = "0x40000 2nd 3D accelerometer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 524288,
                Name = "_3dMag2",
                Description = "0x80000 2nd 3D magnetometer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1048576,
                Name = "MavSysStatusGeofence",
                Description = "0x100000 geofence",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2097152,
                Name = "MavSysStatusAhrs",
                Description = "0x200000 AHRS subsystem health",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4194304,
                Name = "MavSysStatusTerrain",
                Description = "0x400000 Terrain subsystem health",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8388608,
                Name = "MavSysStatusReverseMotor",
                Description = "0x800000 Motors are reversed",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16777216,
                Name = "MavSysStatusLogging",
                Description = "0x1000000 Logging",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 33554432,
                Name = "Battery",
                Description = "0x2000000 Battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 67108864,
                Name = "Proximity",
                Description = "0x4000000 Proximity",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 134217728,
                Name = "Satcom",
                Description = "0x8000000 Satellite Communication ",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 268435456,
                Name = "MavSysStatusPrearmCheck",
                Description = "0x10000000 pre-arm check status. Always healthy when armed",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 536870912,
                Name = "MavSysStatusObstacleAvoidance",
                Description = "0x20000000 Avoidance/collision prevention",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1073741824,
                Name = "Propulsion",
                Description = "0x40000000 propulsion (actuator, esc, motor or propellor)",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavFrame",
                Description = "Co-ordinate frames used by MAVLink. Not all frames are supported by all commands, messages, or vehicles.              Global frames use the following naming conventions:       - `GLOBAL`: Global co-ordinate frame with WGS84 latitude/longitude and altitude positive over mean sea level (MSL) by default.          The following modifiers may be used with `GLOBAL`:         - `RELATIVE_ALT`: Altitude is relative to the vehicle home position rather than MSL         - `TERRAIN_ALT`: Altitude is relative to ground level rather than MSL         - `INT`: Latitude/longitude (in degrees) are scaled by multiplying by 1E7          Local frames use the following naming conventions:       - `LOCAL`: Origin of local frame is fixed relative to earth. Unless otherwise specified this origin is the origin of the vehicle position-estimator ('EKF').       - `BODY`: Origin of local frame travels with the vehicle. NOTE, `BODY` does NOT indicate alignment of frame axis with vehicle attitude.       - `OFFSET`: Deprecated synonym for `BODY` (origin travels with the vehicle). Not to be used for new frames.        Some deprecated frames do not follow these conventions (e.g. MAV_FRAME_BODY_NED and MAV_FRAME_BODY_OFFSET_NED).  ",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Global",
                Description = "Global (WGS84) coordinate frame + MSL altitude. First value / x: latitude, second value / y: longitude, third value / z: positive altitude over mean sea level (MSL).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "LocalNed",
                Description = "NED local tangent frame (x: North, y: East, z: Down) with origin fixed relative to earth.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Mission",
                Description = "NOT a coordinate frame, indicates a mission command.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "GlobalRelativeAlt",
                Description = "Global (WGS84) coordinate frame + altitude relative to the home position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude with 0 being at the altitude of the home location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "LocalEnu",
                Description = "ENU local tangent frame (x: East, y: North, z: Up) with origin fixed relative to earth.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "GlobalInt",
                Description = "Global (WGS84) coordinate frame (scaled) + MSL altitude. First value / x: latitude in degrees*1E7, second value / y: longitude in degrees*1E7, third value / z: positive altitude over mean sea level (MSL).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "GlobalRelativeAltInt",
                Description = "Global (WGS84) coordinate frame (scaled) + altitude relative to the home position. First value / x: latitude in degrees*1E7, second value / y: longitude in degrees*1E7, third value / z: positive altitude with 0 being at the altitude of the home location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "LocalOffsetNed",
                Description = "NED local tangent frame (x: North, y: East, z: Down) with origin that travels with the vehicle.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "BodyNed",
                Description = "Same as MAV_FRAME_LOCAL_NED when used to represent position values. Same as MAV_FRAME_BODY_FRD when used with velocity/accelaration values.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "BodyOffsetNed",
                Description = "This is the same as MAV_FRAME_BODY_FRD.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "GlobalTerrainAlt",
                Description = "Global (WGS84) coordinate frame with AGL altitude (at the waypoint coordinate). First value / x: latitude in degrees, second value / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level in terrain model.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "GlobalTerrainAltInt",
                Description = "Global (WGS84) coordinate frame (scaled) with AGL altitude (at the waypoint coordinate). First value / x: latitude in degrees*1E7, second value / y: longitude in degrees*1E7, third value / z: positive altitude in meters with 0 being at ground level in terrain model.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "BodyFrd",
                Description = "FRD local tangent frame (x: Forward, y: Right, z: Down) with origin that travels with vehicle. The forward axis is aligned to the front of the vehicle in the horizontal plane.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Reserved13",
                Description = "MAV_FRAME_BODY_FLU - Body fixed frame of reference, Z-up (x: Forward, y: Left, z: Up).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Reserved14",
                Description = "MAV_FRAME_MOCAP_NED - Odometry local coordinate frame of data given by a motion capture system, Z-down (x: North, y: East, z: Down).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Reserved15",
                Description = "MAV_FRAME_MOCAP_ENU - Odometry local coordinate frame of data given by a motion capture system, Z-up (x: East, y: North, z: Up).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Reserved16",
                Description = "MAV_FRAME_VISION_NED - Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: North, y: East, z: Down).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "Reserved17",
                Description = "MAV_FRAME_VISION_ENU - Odometry local coordinate frame of data given by a vision estimation system, Z-up (x: East, y: North, z: Up).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "Reserved18",
                Description = "MAV_FRAME_ESTIM_NED - Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: North, y: East, z: Down).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "Reserved19",
                Description = "MAV_FRAME_ESTIM_ENU - Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-up (x: East, y: North, z: Up).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "LocalFrd",
                Description = "FRD local tangent frame (x: Forward, y: Right, z: Down) with origin fixed relative to earth. The forward axis is aligned to the front of the vehicle in the horizontal plane.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 21,
                Name = "LocalFlu",
                Description = "FLU local tangent frame (x: Forward, y: Left, z: Up) with origin fixed relative to earth. The forward axis is aligned to the front of the vehicle in the horizontal plane.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavlinkDataStreamType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MavlinkDataStreamImgJpeg",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavlinkDataStreamImgBmp",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavlinkDataStreamImgRaw8u",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MavlinkDataStreamImgRaw32u",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavlinkDataStreamImgPgm",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "MavlinkDataStreamImgPng",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FenceAction",
                Description = "Actions following geofence breach.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "Disable fenced mode. If used in a plan this would mean the next fence is disabled.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Guided",
                Description = "Fly to geofence MAV_CMD_NAV_FENCE_RETURN_POINT in GUIDED mode. Note: This action is only supported by ArduPlane, and may not be supported in all versions.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Report",
                Description = "Report fence breach, but don't take action",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "GuidedThrPass",
                Description = "Fly to geofence MAV_CMD_NAV_FENCE_RETURN_POINT with manual throttle control in GUIDED mode. Note: This action is only supported by ArduPlane, and may not be supported in all versions.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Rtl",
                Description = "Return/RTL mode.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Hold",
                Description = "Hold at current location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Terminate",
                Description = "Termination failsafe. Motors are shut down (some flight stacks may trigger other failsafe actions).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Land",
                Description = "Land at current location.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FenceBreach",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No last fence breach",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Minalt",
                Description = "Breached minimum altitude",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Maxalt",
                Description = "Breached maximum altitude",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Boundary",
                Description = "Breached fence boundary",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FenceMitigate",
                Description = "Actions being taken to mitigate/prevent fence breach",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Unknown",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "None",
                Description = "No actions being taken",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "VelLimit",
                Description = "Velocity limiting active to prevent breach",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavMountMode",
                Description = "Enumeration of possible mount operation modes. This message is used by obsolete/deprecated gimbal messages.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Retract",
                Description = "Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Neutral",
                Description = "Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavlinkTargeting",
                Description = "Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "RcTargeting",
                Description = "Load neutral position and start RC Roll,Pitch,Yaw control with stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "GpsPoint",
                Description = "Load neutral position and start to point to Lat,Lon,Alt",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "SysidTarget",
                Description = "Gimbal tracks system with specified system ID",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "HomeLocation",
                Description = "Gimbal tracks home location",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GimbalDeviceCapFlags",
                Description = "Gimbal device (low level) capability flags (bitmap)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "HasRetract",
                Description = "Gimbal device supports a retracted position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HasNeutral",
                Description = "Gimbal device supports a horizontal, forward looking position, stabilized",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "HasRollAxis",
                Description = "Gimbal device supports rotating around roll axis.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "HasRollFollow",
                Description = "Gimbal device supports to follow a roll angle relative to the vehicle",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "HasRollLock",
                Description = "Gimbal device supports locking to an roll angle (generally that's the default with roll stabilized)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "HasPitchAxis",
                Description = "Gimbal device supports rotating around pitch axis.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "HasPitchFollow",
                Description = "Gimbal device supports to follow a pitch angle relative to the vehicle",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "HasPitchLock",
                Description = "Gimbal device supports locking to an pitch angle (generally that's the default with pitch stabilized)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "HasYawAxis",
                Description = "Gimbal device supports rotating around yaw axis.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "HasYawFollow",
                Description = "Gimbal device supports to follow a yaw angle relative to the vehicle (generally that's the default)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "HasYawLock",
                Description = "Gimbal device supports locking to an absolute heading (often this is an option available)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "SupportsInfiniteYaw",
                Description = "Gimbal device supports yawing/panning infinetely (e.g. using slip disk).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GimbalManagerCapFlags",
                Description = "Gimbal manager high level capability flags (bitmap). The first 16 bits are identical to the GIMBAL_DEVICE_CAP_FLAGS. However, the gimbal manager does not need to copy the flags from the gimbal but can also enhance the capabilities and thus add flags.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "HasRetract",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HasNeutral",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_NEUTRAL.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "HasRollAxis",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_AXIS.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "HasRollFollow",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_FOLLOW.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "HasRollLock",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_LOCK.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "HasPitchAxis",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_AXIS.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "HasPitchFollow",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_FOLLOW.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "HasPitchLock",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_LOCK.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "HasYawAxis",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_AXIS.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "HasYawFollow",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_FOLLOW.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "HasYawLock",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_LOCK.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "SupportsInfiniteYaw",
                Description = "Based on GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_INFINITE_YAW.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 65536,
                Name = "CanPointLocationLocal",
                Description = "Gimbal manager supports to point to a local position.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 131072,
                Name = "CanPointLocationGlobal",
                Description = "Gimbal manager supports to point to a global latitude, longitude, altitude position.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GimbalDeviceFlags",
                Description = "Flags for gimbal device (lower level) operation.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Retract",
                Description = "Set to retracted safe position (no stabilization), takes presedence over all other flags.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Neutral",
                Description = "Set to neutral position (horizontal, forward looking, with stabiliziation), takes presedence over all other flags except RETRACT.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "RollLock",
                Description = "Lock roll angle to absolute angle relative to horizon (not relative to drone). This is generally the default with a stabilizing gimbal.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "PitchLock",
                Description = "Lock pitch angle to absolute angle relative to horizon (not relative to drone). This is generally the default.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "YawLock",
                Description = "Lock yaw angle to absolute angle relative to North (not relative to drone). If this flag is set, the quaternion is in the Earth frame with the x-axis pointing North (yaw absolute). If this flag is not set, the quaternion frame is in the Earth frame rotated so that the x-axis is pointing forward (yaw relative to vehicle).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GimbalManagerFlags",
                Description = "Flags for high level gimbal manager operation The first 16 bits are identical to the GIMBAL_DEVICE_FLAGS.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Retract",
                Description = "Based on GIMBAL_DEVICE_FLAGS_RETRACT",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Neutral",
                Description = "Based on GIMBAL_DEVICE_FLAGS_NEUTRAL",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "RollLock",
                Description = "Based on GIMBAL_DEVICE_FLAGS_ROLL_LOCK",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "PitchLock",
                Description = "Based on GIMBAL_DEVICE_FLAGS_PITCH_LOCK",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "YawLock",
                Description = "Based on GIMBAL_DEVICE_FLAGS_YAW_LOCK",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GimbalDeviceErrorFlags",
                Description = "Gimbal device (low level) error flags (bitmap, 0 means no error)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "AtRollLimit",
                Description = "Gimbal device is limited by hardware roll limit.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "AtPitchLimit",
                Description = "Gimbal device is limited by hardware pitch limit.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "AtYawLimit",
                Description = "Gimbal device is limited by hardware yaw limit.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "EncoderError",
                Description = "There is an error with the gimbal encoders.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "PowerError",
                Description = "There is an error with the gimbal power source.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "MotorError",
                Description = "There is an error with the gimbal motor's.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "SoftwareError",
                Description = "There is an error with the gimbal's software.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "CommsError",
                Description = "There is an error with the gimbal's communication.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "CalibrationRunning",
                Description = "Gimbal is currently calibrating.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GripperActions",
                Description = "Gripper actions.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "GripperActionRelease",
                Description = "Gripper release cargo.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "GripperActionGrab",
                Description = "Gripper grab onto cargo.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "WinchActions",
                Description = "Winch actions.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "WinchRelaxed",
                Description = "Relax winch.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "WinchRelativeLengthControl",
                Description = "Wind or unwind specified length of cable, optionally using specified rate.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "WinchRateControl",
                Description = "Wind or unwind cable at specified rate.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "UavcanNodeHealth",
                Description = "Generalized UAVCAN node health",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Ok",
                Description = "The node is functioning properly.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Warning",
                Description = "A critical parameter went out of range or the node has encountered a minor failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Error",
                Description = "The node has encountered a major failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Critical",
                Description = "The node has suffered a fatal malfunction.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "UavcanNodeMode",
                Description = "Generalized UAVCAN node mode",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Operational",
                Description = "The node is performing its primary functions.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Initialization",
                Description = "The node is initializing; this mode is entered immediately after startup.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Maintenance",
                Description = "The node is under maintenance.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "SoftwareUpdate",
                Description = "The node is in the process of updating its software.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Offline",
                Description = "The node is no longer available online.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "EscConnectionType",
                Description = "Indicates the ESC connection type.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Ppm",
                Description = "Traditional PPM ESC.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Serial",
                Description = "Serial Bus connected ESC.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Oneshot",
                Description = "One Shot PPM ESC.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "I2c",
                Description = "I2C ESC.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Can",
                Description = "CAN-Bus ESC.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Dshot",
                Description = "DShot ESC.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "EscFailureFlags",
                Description = "Flags to report ESC failures.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "EscFailureNone",
                Description = "No ESC failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "EscFailureOverCurrent",
                Description = "Over current failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "EscFailureOverVoltage",
                Description = "Over voltage failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "EscFailureOverTemperature",
                Description = "Over temperature failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "EscFailureOverRpm",
                Description = "Over RPM failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "EscFailureInconsistentCmd",
                Description = "Inconsistent command failure i.e. out of bounds.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "EscFailureMotorStuck",
                Description = "Motor stuck failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "EscFailureGeneric",
                Description = "Generic ESC failure.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "StorageStatus",
                Description = "Flags to indicate the status of camera storage.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Empty",
                Description = "Storage is missing (no microSD card loaded for example.)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Unformatted",
                Description = "Storage present but unformatted.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Ready",
                Description = "Storage present and ready.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "NotSupported",
                Description = "Camera does not supply storage status information. Capacity information in STORAGE_INFORMATION fields will be ignored.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "StorageType",
                Description = "Flags to indicate the type of storage.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Storage type is not known.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "UsbStick",
                Description = "Storage type is USB device.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Sd",
                Description = "Storage type is SD card.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Microsd",
                Description = "Storage type is microSD card.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Cf",
                Description = "Storage type is CFast.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Cfe",
                Description = "Storage type is CFexpress.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Xqd",
                Description = "Storage type is XQD.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Hd",
                Description = "Storage type is HD mass storage type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 254,
                Name = "Other",
                Description = "Storage type is other, not listed type.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "StorageUsageFlag",
                Description = "Flags to indicate usage for a particular storage (see `STORAGE_INFORMATION.storage_usage` and `MAV_CMD_SET_STORAGE_USAGE`).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Set",
                Description = "Always set to 1 (indicates `STORAGE_INFORMATION.storage_usage` is supported).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Photo",
                Description = "Storage for saving photos.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Video",
                Description = "Storage for saving videos.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Logs",
                Description = "Storage for saving logs.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "OrbitYawBehaviour",
                Description = "Yaw behaviour during orbit flight.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "HoldFrontToCircleCenter",
                Description = "Vehicle front points to the center (default).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "HoldInitialHeading",
                Description = "Vehicle front holds heading when message received.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Uncontrolled",
                Description = "Yaw uncontrolled.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "HoldFrontTangentToCircle",
                Description = "Vehicle front follows flight path (tangential to circle).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "RcControlled",
                Description = "Yaw controlled by RC input.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "WifiConfigApResponse",
                Description = "Possible responses from a WIFI_CONFIG_AP message.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undefined",
                Description = "Undefined response. Likely an indicative of a system that doesn't support this request.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Accepted",
                Description = "Changes accepted.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Rejected",
                Description = "Changes rejected.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "ModeError",
                Description = "Invalid Mode.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "SsidError",
                Description = "Invalid SSID.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "PasswordError",
                Description = "Invalid Password.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CellularConfigResponse",
                Description = "Possible responses from a CELLULAR_CONFIG message.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Accepted",
                Description = "Changes accepted.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ApnError",
                Description = "Invalid APN.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "PinError",
                Description = "Invalid PIN.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Rejected",
                Description = "Changes rejected.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "CellularConfigBlockedPukRequired",
                Description = "PUK is required to unblock SIM card.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "WifiConfigApMode",
                Description = "WiFi Mode.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undefined",
                Description = "WiFi mode is undefined.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Ap",
                Description = "WiFi configured as an access point.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Station",
                Description = "WiFi configured as a station connected to an existing local WiFi network.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Disabled",
                Description = "WiFi disabled.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CompMetadataType",
                Description = "Supported component metadata types. These are used in the 'general' metadata file returned by COMPONENT_INFORMATION to provide information about supported metadata types. The types are not used directly in MAVLink messages.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "General",
                Description = "General information about the component. General metadata includes information about other COMP_METADATA_TYPEs supported by the component. This type must be supported and must be downloadable from vehicle.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Parameter",
                Description = "Parameter meta data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Commands",
                Description = "Meta data that specifies which commands and command parameters the vehicle supports. (WIP)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Peripherals",
                Description = "Meta data that specifies external non-MAVLink peripherals.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Events",
                Description = "Meta data for the events interface.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavCmd",
                Description = "Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data. NaN and INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current yaw or latitude rather than a specific value). See https://mavlink.io/en/guide/xml_schema.html#MAV_CMD for information about the structure of the MAV_CMD entries",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "NavWaypoint",
                Description = "Navigate to waypoint.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Hold time. (ignored by fixed wing, time to stay at waypoint for rotary wing)");
            ent.Params.Add("Acceptance radius (if the sphere with this radius is hit, the waypoint counts as reached)");
            ent.Params.Add("0 to pass through the WP, if > 0 radius to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control.");
            ent.Params.Add("Desired yaw angle at waypoint (rotary wing). NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.).");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "NavLoiterUnlim",
                Description = "Loiter around this waypoint an unlimited amount of time",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Loiter radius around waypoint for forward-only moving vehicles (not multicopters). If positive loiter clockwise, else counter-clockwise");
            ent.Params.Add("Desired yaw angle. NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.).");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "NavLoiterTurns",
                Description = "Loiter around this waypoint for X turns",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Number of turns.");
            ent.Params.Add("Leave loiter circle only once heading towards the next waypoint (0 = False)");
            ent.Params.Add("Loiter radius around waypoint for forward-only moving vehicles (not multicopters). If positive loiter clockwise, else counter-clockwise");
            ent.Params.Add("Loiter circle exit location and/or path to next waypoint ('xtrack') for forward-only moving vehicles (not multicopters). 0 for the vehicle to converge towards the center xtrack when it leaves the loiter (the line between the centers of the current and next waypoint), 1 to converge to the direct line between the location that the vehicle exits the loiter radius and the next waypoint. Otherwise the angle (in degrees) between the tangent of the loiter circle and the center xtrack at which the vehicle must leave the loiter (and converge to the center xtrack). NaN to use the current system default xtrack behaviour.");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "NavLoiterTime",
                Description = "Loiter at the specified latitude, longitude and altitude for a certain amount of time. Multicopter vehicles stop at the point (within a vehicle-specific acceptance radius). Forward-only moving vehicles (e.g. fixed-wing) circle the point with the specified radius/direction. If the Heading Required parameter (2) is non-zero forward moving aircraft will only leave the loiter circle once heading towards the next waypoint.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Loiter time (only starts once Lat, Lon and Alt is reached).");
            ent.Params.Add("Leave loiter circle only once heading towards the next waypoint (0 = False)");
            ent.Params.Add("Loiter radius around waypoint for forward-only moving vehicles (not multicopters). If positive loiter clockwise, else counter-clockwise.");
            ent.Params.Add("Loiter circle exit location and/or path to next waypoint ('xtrack') for forward-only moving vehicles (not multicopters). 0 for the vehicle to converge towards the center xtrack when it leaves the loiter (the line between the centers of the current and next waypoint), 1 to converge to the direct line between the location that the vehicle exits the loiter radius and the next waypoint. Otherwise the angle (in degrees) between the tangent of the loiter circle and the center xtrack at which the vehicle must leave the loiter (and converge to the center xtrack). NaN to use the current system default xtrack behaviour.");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "NavReturnToLaunch",
                Description = "Return to launch location",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 21,
                Name = "NavLand",
                Description = "Land at location.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Minimum target altitude if landing is aborted (0 = undefined/use system default).");
            ent.Params.Add("Precision land mode.");
            ent.Params.Add("Empty.");
            ent.Params.Add("Desired yaw angle. NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.).");
            ent.Params.Add("Latitude.");
            ent.Params.Add("Longitude.");
            ent.Params.Add("Landing altitude (ground level in current frame).");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 22,
                Name = "NavTakeoff",
                Description = "Takeoff from ground / hand. Vehicles that support multiple takeoff modes (e.g. VTOL quadplane) should take off using the currently configured mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Minimum pitch (if airspeed sensor present), desired pitch without sensor");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Yaw angle (if magnetometer present), ignored without magnetometer. NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.).");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 23,
                Name = "NavLandLocal",
                Description = "Land at local position (local frame only)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Landing target number (if available)");
            ent.Params.Add("Maximum accepted offset from desired landing position - computed magnitude from spherical coordinates: d = sqrt(x^2 + y^2 + z^2), which gives the maximum accepted distance between the desired landing position and the position where the vehicle is about to land");
            ent.Params.Add("Landing descend rate");
            ent.Params.Add("Desired yaw angle");
            ent.Params.Add("Y-axis position");
            ent.Params.Add("X-axis position");
            ent.Params.Add("Z-axis / ground level position");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 24,
                Name = "NavTakeoffLocal",
                Description = "Takeoff from local position (local frame only)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Minimum pitch (if airspeed sensor present), desired pitch without sensor");
            ent.Params.Add("Empty");
            ent.Params.Add("Takeoff ascend rate");
            ent.Params.Add("Yaw angle (if magnetometer or another yaw estimation source present), ignored without one of these");
            ent.Params.Add("Y-axis position");
            ent.Params.Add("X-axis position");
            ent.Params.Add("Z-axis position");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 25,
                Name = "NavFollow",
                Description = "Vehicle following, i.e. this waypoint represents the position of a moving vehicle",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Following logic to use (e.g. loitering or sinusoidal following) - depends on specific autopilot implementation");
            ent.Params.Add("Ground speed of vehicle to be followed");
            ent.Params.Add("Radius around waypoint. If positive loiter clockwise, else counter-clockwise");
            ent.Params.Add("Desired yaw angle.");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30,
                Name = "NavContinueAndChangeAlt",
                Description = "Continue on the current course and climb/descend to specified altitude.  When the altitude is reached continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Climb or Descend (0 = Neutral, command completes when within 5m of this command's altitude, 1 = Climbing, command completes when at or above this command's altitude, 2 = Descending, command completes when at or below this command's altitude.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Desired altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31,
                Name = "NavLoiterToAlt",
                Description = "Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.  Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached. Additionally, if the Heading Required parameter is non-zero the aircraft will not leave the loiter until heading toward the next waypoint.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Leave loiter circle only once heading towards the next waypoint (0 = False)");
            ent.Params.Add("Loiter radius around waypoint for forward-only moving vehicles (not multicopters). If positive loiter clockwise, negative counter-clockwise, 0 means no change to standard loiter.");
            ent.Params.Add("Empty");
            ent.Params.Add("Loiter circle exit location and/or path to next waypoint ('xtrack') for forward-only moving vehicles (not multicopters). 0 for the vehicle to converge towards the center xtrack when it leaves the loiter (the line between the centers of the current and next waypoint), 1 to converge to the direct line between the location that the vehicle exits the loiter radius and the next waypoint. Otherwise the angle (in degrees) between the tangent of the loiter circle and the center xtrack at which the vehicle must leave the loiter (and converge to the center xtrack). NaN to use the current system default xtrack behaviour.");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "DoFollow",
                Description = "Begin following a target",
            };
            ent.Params = new List<String>();
            ent.Params.Add("System ID (of the FOLLOW_TARGET beacon). Send 0 to disable follow-me and return to the default position hold mode.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Altitude mode: 0: Keep current altitude, 1: keep altitude difference to target, 2: go to a fixed altitude above home.");
            ent.Params.Add("Altitude above home. (used if mode=2)");
            ent.Params.Add("Reserved");
            ent.Params.Add("Time to land in which the MAV should go to the default position hold mode after a message RX timeout.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 33,
                Name = "DoFollowReposition",
                Description = "Reposition the MAV after a follow target command has been sent",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera q1 (where 0 is on the ray from the camera to the tracking device)");
            ent.Params.Add("Camera q2");
            ent.Params.Add("Camera q3");
            ent.Params.Add("Camera q4");
            ent.Params.Add("altitude offset from target");
            ent.Params.Add("X offset from target");
            ent.Params.Add("Y offset from target");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 34,
                Name = "DoOrbit",
                Description = "Start orbiting on the circumference of a circle defined by the parameters. Setting values to NaN/INT32_MAX (as appropriate) results in using defaults.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Radius of the circle. Positive: orbit clockwise. Negative: orbit counter-clockwise. NaN: Use vehicle default radius, or current radius if already orbiting.");
            ent.Params.Add("Tangential Velocity. NaN: Use vehicle default velocity, or current velocity if already orbiting.");
            ent.Params.Add("Yaw behavior of the vehicle.");
            ent.Params.Add("Orbit around the centre point for this many radians (i.e. for a three-quarter orbit set 270*Pi/180). 0: Orbit forever. NaN: Use vehicle default, or current value if already orbiting.");
            ent.Params.Add("Center point latitude (if no MAV_FRAME specified) / X coordinate according to MAV_FRAME. INT32_MAX (or NaN if sent in COMMAND_LONG): Use current vehicle position, or current center if already orbiting.");
            ent.Params.Add("Center point longitude (if no MAV_FRAME specified) / Y coordinate according to MAV_FRAME. INT32_MAX (or NaN if sent in COMMAND_LONG): Use current vehicle position, or current center if already orbiting.");
            ent.Params.Add("Center point altitude (MSL) (if no MAV_FRAME specified) / Z coordinate according to MAV_FRAME. NaN: Use current vehicle altitude.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 80,
                Name = "NavRoi",
                Description = "Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Region of interest mode.");
            ent.Params.Add("Waypoint index/ target ID. (see MAV_ROI enum)");
            ent.Params.Add("ROI index (allows a vehicle to manage multiple ROI's)");
            ent.Params.Add("Empty");
            ent.Params.Add("x the location of the fixed ROI (see MAV_FRAME)");
            ent.Params.Add("y");
            ent.Params.Add("z");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 81,
                Name = "NavPathplanning",
                Description = "Control autonomous path planning on the MAV.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning");
            ent.Params.Add("0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid");
            ent.Params.Add("Empty");
            ent.Params.Add("Yaw angle at goal");
            ent.Params.Add("Latitude/X of goal");
            ent.Params.Add("Longitude/Y of goal");
            ent.Params.Add("Altitude/Z of goal");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 82,
                Name = "NavSplineWaypoint",
                Description = "Navigate to waypoint using a spline path.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Hold time. (ignored by fixed wing, time to stay at waypoint for rotary wing)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Latitude/X of goal");
            ent.Params.Add("Longitude/Y of goal");
            ent.Params.Add("Altitude/Z of goal");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 84,
                Name = "NavVtolTakeoff",
                Description = "Takeoff from ground using VTOL mode, and transition to forward flight with specified heading. The command should be ignored by vehicles that dont support both VTOL and fixed-wing flight (multicopters, boats,etc.).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Front transition heading.");
            ent.Params.Add("Empty");
            ent.Params.Add("Yaw angle. NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.).");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 85,
                Name = "NavVtolLand",
                Description = "Land using VTOL mode",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Landing behaviour.");
            ent.Params.Add("Empty");
            ent.Params.Add("Approach altitude (with the same reference as the Altitude field). NaN if unspecified.");
            ent.Params.Add("Yaw angle. NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.).");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude (ground level) relative to the current coordinate frame. NaN to use system default landing altitude (ignore value).");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 92,
                Name = "NavGuidedEnable",
                Description = "hand control over to an external controller",
            };
            ent.Params = new List<String>();
            ent.Params.Add("On / Off (> 0.5f on)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 93,
                Name = "NavDelay",
                Description = "Delay the next navigation command a number of seconds or until a specified time",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Delay (-1 to enable time-of-day fields)");
            ent.Params.Add("hour (24h format, UTC, -1 to ignore)");
            ent.Params.Add("minute (24h format, UTC, -1 to ignore)");
            ent.Params.Add("second (24h format, UTC, -1 to ignore)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 94,
                Name = "NavPayloadPlace",
                Description = "Descend and place payload. Vehicle moves to specified location, descends until it detects a hanging payload has reached the ground, and then releases the payload. If ground is not detected before the reaching the maximum descent value (param1), the command will complete without releasing the payload.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Maximum distance to descend.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 95,
                Name = "NavLast",
                Description = "NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 112,
                Name = "ConditionDelay",
                Description = "Delay mission state machine.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Delay");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 113,
                Name = "ConditionChangeAlt",
                Description = "Ascend/descend to target altitude at specified rate. Delay mission state machine until desired altitude reached.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Descent / Ascend rate.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Target Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 114,
                Name = "ConditionDistance",
                Description = "Delay mission state machine until within desired distance of next NAV point.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Distance.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 115,
                Name = "ConditionYaw",
                Description = "Reach a certain target angle.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("target angle, 0 is north");
            ent.Params.Add("angular speed");
            ent.Params.Add("direction: -1: counter clockwise, 1: clockwise");
            ent.Params.Add("0: absolute angle, 1: relative offset");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 159,
                Name = "ConditionLast",
                Description = "NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 176,
                Name = "DoSetMode",
                Description = "Set system mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Mode");
            ent.Params.Add("Custom mode - this is system specific, please refer to the individual autopilot specifications for details.");
            ent.Params.Add("Custom sub mode - this is system specific, please refer to the individual autopilot specifications for details.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 177,
                Name = "DoJump",
                Description = "Jump to the desired command in the mission list.  Repeat this action only the specified number of times",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Sequence number");
            ent.Params.Add("Repeat count");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 178,
                Name = "DoChangeSpeed",
                Description = "Change speed and/or throttle set points.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Speed type (0=Airspeed, 1=Ground Speed, 2=Climb Speed, 3=Descent Speed)");
            ent.Params.Add("Speed (-1 indicates no change)");
            ent.Params.Add("Throttle (-1 indicates no change)");
            ent.Params.Add("0: absolute, 1: relative");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 179,
                Name = "DoSetHome",
                Description = "Changes the home location either to the current location or a specified location.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Use current (1=use current location, 0=use specified location)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Yaw angle. NaN to use default heading");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 180,
                Name = "DoSetParameter",
                Description = "Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value of the parameter.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Parameter number");
            ent.Params.Add("Parameter value");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 181,
                Name = "DoSetRelay",
                Description = "Set a relay to a condition.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Relay instance number.");
            ent.Params.Add("Setting. (1=on, 0=off, others possible depending on system hardware)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 182,
                Name = "DoRepeatRelay",
                Description = "Cycle a relay on and off for a desired number of cycles with a desired period.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Relay instance number.");
            ent.Params.Add("Cycle count.");
            ent.Params.Add("Cycle time.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 183,
                Name = "DoSetServo",
                Description = "Set a servo to a desired PWM value.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Servo instance number.");
            ent.Params.Add("Pulse Width Modulation.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 184,
                Name = "DoRepeatServo",
                Description = "Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Servo instance number.");
            ent.Params.Add("Pulse Width Modulation.");
            ent.Params.Add("Cycle count.");
            ent.Params.Add("Cycle time.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 185,
                Name = "DoFlighttermination",
                Description = "Terminate flight immediately",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Flight termination activated if > 0.5");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 186,
                Name = "DoChangeAltitude",
                Description = "Change altitude set point.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Altitude.");
            ent.Params.Add("Frame of new altitude.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 187,
                Name = "DoSetActuator",
                Description = "Sets actuators (e.g. servos) to a desired value. The actuator numbers are mapped to specific outputs (e.g. on any MAIN or AUX PWM or UAVCAN) using a flight-stack specific mechanism (i.e. a parameter).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Actuator 1 value, scaled from [-1 to 1]. NaN to ignore.");
            ent.Params.Add("Actuator 2 value, scaled from [-1 to 1]. NaN to ignore.");
            ent.Params.Add("Actuator 3 value, scaled from [-1 to 1]. NaN to ignore.");
            ent.Params.Add("Actuator 4 value, scaled from [-1 to 1]. NaN to ignore.");
            ent.Params.Add("Actuator 5 value, scaled from [-1 to 1]. NaN to ignore.");
            ent.Params.Add("Actuator 6 value, scaled from [-1 to 1]. NaN to ignore.");
            ent.Params.Add("Index of actuator set (i.e if set to 1, Actuator 1 becomes Actuator 7)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 189,
                Name = "DoLandStart",
                Description = "Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will be used. The Latitude/Longitude is optional, and may be set to 0 if not needed. If specified then it will be used to help find the closest landing sequence.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 190,
                Name = "DoRallyLand",
                Description = "Mission command to perform a landing from a rally point.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Break altitude");
            ent.Params.Add("Landing speed");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 191,
                Name = "DoGoAround",
                Description = "Mission command to safely abort an autonomous landing.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Altitude");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 192,
                Name = "DoReposition",
                Description = "Reposition the vehicle to a specific WGS84 global position.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Ground speed, less than 0 (-1) for default");
            ent.Params.Add("Bitmask of option flags.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Yaw heading. NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.). For planes indicates loiter direction (0: clockwise, 1: counter clockwise)");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 193,
                Name = "DoPauseContinue",
                Description = "If in a GPS controlled position mode, hold the current position or continue.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: Pause current mission or reposition command, hold current position. 1: Continue mission. A VTOL capable vehicle should enter hover mode (multicopter and VTOL planes). A plane should loiter with the default loiter radius.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 194,
                Name = "DoSetReverse",
                Description = "Set moving direction to forward or reverse.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Direction (0=Forward, 1=Reverse)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 195,
                Name = "DoSetRoiLocation",
                Description = "Sets the region of interest (ROI) to a location. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal is not to react to this message.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Latitude of ROI location");
            ent.Params.Add("Longitude of ROI location");
            ent.Params.Add("Altitude of ROI location");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 196,
                Name = "DoSetRoiWpnextOffset",
                Description = "Sets the region of interest (ROI) to be toward next waypoint, with optional pitch/roll/yaw offset. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Pitch offset from next waypoint, positive pitching up");
            ent.Params.Add("Roll offset from next waypoint, positive rolling to the right");
            ent.Params.Add("Yaw offset from next waypoint, positive yawing to the right");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 197,
                Name = "DoSetRoiNone",
                Description = "Cancels any previous ROI command returning the vehicle/sensors to default flight characteristics. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message. After this command the gimbal manager should go back to manual input if available, and otherwise assume a neutral position.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 198,
                Name = "DoSetRoiSysid",
                Description = "Mount tracks system with specified system ID. Determination of target vehicle position may be done with GLOBAL_POSITION_INT or any other means. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("System ID");
            ent.Params.Add("Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 200,
                Name = "DoControlVideo",
                Description = "Control onboard camera system.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera ID (-1 for all)");
            ent.Params.Add("Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw");
            ent.Params.Add("Transmission mode: 0: video stream, >0: single images every n seconds");
            ent.Params.Add("Recording: 0: disabled, 1: enabled compressed, 2: enabled raw");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 201,
                Name = "DoSetRoi",
                Description = "Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Region of interest mode.");
            ent.Params.Add("Waypoint index/ target ID (depends on param 1).");
            ent.Params.Add("Region of interest index. (allows a vehicle to manage multiple ROI's)");
            ent.Params.Add("Empty");
            ent.Params.Add("MAV_ROI_WPNEXT: pitch offset from next waypoint, MAV_ROI_LOCATION: latitude");
            ent.Params.Add("MAV_ROI_WPNEXT: roll offset from next waypoint, MAV_ROI_LOCATION: longitude");
            ent.Params.Add("MAV_ROI_WPNEXT: yaw offset from next waypoint, MAV_ROI_LOCATION: altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 202,
                Name = "DoDigicamConfigure",
                Description = "Configure digital camera. This is a fallback message for systems that have not yet implemented PARAM_EXT_XXX messages and camera definition files (see https://mavlink.io/en/services/camera_def.html ).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Modes: P, TV, AV, M, Etc.");
            ent.Params.Add("Shutter speed: Divisor number for one second.");
            ent.Params.Add("Aperture: F stop number.");
            ent.Params.Add("ISO number e.g. 80, 100, 200, Etc.");
            ent.Params.Add("Exposure type enumerator.");
            ent.Params.Add("Command Identity.");
            ent.Params.Add("Main engine cut-off time before camera trigger. (0 means no cut-off)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 203,
                Name = "DoDigicamControl",
                Description = "Control digital camera. This is a fallback message for systems that have not yet implemented PARAM_EXT_XXX messages and camera definition files (see https://mavlink.io/en/services/camera_def.html ).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Session control e.g. show/hide lens");
            ent.Params.Add("Zoom's absolute position");
            ent.Params.Add("Zooming step value to offset zoom from the current position");
            ent.Params.Add("Focus Locking, Unlocking or Re-locking");
            ent.Params.Add("Shooting Command");
            ent.Params.Add("Command Identity");
            ent.Params.Add("Test shot identifier. If set to 1, image will only be captured, but not counted towards internal frame count.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 204,
                Name = "DoMountConfigure",
                Description = "Mission command to configure a camera or antenna mount",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Mount operation mode");
            ent.Params.Add("stabilize roll? (1 = yes, 0 = no)");
            ent.Params.Add("stabilize pitch? (1 = yes, 0 = no)");
            ent.Params.Add("stabilize yaw? (1 = yes, 0 = no)");
            ent.Params.Add("roll input (0 = angle body frame, 1 = angular rate, 2 = angle absolute frame)");
            ent.Params.Add("pitch input (0 = angle body frame, 1 = angular rate, 2 = angle absolute frame)");
            ent.Params.Add("yaw input (0 = angle body frame, 1 = angular rate, 2 = angle absolute frame)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 205,
                Name = "DoMountControl",
                Description = "Mission command to control a camera or antenna mount",
            };
            ent.Params = new List<String>();
            ent.Params.Add("pitch depending on mount mode (degrees or degrees/second depending on pitch input).");
            ent.Params.Add("roll depending on mount mode (degrees or degrees/second depending on roll input).");
            ent.Params.Add("yaw depending on mount mode (degrees or degrees/second depending on yaw input).");
            ent.Params.Add("altitude depending on mount mode.");
            ent.Params.Add("latitude, set if appropriate mount mode.");
            ent.Params.Add("longitude, set if appropriate mount mode.");
            ent.Params.Add("Mount mode.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 206,
                Name = "DoSetCamTriggDist",
                Description = "Mission command to set camera trigger distance for this flight. The camera is triggered each time this distance is exceeded. This command can also be used to set the shutter integration time for the camera.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera trigger distance. 0 to stop triggering.");
            ent.Params.Add("Camera shutter integration time. -1 or 0 to ignore");
            ent.Params.Add("Trigger camera once immediately. (0 = no trigger, 1 = trigger)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 207,
                Name = "DoFenceEnable",
                Description = "Mission command to enable the geofence",
            };
            ent.Params = new List<String>();
            ent.Params.Add("enable? (0=disable, 1=enable, 2=disable_floor_only)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 208,
                Name = "DoParachute",
                Description = "Mission item/command to release a parachute or enable/disable auto release.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Action");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 209,
                Name = "DoMotorTest",
                Description = "Command to perform motor test.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Motor instance number (from 1 to max number of motors on the vehicle).");
            ent.Params.Add("Throttle type (whether the Throttle Value in param3 is a percentage, PWM value, etc.)");
            ent.Params.Add("Throttle value.");
            ent.Params.Add("Timeout between tests that are run in sequence.");
            ent.Params.Add("Motor count. Number of motors to test in sequence: 0/1=one motor, 2= two motors, etc. The Timeout (param4) is used between tests.");
            ent.Params.Add("Motor test order.");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 210,
                Name = "DoInvertedFlight",
                Description = "Change to/from inverted flight.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Inverted flight. (0=normal, 1=inverted)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 211,
                Name = "DoGripper",
                Description = "Mission command to operate a gripper.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Gripper instance number.");
            ent.Params.Add("Gripper action to perform.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 212,
                Name = "DoAutotuneEnable",
                Description = "Enable/disable autotune.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Enable (1: enable, 0:disable).");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 213,
                Name = "NavSetYawSpeed",
                Description = "Sets a desired vehicle turn angle and speed change.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Yaw angle to adjust steering by.");
            ent.Params.Add("Speed.");
            ent.Params.Add("Final angle. (0=absolute, 1=relative)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 214,
                Name = "DoSetCamTriggInterval",
                Description = "Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is triggered each time this interval expires. This command can also be used to set the shutter integration time for the camera.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera trigger cycle time. -1 or 0 to ignore.");
            ent.Params.Add("Camera shutter integration time. Should be less than trigger cycle time. -1 or 0 to ignore.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 220,
                Name = "DoMountControlQuat",
                Description = "Mission command to control a camera or antenna mount, using a quaternion as reference.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("quaternion param q1, w (1 in null-rotation)");
            ent.Params.Add("quaternion param q2, x (0 in null-rotation)");
            ent.Params.Add("quaternion param q3, y (0 in null-rotation)");
            ent.Params.Add("quaternion param q4, z (0 in null-rotation)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 221,
                Name = "DoGuidedMaster",
                Description = "set id of master controller",
            };
            ent.Params = new List<String>();
            ent.Params.Add("System ID");
            ent.Params.Add("Component ID");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 222,
                Name = "DoGuidedLimits",
                Description = "Set limits for external control",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Timeout - maximum time that external controller will be allowed to control vehicle. 0 means no timeout.");
            ent.Params.Add("Altitude (MSL) min - if vehicle moves below this alt, the command will be aborted and the mission will continue. 0 means no lower altitude limit.");
            ent.Params.Add("Altitude (MSL) max - if vehicle moves above this alt, the command will be aborted and the mission will continue. 0 means no upper altitude limit.");
            ent.Params.Add("Horizontal move limit - if vehicle moves more than this distance from its location at the moment the command was executed, the command will be aborted and the mission will continue. 0 means no horizontal move limit.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 223,
                Name = "DoEngineControl",
                Description = "Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine state. It is intended for vehicles with internal combustion engines",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: Stop engine, 1:Start Engine");
            ent.Params.Add("0: Warm start, 1:Cold start. Controls use of choke where applicable");
            ent.Params.Add("Height delay. This is for commanding engine start only after the vehicle has gained the specified height. Used in VTOL vehicles during takeoff to start engine after the aircraft is off the ground. Zero for no delay.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 224,
                Name = "DoSetMissionCurrent",
                Description = "Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Mission sequence value to set");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 240,
                Name = "DoLast",
                Description = "NOP - This command is only used to mark the upper limit of the DO commands in the enumeration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 241,
                Name = "PreflightCalibration",
                Description = "Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature Calibration, only one sensor should be set in a single message and all others should be zero.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1: gyro calibration, 3: gyro temperature calibration");
            ent.Params.Add("1: magnetometer calibration");
            ent.Params.Add("1: ground pressure calibration");
            ent.Params.Add("1: radio RC calibration, 2: RC trim calibration");
            ent.Params.Add("1: accelerometer calibration, 2: board level calibration, 3: accelerometer temperature calibration, 4: simple accelerometer calibration");
            ent.Params.Add("1: APM: compass/motor interference calibration (PX4: airspeed calibration, deprecated), 2: airspeed calibration");
            ent.Params.Add("1: ESC calibration, 3: barometer temperature calibration");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 242,
                Name = "PreflightSetSensorOffsets",
                Description = "Set sensor offsets. This command will be only accepted if in pre-flight mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Sensor to adjust the offsets for: 0: gyros, 1: accelerometer, 2: magnetometer, 3: barometer, 4: optical flow, 5: second magnetometer, 6: third magnetometer");
            ent.Params.Add("X axis offset (or generic dimension 1), in the sensor's raw units");
            ent.Params.Add("Y axis offset (or generic dimension 2), in the sensor's raw units");
            ent.Params.Add("Z axis offset (or generic dimension 3), in the sensor's raw units");
            ent.Params.Add("Generic dimension 4, in the sensor's raw units");
            ent.Params.Add("Generic dimension 5, in the sensor's raw units");
            ent.Params.Add("Generic dimension 6, in the sensor's raw units");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 243,
                Name = "PreflightUavcan",
                Description = "Trigger UAVCAN configuration (actuator ID assignment and direction mapping). Note that this maps to the legacy UAVCAN v0 function UAVCAN_ENUMERATE, which is intended to be executed just once during initial vehicle configuration (it is not a normal pre-flight command and has been poorly named).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1: Trigger actuator ID assignment and direction mapping. 0: Cancel command.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 245,
                Name = "PreflightStorage",
                Description = "Request storage of different parameter values and logs. This command will be only accepted if in pre-flight mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Parameter storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults, 3: Reset sensor calibration parameter data to factory default (or firmware default if not available)");
            ent.Params.Add("Mission storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults");
            ent.Params.Add("Onboard logging: 0: Ignore, 1: Start default rate logging, -1: Stop logging, > 1: logging rate (e.g. set to 1000 for 1000 Hz logging)");
            ent.Params.Add("Reserved");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 246,
                Name = "PreflightRebootShutdown",
                Description = "Request the reboot or shutdown of system components.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot, 3: Reboot autopilot and keep it in the bootloader until upgraded.");
            ent.Params.Add("0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer, 3: Reboot onboard computer and keep it in the bootloader until upgraded.");
            ent.Params.Add("0: Do nothing for component, 1: Reboot component, 2: Shutdown component, 3: Reboot component and keep it in the bootloader until upgraded");
            ent.Params.Add("MAVLink Component ID targeted in param3 (0 for all components).");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("WIP: ID (e.g. camera ID -1 for all IDs)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 252,
                Name = "OverrideGoto",
                Description = "Override current mission with command to pause mission, pause mission and move to position, continue/resume mission. When param 1 indicates that the mission is paused (MAV_GOTO_DO_HOLD), param 2 defines whether it holds in place or moves to another position.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("MAV_GOTO_DO_HOLD: pause mission and either hold or move to specified position (depending on param2), MAV_GOTO_DO_CONTINUE: resume mission.");
            ent.Params.Add("MAV_GOTO_HOLD_AT_CURRENT_POSITION: hold at current position, MAV_GOTO_HOLD_AT_SPECIFIED_POSITION: hold at specified position.");
            ent.Params.Add("Coordinate frame of hold point.");
            ent.Params.Add("Desired yaw angle.");
            ent.Params.Add("Latitude/X position.");
            ent.Params.Add("Longitude/Y position.");
            ent.Params.Add("Altitude/Z position.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 260,
                Name = "ObliqueSurvey",
                Description = "Mission command to set a Camera Auto Mount Pivoting Oblique Survey (Replaces CAM_TRIGG_DIST for this purpose). The camera is triggered each time this distance is exceeded, then the mount moves to the next position. Params 4~6 set-up the angle limits and number of positions for oblique survey, where mount-enabled vehicles automatically roll the camera between shots to emulate an oblique camera setup (providing an increased HFOV). This command can also be used to set the shutter integration time for the camera.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera trigger distance. 0 to stop triggering.");
            ent.Params.Add("Camera shutter integration time. 0 to ignore");
            ent.Params.Add("The minimum interval in which the camera is capable of taking subsequent pictures repeatedly. 0 to ignore.");
            ent.Params.Add("Total number of roll positions at which the camera will capture photos (images captures spread evenly across the limits defined by param5).");
            ent.Params.Add("Angle limits that the camera can be rolled to left and right of center.");
            ent.Params.Add("Fixed pitch angle that the camera will hold in oblique mode if the mount is actuated in the pitch axis.");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 300,
                Name = "MissionStart",
                Description = "start running a mission",
            };
            ent.Params = new List<String>();
            ent.Params.Add("first_item: the first mission item to run");
            ent.Params.Add("last_item:  the last mission item to run (after this item is run, the mission ends)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 400,
                Name = "ComponentArmDisarm",
                Description = "Arms / Disarms a component",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: disarm, 1: arm");
            ent.Params.Add("0: arm-disarm unless prevented by safety checks (i.e. when landed), 21196: force arming/disarming (e.g. allow arming to override preflight checks and disarming in flight)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 401,
                Name = "RunPrearmChecks",
                Description = "Instructs system to run pre-arm checks. This command should return MAV_RESULT_TEMPORARILY_REJECTED in the case the system is armed, otherwise MAV_RESULT_ACCEPTED. Note that the return value from executing this command does not indicate whether the vehicle is armable or not, just whether the system has successfully run/is currently running the checks.  The result of the checks is reflected in the SYS_STATUS message.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 405,
                Name = "IlluminatorOnOff",
                Description = "Turns illuminators ON/OFF. An illuminator is a light source that is used for lighting up dark areas external to the sytstem: e.g. a torch or searchlight (as opposed to a light source for illuminating the system itself, e.g. an indicator light).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: Illuminators OFF, 1: Illuminators ON");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 410,
                Name = "GetHomePosition",
                Description = "Request the home position from the vehicle.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 420,
                Name = "InjectFailure",
                Description = "Inject artificial failure for testing purposes. Note that autopilots should implement an additional protection before accepting this command such as a specific param setting.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("The unit which is affected by the failure.");
            ent.Params.Add("The type how the failure manifests itself.");
            ent.Params.Add("Instance affected by failure (0 to signal all).");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 500,
                Name = "StartRxPair",
                Description = "Starts receiver pairing.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0:Spektrum.");
            ent.Params.Add("RC type.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 510,
                Name = "GetMessageInterval",
                Description = "Request the interval between messages for a particular MAVLink message ID. The receiver should ACK the command and then emit its response in a MESSAGE_INTERVAL message.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("The MAVLink message ID");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 511,
                Name = "SetMessageInterval",
                Description = "Set the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREAM.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("The MAVLink message ID");
            ent.Params.Add("The interval between two messages. Set to -1 to disable and 0 to request default rate.");
            ent.Params.Add("Target address of message stream (if message has target address fields). 0: Flight-stack default (recommended), 1: address of requestor, 2: broadcast.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "RequestMessage",
                Description = "Request the target system(s) emit a single instance of a specified message (i.e. a 'one-shot' version of MAV_CMD_SET_MESSAGE_INTERVAL).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("The MAVLink message ID of the requested message.");
            ent.Params.Add("Use for index ID, if required. Otherwise, the use of this parameter (if any) must be defined in the requested message. By default assumed not used (0).");
            ent.Params.Add("The use of this parameter (if any), must be defined in the requested message. By default assumed not used (0).");
            ent.Params.Add("The use of this parameter (if any), must be defined in the requested message. By default assumed not used (0).");
            ent.Params.Add("The use of this parameter (if any), must be defined in the requested message. By default assumed not used (0).");
            ent.Params.Add("The use of this parameter (if any), must be defined in the requested message. By default assumed not used (0).");
            ent.Params.Add("Target address for requested message (if message has target address fields). 0: Flight-stack default, 1: address of requestor, 2: broadcast.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 519,
                Name = "RequestProtocolVersion",
                Description = "Request MAVLink protocol version compatibility. All receivers should ACK the command and then emit their capabilities in an PROTOCOL_VERSION message",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1: Request supported protocol versions by all nodes on the network");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 520,
                Name = "RequestAutopilotCapabilities",
                Description = "Request autopilot capabilities. The receiver should ACK the command and then emit its capabilities in an AUTOPILOT_VERSION message",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1: Request autopilot version");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 521,
                Name = "RequestCameraInformation",
                Description = "Request camera information (CAMERA_INFORMATION).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: No action 1: Request camera capabilities");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 522,
                Name = "RequestCameraSettings",
                Description = "Request camera settings (CAMERA_SETTINGS).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: No Action 1: Request camera settings");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 525,
                Name = "RequestStorageInformation",
                Description = "Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a specific component's storage.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Storage ID (0 for all, 1 for first, 2 for second, etc.)");
            ent.Params.Add("0: No Action 1: Request storage information");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 526,
                Name = "StorageFormat",
                Description = "Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the command's target_component to target a specific component's storage.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Storage ID (1 for first, 2 for second, etc.)");
            ent.Params.Add("Format storage (and reset image log). 0: No action 1: Format storage");
            ent.Params.Add("Reset Image Log (without formatting storage medium). This will reset CAMERA_CAPTURE_STATUS.image_count and CAMERA_IMAGE_CAPTURED.image_index. 0: No action 1: Reset Image Log");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 527,
                Name = "RequestCameraCaptureStatus",
                Description = "Request camera capture status (CAMERA_CAPTURE_STATUS)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: No Action 1: Request camera capture status");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 528,
                Name = "RequestFlightInformation",
                Description = "Request flight information (FLIGHT_INFORMATION)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1: Request flight information");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 529,
                Name = "ResetCameraSettings",
                Description = "Reset all camera settings to Factory Default",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: No Action 1: Reset all settings");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 530,
                Name = "SetCameraMode",
                Description = "Set camera running mode. Use NaN for reserved values. GCS will send a MAV_CMD_REQUEST_VIDEO_STREAM_STATUS command after a mode change if the camera supports video streaming.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved (Set to 0)");
            ent.Params.Add("Camera mode");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 531,
                Name = "SetCameraZoom",
                Description = "Set camera zoom. Camera must respond with a CAMERA_SETTINGS message (on success).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Zoom type");
            ent.Params.Add("Zoom value. The range of valid values depend on the zoom type.");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 532,
                Name = "SetCameraFocus",
                Description = "Set camera focus. Camera must respond with a CAMERA_SETTINGS message (on success).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Focus type");
            ent.Params.Add("Focus value");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 533,
                Name = "SetStorageUsage",
                Description = "Set that a particular storage is the preferred location for saving photos, videos, and/or other media (e.g. to set that an SD card is used for storing videos).           There can only be one preferred save location for each particular media type: setting a media usage flag will clear/reset that same flag if set on any other storage.           If no flag is set the system should use its default storage.           A target system can choose to always use default storage, in which case it should ACK the command with MAV_RESULT_UNSUPPORTED.           A target system can choose to not allow a particular storage to be set as preferred storage, in which case it should ACK the command with MAV_RESULT_DENIED.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Storage ID (1 for first, 2 for second, etc.)");
            ent.Params.Add("Usage flags");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 600,
                Name = "JumpTag",
                Description = "Tagged jump target. Can be jumped to with MAV_CMD_DO_JUMP_TAG.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Tag.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 601,
                Name = "DoJumpTag",
                Description = "Jump to the matching tag in the mission list. Repeat this action for the specified number of times. A mission should contain a single matching tag for each jump. If this is not the case then a jump to a missing tag should complete the mission, and a jump where there are multiple matching tags should always select the one with the lowest mission sequence number.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Target tag to jump to.");
            ent.Params.Add("Repeat count.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1000,
                Name = "DoGimbalManagerPitchyaw",
                Description = "High level setpoint to be sent to a gimbal manager to set a gimbal attitude. It is possible to set combinations of the values below. E.g. an angle as well as a desired angular rate can be used to get to this angle at a certain angular rate, or an angular rate only will result in continuous turning. NaN is to be used to signal unset. Note: a gimbal is never to react to this command but only the gimbal manager.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Pitch angle (positive to pitch up, relative to vehicle for FOLLOW mode, relative to world horizon for LOCK mode).");
            ent.Params.Add("Yaw angle (positive to yaw to the right, relative to vehicle for FOLLOW mode, absolute to North for LOCK mode).");
            ent.Params.Add("Pitch rate (positive to pitch up).");
            ent.Params.Add("Yaw rate (positive to yaw to the right).");
            ent.Params.Add("Gimbal manager flags to use.");
            ent.Params.Add("Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1001,
                Name = "DoGimbalManagerConfigure",
                Description = "Gimbal configuration to set which sysid/compid is in primary and secondary control.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Sysid for primary control (0: no one in control, -1: leave unchanged, -2: set itself in control (for missions where the own sysid is still unknown), -3: remove control if currently in control).");
            ent.Params.Add("Compid for primary control (0: no one in control, -1: leave unchanged, -2: set itself in control (for missions where the own sysid is still unknown), -3: remove control if currently in control).");
            ent.Params.Add("Sysid for secondary control (0: no one in control, -1: leave unchanged, -2: set itself in control (for missions where the own sysid is still unknown), -3: remove control if currently in control).");
            ent.Params.Add("Compid for secondary control (0: no one in control, -1: leave unchanged, -2: set itself in control (for missions where the own sysid is still unknown), -3: remove control if currently in control).");
            ent.Params.Add("Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2000,
                Name = "ImageStartCapture",
                Description = "Start image capture sequence. Sends CAMERA_IMAGE_CAPTURED after each capture. Use NaN for reserved values.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved (Set to 0)");
            ent.Params.Add("Desired elapsed time between two consecutive pictures (in seconds). Minimum values depend on hardware (typically greater than 2 seconds).");
            ent.Params.Add("Total number of images to capture. 0 to capture forever/until MAV_CMD_IMAGE_STOP_CAPTURE.");
            ent.Params.Add("Capture sequence number starting from 1. This is only valid for single-capture (param3 == 1), otherwise set to 0. Increment the capture ID for each capture command to prevent double captures when a command is re-transmitted.");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2001,
                Name = "ImageStopCapture",
                Description = "Stop image capture sequence Use NaN for reserved values.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved (Set to 0)");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2002,
                Name = "RequestCameraImageCapture",
                Description = "Re-request a CAMERA_IMAGE_CAPTURED message.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Sequence number for missing CAMERA_IMAGE_CAPTURED message");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2003,
                Name = "DoTriggerControl",
                Description = "Enable or disable on-board camera triggering system.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Trigger enable/disable (0 for disable, 1 for start), -1 to ignore");
            ent.Params.Add("1 to reset the trigger sequence, -1 or 0 to ignore");
            ent.Params.Add("1 to pause triggering, but without switching the camera off or retracting it. -1 to ignore");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2004,
                Name = "CameraTrackPoint",
                Description = "If the camera supports point visual tracking (CAMERA_CAP_FLAGS_HAS_TRACKING_POINT is set), this command allows to initiate the tracking.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Point to track x value (normalized 0..1, 0 is left, 1 is right).");
            ent.Params.Add("Point to track y value (normalized 0..1, 0 is top, 1 is bottom).");
            ent.Params.Add("Point radius (normalized 0..1, 0 is image left, 1 is image right).");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2005,
                Name = "CameraTrackRectangle",
                Description = "If the camera supports rectangle visual tracking (CAMERA_CAP_FLAGS_HAS_TRACKING_RECTANGLE is set), this command allows to initiate the tracking.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Top left corner of rectangle x value (normalized 0..1, 0 is left, 1 is right).");
            ent.Params.Add("Top left corner of rectangle y value (normalized 0..1, 0 is top, 1 is bottom).");
            ent.Params.Add("Bottom right corner of rectangle x value (normalized 0..1, 0 is left, 1 is right).");
            ent.Params.Add("Bottom right corner of rectangle y value (normalized 0..1, 0 is top, 1 is bottom).");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2010,
                Name = "CameraStopTracking",
                Description = "Stops ongoing tracking.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2500,
                Name = "VideoStartCapture",
                Description = "Starts video capture (recording).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Video Stream ID (0 for all streams)");
            ent.Params.Add("Frequency CAMERA_CAPTURE_STATUS messages should be sent while recording (0 for no messages, otherwise frequency)");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2501,
                Name = "VideoStopCapture",
                Description = "Stop the current video capture (recording).",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Video Stream ID (0 for all streams)");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2502,
                Name = "VideoStartStreaming",
                Description = "Start video streaming",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Video Stream ID (0 for all streams, 1 for first, 2 for second, etc.)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2503,
                Name = "VideoStopStreaming",
                Description = "Stop the given video stream",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Video Stream ID (0 for all streams, 1 for first, 2 for second, etc.)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2504,
                Name = "RequestVideoStreamInformation",
                Description = "Request video stream information (VIDEO_STREAM_INFORMATION)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Video Stream ID (0 for all streams, 1 for first, 2 for second, etc.)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2505,
                Name = "RequestVideoStreamStatus",
                Description = "Request video stream status (VIDEO_STREAM_STATUS)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Video Stream ID (0 for all streams, 1 for first, 2 for second, etc.)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2510,
                Name = "LoggingStart",
                Description = "Request to start streaming logging data over MAVLink (see also LOGGING_DATA message)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Format: 0: ULog");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2511,
                Name = "LoggingStop",
                Description = "Request to stop streaming log data over MAVLink",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2520,
                Name = "AirframeConfiguration",
                Description = "",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Landing gear ID (default: 0, -1 for all)");
            ent.Params.Add("Landing gear position (Down: 0, Up: 1, NaN for no change)");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            ent.Params.Add("");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2600,
                Name = "ControlHighLatency",
                Description = "Request to start/stop transmitting over the high latency telemetry",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Control transmission over high latency telemetry (0: stop, 1: start)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2800,
                Name = "PanoramaCreate",
                Description = "Create a panorama at the current position",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Viewing angle horizontal of the panorama (+- 0.5 the total angle)");
            ent.Params.Add("Viewing angle vertical of panorama.");
            ent.Params.Add("Speed of the horizontal rotation.");
            ent.Params.Add("Speed of the vertical rotation.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3000,
                Name = "DoVtolTransition",
                Description = "Request VTOL transition",
            };
            ent.Params = new List<String>();
            ent.Params.Add("The target VTOL state. For normal transitions, only MAV_VTOL_STATE_MC and MAV_VTOL_STATE_FW can be used.");
            ent.Params.Add("Force immediate transition to the specified MAV_VTOL_STATE. 1: Force immediate, 0: normal transition. Can be used, for example, to trigger an emergency 'Quadchute'. Caution: Can be dangerous/damage vehicle, depending on autopilot implementation of this command.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3001,
                Name = "ArmAuthorizationRequest",
                Description = "Request authorization to arm the vehicle to a external entity, the arm authorizer is responsible to request all data that is needs from the vehicle before authorize or deny the request. If approved the progress of command_ack message should be set with period of time that this authorization is valid in seconds or in case it was denied it should be set with one of the reasons in ARM_AUTH_DENIED_REASON.         ",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Vehicle system id, this way ground station can request arm authorization on behalf of any vehicle");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4000,
                Name = "SetGuidedSubmodeStandard",
                Description = "This command sets the submode to standard guided when vehicle is in guided mode. The vehicle holds position and altitude and the user can input the desired velocities along all three axes.                   ",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4001,
                Name = "SetGuidedSubmodeCircle",
                Description = "This command sets submode circle when vehicle is in guided mode. Vehicle flies along a circle facing the center of the circle. The user can input the velocity along the circle and change the radius. If no input is given the vehicle will hold position.                   ",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Radius of desired circle in CIRCLE_MODE");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Target latitude of center of circle in CIRCLE_MODE");
            ent.Params.Add("Target longitude of center of circle in CIRCLE_MODE");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4501,
                Name = "ConditionGate",
                Description = "Delay mission state machine until gate has been reached.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Geometry: 0: orthogonal to path between previous and next waypoint.");
            ent.Params.Add("Altitude: 0: ignore altitude");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5000,
                Name = "NavFenceReturnPoint",
                Description = "Fence return point (there can only be one such point in a geofence definition). If rally points are supported they should be used instead.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5001,
                Name = "NavFencePolygonVertexInclusion",
                Description = "Fence vertex for an inclusion polygon (the polygon must not be self-intersecting). The vehicle must stay within this area. Minimum of 3 vertices required.         ",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Polygon vertex count");
            ent.Params.Add("Vehicle must be inside ALL inclusion zones in a single group, vehicle must be inside at least one group, must be the same for all points in each polygon");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5002,
                Name = "NavFencePolygonVertexExclusion",
                Description = "Fence vertex for an exclusion polygon (the polygon must not be self-intersecting). The vehicle must stay outside this area. Minimum of 3 vertices required.         ",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Polygon vertex count");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5003,
                Name = "NavFenceCircleInclusion",
                Description = "Circular fence area. The vehicle must stay inside this area.         ",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Radius.");
            ent.Params.Add("Vehicle must be inside ALL inclusion zones in a single group, vehicle must be inside at least one group");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5004,
                Name = "NavFenceCircleExclusion",
                Description = "Circular fence area. The vehicle must stay outside this area.         ",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Radius.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5100,
                Name = "NavRallyPoint",
                Description = "Rally point. You can have multiple rally points defined.         ",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5200,
                Name = "UavcanGetNodeInfo",
                Description = "Commands the vehicle to respond with a sequence of messages UAVCAN_NODE_INFO, one message per every UAVCAN node that is online. Note that some of the response messages can be lost, which the receiver can detect easily by checking whether every received UAVCAN_NODE_STATUS has a matching message UAVCAN_NODE_INFO received earlier; if not, this command should be sent again in order to request re-transmission of the node information messages.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10001,
                Name = "DoAdsbOutIdent",
                Description = "Trigger the start of an ADSB-out IDENT. This should only be used when requested to do so by an Air Traffic Controller in controlled airspace. This starts the IDENT which is then typically held for 18 seconds by the hardware per the Mode A, C, and S transponder spec.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            ent.Params.Add("Reserved (set to 0)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30001,
                Name = "PayloadPrepareDeploy",
                Description = "Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release position and velocity.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Operation mode. 0: prepare single payload deploy (overwriting previous requests), but do not execute it. 1: execute payload deploy immediately (rejecting further deploy commands during execution, but allowing abort). 2: add payload deploy to existing deployment list.");
            ent.Params.Add("Desired approach vector in compass heading. A negative value indicates the system can define the approach vector at will.");
            ent.Params.Add("Desired ground speed at release time. This can be overridden by the airframe in case it needs to meet minimum airspeed. A negative value indicates the system can define the ground speed at will.");
            ent.Params.Add("Minimum altitude clearance to the release position. A negative value indicates the system can define the clearance at will.");
            ent.Params.Add("Latitude. Note, if used in MISSION_ITEM (deprecated) the units are degrees (unscaled)");
            ent.Params.Add("Longitude. Note, if used in MISSION_ITEM (deprecated) the units are degrees (unscaled)");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30002,
                Name = "PayloadControlDeploy",
                Description = "Control the payload deployment.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Operation mode. 0: Abort deployment, continue normal mission. 1: switch to payload deployment mode. 100: delete first payload deployment request. 101: delete all payload deployment requests.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42006,
                Name = "FixedMagCalYaw",
                Description = "Magnetometer calibration based on provided known yaw. This allows for fast calibration using WMM field tables in the vehicle, given only the known yaw of the vehicle. If Latitude and longitude are both zero then use the current vehicle location.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Yaw of vehicle in earth frame.");
            ent.Params.Add("CompassMask, 0 for all.");
            ent.Params.Add("Latitude.");
            ent.Params.Add("Longitude.");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42600,
                Name = "DoWinch",
                Description = "Command to operate winch.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Winch instance number.");
            ent.Params.Add("Action to perform.");
            ent.Params.Add("Length of cable to release (negative to wind).");
            ent.Params.Add("Release rate (negative to wind).");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            ent.Params.Add("Empty.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31000,
                Name = "WaypointUser1",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31001,
                Name = "WaypointUser2",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31002,
                Name = "WaypointUser3",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31003,
                Name = "WaypointUser4",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31004,
                Name = "WaypointUser5",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31005,
                Name = "SpatialUser1",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31006,
                Name = "SpatialUser2",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31007,
                Name = "SpatialUser3",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31008,
                Name = "SpatialUser4",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31009,
                Name = "SpatialUser5",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude (MSL)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31010,
                Name = "User1",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31011,
                Name = "User2",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31012,
                Name = "User3",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31013,
                Name = "User4",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31014,
                Name = "User5",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavDataStream",
                Description = "A data stream is not a fixed set of messages, but rather a      recommendation to the autopilot software. Individual autopilots may or may not obey      the recommended messages.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "All",
                Description = "Enable all data streams",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "RawSensors",
                Description = "Enable IMU_RAW, GPS_RAW, GPS_STATUS packets.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ExtendedStatus",
                Description = "Enable GPS_STATUS, CONTROL_STATUS, AUX_STATUS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "RcChannels",
                Description = "Enable RC_CHANNELS_SCALED, RC_CHANNELS_RAW, SERVO_OUTPUT_RAW",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "RawController",
                Description = "Enable ATTITUDE_CONTROLLER_OUTPUT, POSITION_CONTROLLER_OUTPUT, NAV_CONTROLLER_OUTPUT.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Position",
                Description = "Enable LOCAL_POSITION, GLOBAL_POSITION_INT messages.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Extra1",
                Description = "Dependent on the autopilot",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Extra2",
                Description = "Dependent on the autopilot",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Extra3",
                Description = "Dependent on the autopilot",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavRoi",
                Description = "The ROI (region of interest) for the vehicle. This can be                 be used by the vehicle for camera/vehicle attitude alignment (see                 MAV_CMD_NAV_ROI).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No region of interest.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Wpnext",
                Description = "Point toward next waypoint, with optional pitch/roll/yaw offset.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Wpindex",
                Description = "Point toward given waypoint.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Location",
                Description = "Point toward fixed location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Target",
                Description = "Point toward of given id.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavCmdAck",
                Description = "ACK / NACK / ERROR values as a result of MAV_CMDs and for mission item transmission.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Ok",
                Description = "Command / mission item is ok.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ErrFail",
                Description = "Generic error message if none of the other reasons fails or if no detailed error reporting is implemented.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ErrAccessDenied",
                Description = "The system is refusing to accept this command from this source / communication partner.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "ErrNotSupported",
                Description = "Command or mission item is not supported, other commands would be accepted.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "ErrCoordinateFrameNotSupported",
                Description = "The coordinate frame of this command / mission item is not supported.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "ErrCoordinatesOutOfRange",
                Description = "The coordinate frame of this command is ok, but he coordinate values exceed the safety limits of this system. This is a generic error, please use the more specific error messages below if possible.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "ErrXLatOutOfRange",
                Description = "The X or latitude value is out of range.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "ErrYLonOutOfRange",
                Description = "The Y or longitude value is out of range.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "ErrZAltOutOfRange",
                Description = "The Z or altitude value is out of range.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavParamType",
                Description = "Specifies the datatype of a MAVLink parameter.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Uint8",
                Description = "8-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Int8",
                Description = "8-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Uint16",
                Description = "16-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Int16",
                Description = "16-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Uint32",
                Description = "32-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Int32",
                Description = "32-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Uint64",
                Description = "64-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Int64",
                Description = "64-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Real32",
                Description = "32-bit floating-point",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Real64",
                Description = "64-bit floating-point",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavParamExtType",
                Description = "Specifies the datatype of a MAVLink extended parameter.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Uint8",
                Description = "8-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Int8",
                Description = "8-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Uint16",
                Description = "16-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Int16",
                Description = "16-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Uint32",
                Description = "32-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Int32",
                Description = "32-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Uint64",
                Description = "64-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Int64",
                Description = "64-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Real32",
                Description = "32-bit floating-point",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Real64",
                Description = "64-bit floating-point",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Custom",
                Description = "Custom Type",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavResult",
                Description = "Result from a MAVLink command (MAV_CMD)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Accepted",
                Description = "Command is valid (is supported and has valid parameters), and was executed.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "TemporarilyRejected",
                Description = "Command is valid, but cannot be executed at this time. This is used to indicate a problem that should be fixed just by waiting (e.g. a state machine is busy, can't arm because have not got GPS lock, etc.). Retrying later should work.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Denied",
                Description = "Command is invalid (is supported but has invalid parameters). Retrying same command and parameters will not work.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Unsupported",
                Description = "Command is not supported (unknown).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Failed",
                Description = "Command is valid, but execution has failed. This is used to indicate any non-temporary or unexpected problem, i.e. any problem that must be fixed before the command can succeed/be retried. For example, attempting to write a file when out of memory, attempting to arm when sensors are not calibrated, etc.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "InProgress",
                Description = "Command is valid and is being executed. This will be followed by further progress updates, i.e. the component may send further COMMAND_ACK messages with result MAV_RESULT_IN_PROGRESS (at a rate decided by the implementation), and must terminate by sending a COMMAND_ACK message with final result of the operation. The COMMAND_ACK.progress field can be used to indicate the progress of the operation.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Cancelled",
                Description = "Command has been cancelled (as a result of receiving a COMMAND_CANCEL message).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavMissionResult",
                Description = "Result of mission operation (in a MISSION_ACK message).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MavMissionAccepted",
                Description = "mission accepted OK",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavMissionError",
                Description = "Generic error / not accepting mission commands at all right now.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavMissionUnsupportedFrame",
                Description = "Coordinate frame is not supported.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MavMissionUnsupported",
                Description = "Command is not supported.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavMissionNoSpace",
                Description = "Mission items exceed storage space.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "MavMissionInvalid",
                Description = "One of the parameters has an invalid value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "MavMissionInvalidParam1",
                Description = "param1 has an invalid value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "MavMissionInvalidParam2",
                Description = "param2 has an invalid value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "MavMissionInvalidParam3",
                Description = "param3 has an invalid value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "MavMissionInvalidParam4",
                Description = "param4 has an invalid value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "MavMissionInvalidParam5X",
                Description = "x / param5 has an invalid value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "MavMissionInvalidParam6Y",
                Description = "y / param6 has an invalid value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "MavMissionInvalidParam7",
                Description = "z / param7 has an invalid value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "MavMissionInvalidSequence",
                Description = "Mission item received out of sequence",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "MavMissionDenied",
                Description = "Not accepting any mission commands from this communication partner.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "MavMissionOperationCancelled",
                Description = "Current mission operation cancelled (e.g. mission upload, mission download).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavSeverity",
                Description = "Indicates the severity level, generally used for status messages to indicate their relative urgency. Based on RFC-5424 using expanded definitions at: http://www.kiwisyslog.com/kb/info:-syslog-message-levels/.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Emergency",
                Description = "System is unusable. This is a 'panic' condition.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Alert",
                Description = "Action should be taken immediately. Indicates error in non-critical systems.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Critical",
                Description = "Action must be taken immediately. Indicates failure in a primary system.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Error",
                Description = "Indicates an error in secondary/redundant systems.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Warning",
                Description = "Indicates about a possible future error if this is not resolved within a given timeframe. Example would be a low battery warning.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Notice",
                Description = "An unusual event has occurred, though not an error condition. This should be investigated for the root cause.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Info",
                Description = "Normal operational messages. Useful for logging. No action is required for these messages.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Debug",
                Description = "Useful non-operational messages that can assist in debugging. These should not occur during normal operation.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavPowerStatus",
                Description = "Power supply status flags (bitmask)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "BrickValid",
                Description = "main brick power supply valid",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ServoValid",
                Description = "main servo power supply valid for FMU",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "UsbConnected",
                Description = "USB power is connected",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "PeriphOvercurrent",
                Description = "peripheral supply is in over-current state",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "PeriphHipowerOvercurrent",
                Description = "hi-power peripheral supply is in over-current state",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Changed",
                Description = "Power status has changed since boot",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "SerialControlDev",
                Description = "SERIAL_CONTROL device types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Telem1",
                Description = "First telemetry port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Telem2",
                Description = "Second telemetry port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Gps1",
                Description = "First GPS port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Gps2",
                Description = "Second GPS port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Shell",
                Description = "system shell",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 100,
                Name = "SerialControlSerial0",
                Description = "SERIAL0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 101,
                Name = "SerialControlSerial1",
                Description = "SERIAL1",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 102,
                Name = "SerialControlSerial2",
                Description = "SERIAL2",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 103,
                Name = "SerialControlSerial3",
                Description = "SERIAL3",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 104,
                Name = "SerialControlSerial4",
                Description = "SERIAL4",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 105,
                Name = "SerialControlSerial5",
                Description = "SERIAL5",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 106,
                Name = "SerialControlSerial6",
                Description = "SERIAL6",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 107,
                Name = "SerialControlSerial7",
                Description = "SERIAL7",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 108,
                Name = "SerialControlSerial8",
                Description = "SERIAL8",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 109,
                Name = "SerialControlSerial9",
                Description = "SERIAL9",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "SerialControlFlag",
                Description = "SERIAL_CONTROL flags (bitmask)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Reply",
                Description = "Set if this is a reply",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Respond",
                Description = "Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Exclusive",
                Description = "Set if access to the serial port should be removed from whatever driver is currently using it, giving exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without this flag set",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Blocking",
                Description = "Block on writes to the serial port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Multi",
                Description = "Send multiple replies until port is drained",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavDistanceSensor",
                Description = "Enumeration of distance sensor types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Laser",
                Description = "Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Ultrasound",
                Description = "Ultrasound rangefinder, e.g. MaxBotix units",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Infrared",
                Description = "Infrared rangefinder, e.g. Sharp units",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Radar",
                Description = "Radar type, e.g. uLanding units",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Unknown",
                Description = "Broken or unknown type, e.g. analog units",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavSensorOrientation",
                Description = "Enumeration of sensor orientation, according to its rotations",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MavSensorRotationNone",
                Description = "Roll: 0, Pitch: 0, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavSensorRotationYaw45",
                Description = "Roll: 0, Pitch: 0, Yaw: 45",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavSensorRotationYaw90",
                Description = "Roll: 0, Pitch: 0, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MavSensorRotationYaw135",
                Description = "Roll: 0, Pitch: 0, Yaw: 135",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavSensorRotationYaw180",
                Description = "Roll: 0, Pitch: 0, Yaw: 180",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "MavSensorRotationYaw225",
                Description = "Roll: 0, Pitch: 0, Yaw: 225",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "MavSensorRotationYaw270",
                Description = "Roll: 0, Pitch: 0, Yaw: 270",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "MavSensorRotationYaw315",
                Description = "Roll: 0, Pitch: 0, Yaw: 315",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "MavSensorRotationRoll180",
                Description = "Roll: 180, Pitch: 0, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "MavSensorRotationRoll180Yaw45",
                Description = "Roll: 180, Pitch: 0, Yaw: 45",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "MavSensorRotationRoll180Yaw90",
                Description = "Roll: 180, Pitch: 0, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "MavSensorRotationRoll180Yaw135",
                Description = "Roll: 180, Pitch: 0, Yaw: 135",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "MavSensorRotationPitch180",
                Description = "Roll: 0, Pitch: 180, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "MavSensorRotationRoll180Yaw225",
                Description = "Roll: 180, Pitch: 0, Yaw: 225",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "MavSensorRotationRoll180Yaw270",
                Description = "Roll: 180, Pitch: 0, Yaw: 270",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "MavSensorRotationRoll180Yaw315",
                Description = "Roll: 180, Pitch: 0, Yaw: 315",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "MavSensorRotationRoll90",
                Description = "Roll: 90, Pitch: 0, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "MavSensorRotationRoll90Yaw45",
                Description = "Roll: 90, Pitch: 0, Yaw: 45",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "MavSensorRotationRoll90Yaw90",
                Description = "Roll: 90, Pitch: 0, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "MavSensorRotationRoll90Yaw135",
                Description = "Roll: 90, Pitch: 0, Yaw: 135",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "MavSensorRotationRoll270",
                Description = "Roll: 270, Pitch: 0, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 21,
                Name = "MavSensorRotationRoll270Yaw45",
                Description = "Roll: 270, Pitch: 0, Yaw: 45",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 22,
                Name = "MavSensorRotationRoll270Yaw90",
                Description = "Roll: 270, Pitch: 0, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 23,
                Name = "MavSensorRotationRoll270Yaw135",
                Description = "Roll: 270, Pitch: 0, Yaw: 135",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 24,
                Name = "MavSensorRotationPitch90",
                Description = "Roll: 0, Pitch: 90, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 25,
                Name = "MavSensorRotationPitch270",
                Description = "Roll: 0, Pitch: 270, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 26,
                Name = "MavSensorRotationPitch180Yaw90",
                Description = "Roll: 0, Pitch: 180, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 27,
                Name = "MavSensorRotationPitch180Yaw270",
                Description = "Roll: 0, Pitch: 180, Yaw: 270",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 28,
                Name = "MavSensorRotationRoll90Pitch90",
                Description = "Roll: 90, Pitch: 90, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 29,
                Name = "MavSensorRotationRoll180Pitch90",
                Description = "Roll: 180, Pitch: 90, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30,
                Name = "MavSensorRotationRoll270Pitch90",
                Description = "Roll: 270, Pitch: 90, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31,
                Name = "MavSensorRotationRoll90Pitch180",
                Description = "Roll: 90, Pitch: 180, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "MavSensorRotationRoll270Pitch180",
                Description = "Roll: 270, Pitch: 180, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 33,
                Name = "MavSensorRotationRoll90Pitch270",
                Description = "Roll: 90, Pitch: 270, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 34,
                Name = "MavSensorRotationRoll180Pitch270",
                Description = "Roll: 180, Pitch: 270, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 35,
                Name = "MavSensorRotationRoll270Pitch270",
                Description = "Roll: 270, Pitch: 270, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 36,
                Name = "MavSensorRotationRoll90Pitch180Yaw90",
                Description = "Roll: 90, Pitch: 180, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 37,
                Name = "MavSensorRotationRoll90Yaw270",
                Description = "Roll: 90, Pitch: 0, Yaw: 270",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 38,
                Name = "MavSensorRotationRoll90Pitch68Yaw293",
                Description = "Roll: 90, Pitch: 68, Yaw: 293",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 39,
                Name = "MavSensorRotationPitch315",
                Description = "Pitch: 315",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 40,
                Name = "MavSensorRotationRoll90Pitch315",
                Description = "Roll: 90, Pitch: 315",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 100,
                Name = "MavSensorRotationCustom",
                Description = "Custom orientation",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavProtocolCapability",
                Description = "Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MissionFloat",
                Description = "Autopilot supports MISSION float message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ParamFloat",
                Description = "Autopilot supports the new param float message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MissionInt",
                Description = "Autopilot supports MISSION_ITEM_INT scaled integer message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "CommandInt",
                Description = "Autopilot supports COMMAND_INT scaled integer message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "ParamUnion",
                Description = "Autopilot supports the new param union message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Ftp",
                Description = "Autopilot supports the new FILE_TRANSFER_PROTOCOL message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "SetAttitudeTarget",
                Description = "Autopilot supports commanding attitude offboard.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "SetPositionTargetLocalNed",
                Description = "Autopilot supports commanding position and velocity targets in local NED frame.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "SetPositionTargetGlobalInt",
                Description = "Autopilot supports commanding position and velocity targets in global scaled integers.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "Terrain",
                Description = "Autopilot supports terrain protocol / data handling.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "SetActuatorTarget",
                Description = "Autopilot supports direct actuator control.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "FlightTermination",
                Description = "Autopilot supports the flight termination command.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "CompassCalibration",
                Description = "Autopilot supports onboard compass calibration.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8192,
                Name = "Mavlink2",
                Description = "Autopilot supports MAVLink version 2.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16384,
                Name = "MissionFence",
                Description = "Autopilot supports mission fence protocol.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32768,
                Name = "MissionRally",
                Description = "Autopilot supports mission rally point protocol.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 65536,
                Name = "FlightInformation",
                Description = "Autopilot supports the flight information protocol.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavMissionType",
                Description = "Type of mission items being requested/sent in mission protocol.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Mission",
                Description = "Items are mission commands for main mission.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Fence",
                Description = "Specifies GeoFence area(s). Items are MAV_CMD_NAV_FENCE_ GeoFence items.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Rally",
                Description = "Specifies the rally points for the vehicle. Rally points are alternative RTL points. Items are MAV_CMD_NAV_RALLY_POINT rally point items.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 255,
                Name = "All",
                Description = "Only used in MISSION_CLEAR_ALL to clear all mission types.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavEstimatorType",
                Description = "Enumeration of estimator types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Unknown type of the estimator.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Naive",
                Description = "This is a naive estimator without any real covariance feedback.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Vision",
                Description = "Computer vision based estimate. Might be up to scale.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Vio",
                Description = "Visual-inertial estimate.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Gps",
                Description = "Plain GPS estimate.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "GpsIns",
                Description = "Estimator integrating GPS and inertial sensing.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Mocap",
                Description = "Estimate from external motion capturing system.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Lidar",
                Description = "Estimator based on lidar sensor input.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Autopilot",
                Description = "Estimator on autopilot.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavBatteryType",
                Description = "Enumeration of battery types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Not specified.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Lipo",
                Description = "Lithium polymer battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Life",
                Description = "Lithium-iron-phosphate battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Lion",
                Description = "Lithium-ION battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Nimh",
                Description = "Nickel metal hydride battery",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavBatteryFunction",
                Description = "Enumeration of battery functions",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Battery function is unknown",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "All",
                Description = "Battery supports all flight systems",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Propulsion",
                Description = "Battery for the propulsion system",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Avionics",
                Description = "Avionics battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavBatteryTypePayload",
                Description = "Payload battery",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavBatteryChargeState",
                Description = "Enumeration for battery charge states.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undefined",
                Description = "Low battery state is not provided",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Ok",
                Description = "Battery is not in low state. Normal operation.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Low",
                Description = "Battery state is low, warn and monitor close.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Critical",
                Description = "Battery state is critical, return or abort immediately.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Emergency",
                Description = "Battery state is too low for ordinary abort sequence. Perform fastest possible emergency stop to prevent damage.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Failed",
                Description = "Battery failed, damage unavoidable. Possible causes (faults) are listed in MAV_BATTERY_FAULT.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Unhealthy",
                Description = "Battery is diagnosed to be defective or an error occurred, usage is discouraged / prohibited. Possible causes (faults) are listed in MAV_BATTERY_FAULT.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Charging",
                Description = "Battery is charging.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavBatteryMode",
                Description = "Battery mode. Note, the normal operation mode (i.e. when flying) should be reported as MAV_BATTERY_MODE_UNKNOWN to allow message trimming in normal flight.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Battery mode not supported/unknown battery mode/normal operation.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "AutoDischarging",
                Description = "Battery is auto discharging (towards storage level).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HotSwap",
                Description = "Battery in hot-swap mode (current limited to prevent spikes that might damage sensitive electrical circuits).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavBatteryFault",
                Description = "Smart battery supply status/fault flags (bitmask) for health indication. The battery must also report either MAV_BATTERY_CHARGE_STATE_FAILED or MAV_BATTERY_CHARGE_STATE_UNHEALTHY if any of these are set.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "DeepDischarge",
                Description = "Battery has deep discharged.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Spikes",
                Description = "Voltage spikes.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "CellFail",
                Description = "One or more cells have failed. Battery should also report MAV_BATTERY_CHARGE_STATE_FAILE (and should not be used).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "OverCurrent",
                Description = "Over-current fault.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "OverTemperature",
                Description = "Over-temperature fault.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "UnderTemperature",
                Description = "Under-temperature fault.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "IncompatibleVoltage",
                Description = "Vehicle voltage is not compatible with this battery (batteries on same power rail should have similar voltage).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "IncompatibleFirmware",
                Description = "Battery firmware is not compatible with current autopilot firmware.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "BatteryFaultIncompatibleCellsConfiguration",
                Description = "Battery is not compatible due to cell configuration (e.g. 5s1p when vehicle requires 6s).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavGeneratorStatusFlag",
                Description = "Flags to report status/failure cases for a power generator (used in GENERATOR_STATUS). Note that FAULTS are conditions that cause the generator to fail. Warnings are conditions that require attention before the next use (they indicate the system is not operating properly).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Off",
                Description = "Generator is off.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Ready",
                Description = "Generator is ready to start generating power.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Generating",
                Description = "Generator is generating power.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Charging",
                Description = "Generator is charging the batteries (generating enough power to charge and provide the load).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "ReducedPower",
                Description = "Generator is operating at a reduced maximum power.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Maxpower",
                Description = "Generator is providing the maximum output.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "OvertempWarning",
                Description = "Generator is near the maximum operating temperature, cooling is insufficient.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "OvertempFault",
                Description = "Generator hit the maximum operating temperature and shutdown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "ElectronicsOvertempWarning",
                Description = "Power electronics are near the maximum operating temperature, cooling is insufficient.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "ElectronicsOvertempFault",
                Description = "Power electronics hit the maximum operating temperature and shutdown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "ElectronicsFault",
                Description = "Power electronics experienced a fault and shutdown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "PowersourceFault",
                Description = "The power source supplying the generator failed e.g. mechanical generator stopped, tether is no longer providing power, solar cell is in shade, hydrogen reaction no longer happening.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "CommunicationWarning",
                Description = "Generator controller having communication problems.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8192,
                Name = "CoolingWarning",
                Description = "Power electronic or generator cooling system error.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16384,
                Name = "PowerRailFault",
                Description = "Generator controller power rail experienced a fault.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32768,
                Name = "OvercurrentFault",
                Description = "Generator controller exceeded the overcurrent threshold and shutdown to prevent damage.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 65536,
                Name = "BatteryOverchargeCurrentFault",
                Description = "Generator controller detected a high current going into the batteries and shutdown to prevent battery damage.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 131072,
                Name = "OvervoltageFault",
                Description = "Generator controller exceeded it's overvoltage threshold and shutdown to prevent it exceeding the voltage rating.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 262144,
                Name = "BatteryUndervoltFault",
                Description = "Batteries are under voltage (generator will not start).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 524288,
                Name = "StartInhibited",
                Description = "Generator start is inhibited by e.g. a safety switch.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1048576,
                Name = "MaintenanceRequired",
                Description = "Generator requires maintenance.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2097152,
                Name = "WarmingUp",
                Description = "Generator is not ready to generate yet.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4194304,
                Name = "Idle",
                Description = "Generator is idle.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavVtolState",
                Description = "Enumeration of VTOL states",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undefined",
                Description = "MAV is not configured as VTOL",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "TransitionToFw",
                Description = "VTOL is in transition from multicopter to fixed-wing",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "TransitionToMc",
                Description = "VTOL is in transition from fixed-wing to multicopter",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Mc",
                Description = "VTOL is in multicopter state",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Fw",
                Description = "VTOL is in fixed-wing state",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavLandedState",
                Description = "Enumeration of landed detector states",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undefined",
                Description = "MAV landed state is unknown",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "OnGround",
                Description = "MAV is landed (on ground)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "InAir",
                Description = "MAV is in air",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Takeoff",
                Description = "MAV currently taking off",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Landing",
                Description = "MAV currently landing",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AdsbAltitudeType",
                Description = "Enumeration of the ADSB altimeter types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "PressureQnh",
                Description = "Altitude reported from a Baro source using QNH reference",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Geometric",
                Description = "Altitude reported from a GNSS source",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AdsbEmitterType",
                Description = "ADSB classification for the type of vehicle emitting the transponder signal",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "NoInfo",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Light",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Small",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Large",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "HighVortexLarge",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Heavy",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "HighlyManuv",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Rotocraft",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Unassigned",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Glider",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "LighterAir",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Parachute",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "UltraLight",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Unassigned2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Uav",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Space",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Unassgined3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "EmergencySurface",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "ServiceSurface",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "PointObstacle",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AdsbFlags",
                Description = "These flags indicate status such as data validity of each data source. Set = data valid",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ValidCoords",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ValidAltitude",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "ValidHeading",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "ValidVelocity",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "ValidCallsign",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "ValidSquawk",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "Simulated",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "VerticalVelocityValid",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "BaroValid",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32768,
                Name = "SourceUat",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavDoRepositionFlags",
                Description = "Bitmap of options for the MAV_CMD_DO_REPOSITION",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ChangeMode",
                Description = "The aircraft should immediately transition into guided. This should not be set for follow me applications",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "EstimatorStatusFlags",
                Description = "Flags in ESTIMATOR_STATUS message",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "EstimatorAttitude",
                Description = "True if the attitude estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "EstimatorVelocityHoriz",
                Description = "True if the horizontal velocity estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "EstimatorVelocityVert",
                Description = "True if the  vertical velocity estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "EstimatorPosHorizRel",
                Description = "True if the horizontal position (relative) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "EstimatorPosHorizAbs",
                Description = "True if the horizontal position (absolute) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "EstimatorPosVertAbs",
                Description = "True if the vertical position (absolute) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "EstimatorPosVertAgl",
                Description = "True if the vertical position (above ground) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "EstimatorConstPosMode",
                Description = "True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical flow)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "EstimatorPredPosHorizRel",
                Description = "True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "EstimatorPredPosHorizAbs",
                Description = "True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "EstimatorGpsGlitch",
                Description = "True if the EKF has detected a GPS glitch",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "EstimatorAccelError",
                Description = "True if the EKF has detected bad accelerometer data",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MotorTestOrder",
                Description = "Sequence that motors are tested when using MAV_CMD_DO_MOTOR_TEST.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Default",
                Description = "Default autopilot motor test method.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Sequence",
                Description = "Motor numbers are specified as their index in a predefined vehicle-specific sequence.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Board",
                Description = "Motor numbers are specified as the output as labeled on the board.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MotorTestThrottleType",
                Description = "Defines how throttle value is represented in MAV_CMD_DO_MOTOR_TEST.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MotorTestThrottlePercent",
                Description = "Throttle as a percentage (0 ~ 100)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MotorTestThrottlePwm",
                Description = "Throttle as an absolute PWM value (normally in range of 1000~2000).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MotorTestThrottlePilot",
                Description = "Throttle pass-through from pilot's transmitter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MotorTestCompassCal",
                Description = "Per-motor compass calibration test.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GpsInputIgnoreFlags",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "GpsInputIgnoreFlagAlt",
                Description = "ignore altitude field",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "GpsInputIgnoreFlagHdop",
                Description = "ignore hdop field",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "GpsInputIgnoreFlagVdop",
                Description = "ignore vdop field",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "GpsInputIgnoreFlagVelHoriz",
                Description = "ignore horizontal velocity field (vn and ve)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "GpsInputIgnoreFlagVelVert",
                Description = "ignore vertical velocity field (vd)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "GpsInputIgnoreFlagSpeedAccuracy",
                Description = "ignore speed accuracy field",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "GpsInputIgnoreFlagHorizontalAccuracy",
                Description = "ignore horizontal accuracy field",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "GpsInputIgnoreFlagVerticalAccuracy",
                Description = "ignore vertical accuracy field",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavCollisionAction",
                Description = "Possible actions an aircraft can take to avoid a collision.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "Ignore any potential collisions",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Report",
                Description = "Report potential collision",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "AscendOrDescend",
                Description = "Ascend or Descend to avoid threat",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MoveHorizontally",
                Description = "Move horizontally to avoid threat",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MovePerpendicular",
                Description = "Aircraft to move perpendicular to the collision's velocity vector",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Rtl",
                Description = "Aircraft to fly directly back to its launch point",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Hover",
                Description = "Aircraft to stop in place",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavCollisionThreatLevel",
                Description = "Aircraft-rated danger from this threat.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "Not a threat",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Low",
                Description = "Craft is mildly concerned about this threat",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "High",
                Description = "Craft is panicking, and may take actions to avoid threat",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavCollisionSrc",
                Description = "Source of information about this collision.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Adsb",
                Description = "ID field references ADSB_VEHICLE packets",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavlinkGpsGlobalInt",
                Description = "ID field references MAVLink SRC ID",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GpsFixType",
                Description = "Type of GPS fix",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "NoGps",
                Description = "No GPS connected",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "NoFix",
                Description = "No position information, GPS is connected",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_2dFix",
                Description = "2D position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_3dFix",
                Description = "3D position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Dgps",
                Description = "DGPS/SBAS aided 3D position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "RtkFloat",
                Description = "RTK float, 3D position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "RtkFixed",
                Description = "RTK Fixed, 3D position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Static",
                Description = "Static fixed, typically used for base stations",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Ppp",
                Description = "PPP, 3D position.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "RtkBaselineCoordinateSystem",
                Description = "RTK GPS baseline coordinate system, used for RTK corrections",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Ecef",
                Description = "Earth-centered, Earth-fixed",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Ned",
                Description = "RTK basestation centered, north, east, down",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "LandingTargetType",
                Description = "Type of landing target",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "LightBeacon",
                Description = "Landing target signaled by light beacon (ex: IR-LOCK)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "RadioBeacon",
                Description = "Landing target signaled by radio beacon (ex: ILS, NDB)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "VisionFiducial",
                Description = "Landing target represented by a fiducial marker (ex: ARTag)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "VisionOther",
                Description = "Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square)",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "VtolTransitionHeading",
                Description = "Direction of VTOL transition",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "VehicleDefault",
                Description = "Respect the heading configuration of the vehicle.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "NextWaypoint",
                Description = "Use the heading pointing towards the next waypoint.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Takeoff",
                Description = "Use the heading on takeoff (while sitting on the ground).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Specified",
                Description = "Use the specified heading in parameter 4.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Any",
                Description = "Use the current heading when reaching takeoff altitude (potentially facing the wind when weather-vaning is active).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CameraCapFlags",
                Description = "Camera capability flags (Bitmap)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CaptureVideo",
                Description = "Camera is able to record video",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "CaptureImage",
                Description = "Camera is able to capture images",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "HasModes",
                Description = "Camera has separate Video and Image/Photo modes (MAV_CMD_SET_CAMERA_MODE)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "CanCaptureImageInVideoMode",
                Description = "Camera can capture images while in video mode",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "CanCaptureVideoInImageMode",
                Description = "Camera can capture videos while in Photo/Image mode",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "HasImageSurveyMode",
                Description = "Camera has image survey mode (MAV_CMD_SET_CAMERA_MODE)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "HasBasicZoom",
                Description = "Camera has basic zoom control (MAV_CMD_SET_CAMERA_ZOOM)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "HasBasicFocus",
                Description = "Camera has basic focus control (MAV_CMD_SET_CAMERA_FOCUS)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "HasVideoStream",
                Description = "Camera has video streaming capabilities (request VIDEO_STREAM_INFORMATION with MAV_CMD_REQUEST_MESSAGE for video streaming info)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "HasTrackingPoint",
                Description = "Camera supports tracking of a point on the camera view.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "HasTrackingRectangle",
                Description = "Camera supports tracking of a selection rectangle on the camera view.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "HasTrackingGeoStatus",
                Description = "Camera supports tracking geo status (CAMERA_TRACKING_GEO_STATUS).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "VideoStreamStatusFlags",
                Description = "Stream status flags (Bitmap)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Running",
                Description = "Stream is active (running)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Thermal",
                Description = "Stream is thermal imaging",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "VideoStreamType",
                Description = "Video stream types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Rtsp",
                Description = "Stream is RTSP",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Rtpudp",
                Description = "Stream is RTP UDP (URI gives the port number)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "TcpMpeg",
                Description = "Stream is MPEG on TCP",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MpegTsH264",
                Description = "Stream is h.264 on MPEG TS (URI gives the port number)",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CameraTrackingStatusFlags",
                Description = "Camera tracking status flags",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Idle",
                Description = "Camera is not tracking",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Active",
                Description = "Camera is tracking",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Error",
                Description = "Camera tracking in error state",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CameraTrackingMode",
                Description = "Camera tracking modes",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "Not tracking",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Point",
                Description = "Target is a point",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Rectangle",
                Description = "Target is a rectangle",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CameraTrackingTargetData",
                Description = "Camera tracking target data (shows where tracked target is within image)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No target data",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Embedded",
                Description = "Target data embedded in image data (proprietary)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Rendered",
                Description = "Target data rendered in image",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "InStatus",
                Description = "Target data within status message (Point or Rectangle)",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CameraZoomType",
                Description = "Zoom types for MAV_CMD_SET_CAMERA_ZOOM",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "ZoomTypeStep",
                Description = "Zoom one step increment (-1 for wide, 1 for tele)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ZoomTypeContinuous",
                Description = "Continuous zoom up/down until stopped (-1 for wide, 1 for tele, 0 to stop zooming)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ZoomTypeRange",
                Description = "Zoom value as proportion of full camera range (a value between 0.0 and 100.0)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "ZoomTypeFocalLength",
                Description = "Zoom value/variable focal length in milimetres. Note that there is no message to get the valid zoom range of the camera, so this can type can only be used for cameras where the zoom range is known (implying that this cannot reliably be used in a GCS for an arbitrary camera)",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "SetFocusType",
                Description = "Focus types for MAV_CMD_SET_CAMERA_FOCUS",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "FocusTypeStep",
                Description = "Focus one step increment (-1 for focusing in, 1 for focusing out towards infinity).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "FocusTypeContinuous",
                Description = "Continuous focus up/down until stopped (-1 for focusing in, 1 for focusing out towards infinity, 0 to stop focusing)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "FocusTypeRange",
                Description = "Focus value as proportion of full camera focus range (a value between 0.0 and 100.0)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "FocusTypeMeters",
                Description = "Focus value in metres. Note that there is no message to get the valid focus range of the camera, so this can type can only be used for cameras where the range is known (implying that this cannot reliably be used in a GCS for an arbitrary camera).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "ParamAck",
                Description = "Result from PARAM_EXT_SET message (or a PARAM_SET within a transaction).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Accepted",
                Description = "Parameter value ACCEPTED and SET",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ValueUnsupported",
                Description = "Parameter value UNKNOWN/UNSUPPORTED",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Failed",
                Description = "Parameter failed to set",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "InProgress",
                Description = "Parameter value received but not yet set/accepted. A subsequent PARAM_ACK_TRANSACTION or PARAM_EXT_ACK with the final result will follow once operation is completed. This is returned immediately for parameters that take longer to set, indicating taht the the parameter was recieved and does not need to be resent.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CameraMode",
                Description = "Camera Modes.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Image",
                Description = "Camera is in image/photo capture mode.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Video",
                Description = "Camera is in video capture mode.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ImageSurvey",
                Description = "Camera is in image survey capture mode. It allows for camera controller to do specific settings for surveys.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavArmAuthDeniedReason",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Generic",
                Description = "Not a specific reason",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "None",
                Description = "Authorizer will send the error as string to GCS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "InvalidWaypoint",
                Description = "At least one waypoint have a invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Timeout",
                Description = "Timeout in the authorizer process(in case it depends on network)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "AirspaceInUse",
                Description = "Airspace of the mission in use by another vehicle, second result parameter can have the waypoint id that caused it to be denied.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "BadWeather",
                Description = "Weather is not good to fly",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "RcType",
                Description = "RC type",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "SpektrumDsm2",
                Description = "Spektrum DSM2",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "SpektrumDsmx",
                Description = "Spektrum DSMX",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "PositionTargetTypemask",
                Description = "Bitmap to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 9 is set the floats afx afy afz should be interpreted as force instead of acceleration.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "XIgnore",
                Description = "Ignore position x",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "YIgnore",
                Description = "Ignore position y",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "ZIgnore",
                Description = "Ignore position z",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "VxIgnore",
                Description = "Ignore velocity x",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "VyIgnore",
                Description = "Ignore velocity y",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "VzIgnore",
                Description = "Ignore velocity z",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "AxIgnore",
                Description = "Ignore acceleration x",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "AyIgnore",
                Description = "Ignore acceleration y",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "AzIgnore",
                Description = "Ignore acceleration z",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "ForceSet",
                Description = "Use force instead of acceleration",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "YawIgnore",
                Description = "Ignore yaw",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "YawRateIgnore",
                Description = "Ignore yaw rate",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AttitudeTargetTypemask",
                Description = "Bitmap to indicate which dimensions should be ignored by the vehicle: a value of 0b00000000 indicates that none of the setpoint dimensions should be ignored.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "BodyRollRateIgnore",
                Description = "Ignore body roll rate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "BodyPitchRateIgnore",
                Description = "Ignore body pitch rate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "BodyYawRateIgnore",
                Description = "Ignore body yaw rate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "ThrustBodySet",
                Description = "Use 3D body thrust setpoint instead of throttle",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "ThrottleIgnore",
                Description = "Ignore throttle",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "AttitudeIgnore",
                Description = "Ignore attitude",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "UtmFlightState",
                Description = "Airborne status of UAS.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Unknown",
                Description = "The flight state can't be determined.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Ground",
                Description = "UAS on ground.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Airborne",
                Description = "UAS airborne.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Emergency",
                Description = "UAS is in an emergency flight state.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Noctrl",
                Description = "UAS has no active controls.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "UtmDataAvailFlags",
                Description = "Flags for the global position report.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "TimeValid",
                Description = "The field time contains valid data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "UasIdAvailable",
                Description = "The field uas_id contains valid data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "PositionAvailable",
                Description = "The fields lat, lon and h_acc contain valid data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "AltitudeAvailable",
                Description = "The fields alt and v_acc contain valid data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "RelativeAltitudeAvailable",
                Description = "The field relative_alt contains valid data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "HorizontalVeloAvailable",
                Description = "The fields vx and vy contain valid data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "VerticalVeloAvailable",
                Description = "The field vz contains valid data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "NextWaypointAvailable",
                Description = "The fields next_lat, next_lon and next_alt contain valid data.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CellularStatusFlag",
                Description = "These flags encode the cellular network status",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "State unknown or not reportable.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Failed",
                Description = "Modem is unusable",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Initializing",
                Description = "Modem is being initialized",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Locked",
                Description = "Modem is locked",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Disabled",
                Description = "Modem is not enabled and is powered down",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Disabling",
                Description = "Modem is currently transitioning to the CELLULAR_STATUS_FLAG_DISABLED state",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Enabling",
                Description = "Modem is currently transitioning to the CELLULAR_STATUS_FLAG_ENABLED state",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Enabled",
                Description = "Modem is enabled and powered on but not registered with a network provider and not available for data connections",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Searching",
                Description = "Modem is searching for a network provider to register",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Registered",
                Description = "Modem is registered with a network provider, and data connections and messaging may be available for use",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Disconnecting",
                Description = "Modem is disconnecting and deactivating the last active packet data bearer. This state will not be entered if more than one packet data bearer is active and one of the active bearers is deactivated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Connecting",
                Description = "Modem is activating and connecting the first packet data bearer. Subsequent bearer activations when another bearer is already active do not cause this state to be entered",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Connected",
                Description = "One or more packet data bearers is active and connected",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CellularNetworkFailedReason",
                Description = "These flags are used to diagnose the failure state of CELLULAR_STATUS",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No error",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Unknown",
                Description = "Error state is unknown",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "SimMissing",
                Description = "SIM is required for the modem but missing",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "SimError",
                Description = "SIM is available, but not usuable for connection",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CellularNetworkRadioType",
                Description = "Cellular network radio type",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Gsm",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Cdma",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Wcdma",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Lte",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "PrecisionLandMode",
                Description = "Precision land modes (used in MAV_CMD_NAV_LAND).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Disabled",
                Description = "Normal (non-precision) landing.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Opportunistic",
                Description = "Use precision landing if beacon detected when land command accepted, otherwise land normally.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Required",
                Description = "Use precision landing, searching for beacon if not found when land command accepted (land normally if beacon cannot be found).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "ParachuteAction",
                Description = "Parachute actions. Trigger release and enable/disable auto-release.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "ParachuteDisable",
                Description = "Disable auto-release of parachute (i.e. release triggered by crash detectors).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ParachuteEnable",
                Description = "Enable auto-release of parachute.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ParachuteRelease",
                Description = "Release parachute and kill motors.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavTunnelPayloadType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Encoding of payload unknown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 200,
                Name = "Storm32Reserved0",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 201,
                Name = "Storm32Reserved1",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 202,
                Name = "Storm32Reserved2",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 203,
                Name = "Storm32Reserved3",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 204,
                Name = "Storm32Reserved4",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 205,
                Name = "Storm32Reserved5",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 206,
                Name = "Storm32Reserved6",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 207,
                Name = "Storm32Reserved7",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 208,
                Name = "Storm32Reserved8",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 209,
                Name = "Storm32Reserved9",
                Description = "Registered for STorM32 gimbal controller.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidIdType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No type defined.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "SerialNumber",
                Description = "Manufacturer Serial Number (ANSI/CTA-2063 format).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "CaaRegistrationId",
                Description = "CAA (Civil Aviation Authority) registered ID. Format: [ICAO Country Code].[CAA Assigned ID].",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "UtmAssignedUuid",
                Description = "UTM (Unmanned Traffic Management) assigned UUID (RFC4122).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "SpecificSessionId",
                Description = "A 20 byte ID for a specific flight/session. The exact ID type is indicated by the first byte of uas_id and these type values are managed by ICAO.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidUaType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No UA (Unmanned Aircraft) type defined.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Aeroplane",
                Description = "Aeroplane/Airplane. Fixed wing.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HelicopterOrMultirotor",
                Description = "Helicopter or multirotor.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Gyroplane",
                Description = "Gyroplane.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "HybridLift",
                Description = "VTOL (Vertical Take-Off and Landing). Fixed wing aircraft that can take off vertically.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Ornithopter",
                Description = "Ornithopter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Glider",
                Description = "Glider.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Kite",
                Description = "Kite.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "FreeBalloon",
                Description = "Free Balloon.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "CaptiveBalloon",
                Description = "Captive Balloon.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Airship",
                Description = "Airship. E.g. a blimp.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "FreeFallParachute",
                Description = "Free Fall/Parachute (unpowered).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Rocket",
                Description = "Rocket.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "TetheredPoweredAircraft",
                Description = "Tethered powered aircraft.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "GroundObstacle",
                Description = "Ground Obstacle.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Other",
                Description = "Other type of aircraft not listed earlier.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidStatus",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undeclared",
                Description = "The status of the (UA) Unmanned Aircraft is undefined.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Ground",
                Description = "The UA is on the ground.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Airborne",
                Description = "The UA is in the air.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Emergency",
                Description = "The UA is having an emergency.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidHeightRef",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "OverTakeoff",
                Description = "The height field is relative to the take-off location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "OverGround",
                Description = "The height field is relative to ground.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidHorAcc",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "The horizontal accuracy is unknown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_10nm",
                Description = "The horizontal accuracy is smaller than 10 Nautical Miles. 18.52 km.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_4nm",
                Description = "The horizontal accuracy is smaller than 4 Nautical Miles. 7.408 km.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_2nm",
                Description = "The horizontal accuracy is smaller than 2 Nautical Miles. 3.704 km.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_1nm",
                Description = "The horizontal accuracy is smaller than 1 Nautical Miles. 1.852 km.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "_05nm",
                Description = "The horizontal accuracy is smaller than 0.5 Nautical Miles. 926 m.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "_03nm",
                Description = "The horizontal accuracy is smaller than 0.3 Nautical Miles. 555.6 m.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "_01nm",
                Description = "The horizontal accuracy is smaller than 0.1 Nautical Miles. 185.2 m.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "_005nm",
                Description = "The horizontal accuracy is smaller than 0.05 Nautical Miles. 92.6 m.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "_30Meter",
                Description = "The horizontal accuracy is smaller than 30 meter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "_10Meter",
                Description = "The horizontal accuracy is smaller than 10 meter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "_3Meter",
                Description = "The horizontal accuracy is smaller than 3 meter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "_1Meter",
                Description = "The horizontal accuracy is smaller than 1 meter.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidVerAcc",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "The vertical accuracy is unknown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_150Meter",
                Description = "The vertical accuracy is smaller than 150 meter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_45Meter",
                Description = "The vertical accuracy is smaller than 45 meter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_25Meter",
                Description = "The vertical accuracy is smaller than 25 meter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_10Meter",
                Description = "The vertical accuracy is smaller than 10 meter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "_3Meter",
                Description = "The vertical accuracy is smaller than 3 meter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "_1Meter",
                Description = "The vertical accuracy is smaller than 1 meter.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidSpeedAcc",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "The speed accuracy is unknown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_10MetersPerSecond",
                Description = "The speed accuracy is smaller than 10 meters per second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_3MetersPerSecond",
                Description = "The speed accuracy is smaller than 3 meters per second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_1MetersPerSecond",
                Description = "The speed accuracy is smaller than 1 meters per second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_03MetersPerSecond",
                Description = "The speed accuracy is smaller than 0.3 meters per second.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidTimeAcc",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "The timestamp accuracy is unknown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_01Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.1 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_02Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.2 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_03Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.3 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_04Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.4 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "_05Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.5 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "_06Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.6 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "_07Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.7 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "_08Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.8 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "_09Second",
                Description = "The timestamp accuracy is smaller than or equal to 0.9 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "_10Second",
                Description = "The timestamp accuracy is smaller than or equal to 1.0 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "_11Second",
                Description = "The timestamp accuracy is smaller than or equal to 1.1 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "_12Second",
                Description = "The timestamp accuracy is smaller than or equal to 1.2 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "_13Second",
                Description = "The timestamp accuracy is smaller than or equal to 1.3 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "_14Second",
                Description = "The timestamp accuracy is smaller than or equal to 1.4 second.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "_15Second",
                Description = "The timestamp accuracy is smaller than or equal to 1.5 second.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidAuthType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No authentication type is specified.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "UasIdSignature",
                Description = "Signature for the UAS (Unmanned Aircraft System) ID.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "OperatorIdSignature",
                Description = "Signature for the Operator ID.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MessageSetSignature",
                Description = "Signature for the entire message set.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "NetworkRemoteId",
                Description = "Authentication is provided by Network Remote ID.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "SpecificAuthentication",
                Description = "The exact authentication type is indicated by the first byte of authentication_data and these type values are managed by ICAO.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidDescType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Text",
                Description = "Free-form text description of the purpose of the flight.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidOperatorLocationType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Takeoff",
                Description = "The location of the operator is the same as the take-off location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "LiveGnss",
                Description = "The location of the operator is based on live GNSS data.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Fixed",
                Description = "The location of the operator is a fixed location.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidClassificationType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undeclared",
                Description = "The classification type for the UA is undeclared.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Eu",
                Description = "The classification type for the UA follows EU (European Union) specifications.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidCategoryEu",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undeclared",
                Description = "The category for the UA, according to the EU specification, is undeclared.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Open",
                Description = "The category for the UA, according to the EU specification, is the Open category.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Specific",
                Description = "The category for the UA, according to the EU specification, is the Specific category.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Certified",
                Description = "The category for the UA, according to the EU specification, is the Certified category.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidClassEu",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undeclared",
                Description = "The class for the UA, according to the EU specification, is undeclared.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Class0",
                Description = "The class for the UA, according to the EU specification, is Class 0.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Class1",
                Description = "The class for the UA, according to the EU specification, is Class 1.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Class2",
                Description = "The class for the UA, according to the EU specification, is Class 2.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Class3",
                Description = "The class for the UA, according to the EU specification, is Class 3.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Class4",
                Description = "The class for the UA, according to the EU specification, is Class 4.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Class5",
                Description = "The class for the UA, according to the EU specification, is Class 5.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Class6",
                Description = "The class for the UA, according to the EU specification, is Class 6.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavOdidOperatorIdType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Caa",
                Description = "CAA (Civil Aviation Authority) registered operator ID.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "TuneFormat",
                Description = "Tune formats (used for vehicle buzzer/tone generation).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Qbasic11",
                Description = "Format is QBasic 1.1 Play: https://www.qbasic.net/en/reference/qb11/Statement/PLAY-006.htm.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MmlModern",
                Description = "Format is Modern Music Markup Language (MML): https://en.wikipedia.org/wiki/Music_Macro_Language#Modern_MML.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "ComponentCapFlags",
                Description = "Component capability flags (Bitmap)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Param",
                Description = "Component has parameters, and supports the parameter protocol (PARAM messages).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ParamExt",
                Description = "Component has parameters, and supports the extended parameter protocol (PARAM_EXT messages).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AisType",
                Description = "Type of AIS vessel, enum duplicated from AIS standard, https://gpsd.gitlab.io/gpsd/AIVDM.html",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Not available (default).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Reserved1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Reserved2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Reserved3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Reserved4",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Reserved5",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Reserved6",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Reserved7",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Reserved8",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Reserved9",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Reserved10",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Reserved11",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Reserved12",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Reserved13",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Reserved14",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Reserved15",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Reserved16",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "Reserved17",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "Reserved18",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "Reserved19",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "Wig",
                Description = "Wing In Ground effect.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 21,
                Name = "WigHazardousA",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 22,
                Name = "WigHazardousB",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 23,
                Name = "WigHazardousC",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 24,
                Name = "WigHazardousD",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 25,
                Name = "WigReserved1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 26,
                Name = "WigReserved2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 27,
                Name = "WigReserved3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 28,
                Name = "WigReserved4",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 29,
                Name = "WigReserved5",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30,
                Name = "Fishing",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31,
                Name = "Towing",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "TowingLarge",
                Description = "Towing: length exceeds 200m or breadth exceeds 25m.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 33,
                Name = "Dredging",
                Description = "Dredging or other underwater ops.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 34,
                Name = "Diving",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 35,
                Name = "Military",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 36,
                Name = "Sailing",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 37,
                Name = "Pleasure",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 38,
                Name = "Reserved20",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 39,
                Name = "Reserved21",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 40,
                Name = "Hsc",
                Description = "High Speed Craft.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 41,
                Name = "HscHazardousA",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42,
                Name = "HscHazardousB",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 43,
                Name = "HscHazardousC",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 44,
                Name = "HscHazardousD",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 45,
                Name = "HscReserved1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 46,
                Name = "HscReserved2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 47,
                Name = "HscReserved3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 48,
                Name = "HscReserved4",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 49,
                Name = "HscUnknown",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 50,
                Name = "Pilot",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 51,
                Name = "Sar",
                Description = "Search And Rescue vessel.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 52,
                Name = "Tug",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 53,
                Name = "PortTender",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 54,
                Name = "AntiPollution",
                Description = "Anti-pollution equipment.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 55,
                Name = "LawEnforcement",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 56,
                Name = "SpareLocal1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 57,
                Name = "SpareLocal2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 58,
                Name = "MedicalTransport",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 59,
                Name = "Nonecombatant",
                Description = "Noncombatant ship according to RR Resolution No. 18.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 60,
                Name = "Passenger",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 61,
                Name = "PassengerHazardousA",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 62,
                Name = "PassengerHazardousB",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 63,
                Name = "AisTypePassengerHazardousC",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "PassengerHazardousD",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 65,
                Name = "PassengerReserved1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 66,
                Name = "PassengerReserved2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 67,
                Name = "PassengerReserved3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 68,
                Name = "AisTypePassengerReserved4",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 69,
                Name = "PassengerUnknown",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 70,
                Name = "Cargo",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 71,
                Name = "CargoHazardousA",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 72,
                Name = "CargoHazardousB",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 73,
                Name = "CargoHazardousC",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 74,
                Name = "CargoHazardousD",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 75,
                Name = "CargoReserved1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 76,
                Name = "CargoReserved2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 77,
                Name = "CargoReserved3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 78,
                Name = "CargoReserved4",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 79,
                Name = "CargoUnknown",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 80,
                Name = "Tanker",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 81,
                Name = "TankerHazardousA",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 82,
                Name = "TankerHazardousB",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 83,
                Name = "TankerHazardousC",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 84,
                Name = "TankerHazardousD",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 85,
                Name = "TankerReserved1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 86,
                Name = "TankerReserved2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 87,
                Name = "TankerReserved3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 88,
                Name = "TankerReserved4",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 89,
                Name = "TankerUnknown",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 90,
                Name = "Other",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 91,
                Name = "OtherHazardousA",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 92,
                Name = "OtherHazardousB",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 93,
                Name = "OtherHazardousC",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 94,
                Name = "OtherHazardousD",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 95,
                Name = "OtherReserved1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 96,
                Name = "OtherReserved2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 97,
                Name = "OtherReserved3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 98,
                Name = "OtherReserved4",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 99,
                Name = "OtherUnknown",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AisNavStatus",
                Description = "Navigational status of AIS vessel, enum duplicated from AIS standard, https://gpsd.gitlab.io/gpsd/AIVDM.html",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "UnderWay",
                Description = "Under way using engine.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "AisNavAnchored",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "AisNavUnCommanded",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "AisNavRestrictedManoeuverability",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "AisNavDraughtConstrained",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "AisNavMoored",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "AisNavAground",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "AisNavFishing",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "AisNavSailing",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "AisNavReservedHsc",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "AisNavReservedWig",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "AisNavReserved1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "AisNavReserved2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "AisNavReserved3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "AisNavAisSart",
                Description = "Search And Rescue Transponder.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "AisNavUnknown",
                Description = "Not available (default).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AisFlags",
                Description = "These flags are used in the AIS_VESSEL.fields bitmask to indicate validity of data in the other message fields. When set, the data is valid.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "PositionAccuracy",
                Description = "1 = Position accuracy less than 10m, 0 = position accuracy greater than 10m.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ValidCog",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "ValidVelocity",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "HighVelocity",
                Description = "1 = Velocity over 52.5765m/s (102.2 knots)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "ValidTurnRate",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "TurnRateSignOnly",
                Description = "Only the sign of the returned turn rate value is valid, either greater than 5deg/30s or less than -5deg/30s",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "ValidDimensions",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "LargeBowDimension",
                Description = "Distance to bow is larger than 511m",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "LargeSternDimension",
                Description = "Distance to stern is larger than 511m",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "LargePortDimension",
                Description = "Distance to port side is larger than 63m",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "LargeStarboardDimension",
                Description = "Distance to starboard side is larger than 63m",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "ValidCallsign",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "ValidName",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FailureUnit",
                Description = "List of possible units where failures can be injected.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "SensorGyro",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "SensorAccel",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "SensorMag",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "SensorBaro",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "SensorGps",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "SensorOpticalFlow",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "SensorVio",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "SensorDistanceSensor",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "SensorAirspeed",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 100,
                Name = "SystemBattery",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 101,
                Name = "SystemMotor",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 102,
                Name = "SystemServo",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 103,
                Name = "SystemAvoidance",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 104,
                Name = "SystemRcSignal",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 105,
                Name = "SystemMavlinkSignal",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FailureType",
                Description = "List of possible failure type to inject.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Ok",
                Description = "No failure injected, used to reset a previous failure.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Off",
                Description = "Sets unit off, so completely non-responsive.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Stuck",
                Description = "Unit is stuck e.g. keeps reporting the same value.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Garbage",
                Description = "Unit is reporting complete garbage.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Wrong",
                Description = "Unit is consistently wrong.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Slow",
                Description = "Unit is slow, so e.g. reporting at slower than expected rate.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Delayed",
                Description = "Data of unit is delayed in time.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Intermittent",
                Description = "Unit is sometimes working, sometimes not.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "NavVtolLandOptions",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Default",
                Description = "Default autopilot landing behaviour.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "FwDescent",
                Description = "Descend in fixed wing mode, transitioning to multicopter mode for vertical landing when close to the ground.           The fixed wing descent pattern is at the discretion of the vehicle (e.g. transition altitude, loiter direction, radius, and speed, etc.).         ",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HoverDescent",
                Description = "Land in multicopter mode on reaching the landing co-ordinates (the whole landing is by 'hover descent').",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavWinchStatusFlag",
                Description = "Winch status flags used in WINCH_STATUS",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavWinchStatusHealthy",
                Description = "Winch is healthy",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavWinchStatusFullyRetracted",
                Description = "Winch thread is fully retracted",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavWinchStatusMoving",
                Description = "Winch motor is moving",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "MavWinchStatusClutchEngaged",
                Description = "Winch clutch is engaged allowing motor to move freely",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MagCalStatus",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MagCalNotStarted",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MagCalWaitingToStart",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MagCalRunningStepOne",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MagCalRunningStepTwo",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MagCalSuccess",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "MagCalFailed",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "MagCalBadOrientation",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "MagCalBadRadius",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavEventErrorReason",
                Description = "Reason for an event error response.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unavailable",
                Description = "The requested event is not available (anymore).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavEventCurrentSequenceFlags",
                Description = "Flags for CURRENT_EVENT_SEQUENCE.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Reset",
                Description = "A sequence reset has happened (e.g. vehicle reboot).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "HilSensorUpdatedFlags",
                Description = "Flags in the HIL_SENSOR message indicate which fields have updated since the last message",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "HilSensorUpdatedNone",
                Description = "None of the fields in HIL_SENSOR have been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "HilSensorUpdatedXacc",
                Description = "The value in the xacc field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HilSensorUpdatedYacc",
                Description = "The value in the yacc field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "HilSensorUpdatedZacc",
                Description = "The value in the zacc field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "HilSensorUpdatedXgyro",
                Description = "The value in the xgyro field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "HilSensorUpdatedYgyro",
                Description = "The value in the ygyro field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "HilSensorUpdatedZgyro",
                Description = "The value in the zgyro field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "HilSensorUpdatedXmag",
                Description = "The value in the xmag field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "HilSensorUpdatedYmag",
                Description = "The value in the ymag field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "HilSensorUpdatedZmag",
                Description = "The value in the zmag field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "HilSensorUpdatedAbsPressure",
                Description = "The value in the abs_pressure field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "HilSensorUpdatedDiffPressure",
                Description = "The value in the diff_pressure field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "HilSensorUpdatedPressureAlt",
                Description = "The value in the pressure_alt field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "HilSensorUpdatedTemperature",
                Description = "The value in the temperature field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4097,
                Name = "HilSensorUpdatedReset",
                Description = "Full reset of attitude/position/velocities/etc was performed in sim (Bit 31).",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "HighresImuUpdatedFlags",
                Description = "Flags in the HIGHRES_IMU message indicate which fields have updated since the last message",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "HighresImuUpdatedNone",
                Description = "None of the fields in HIGHRES_IMU have been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "HighresImuUpdatedXacc",
                Description = "The value in the xacc field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HighresImuUpdatedYacc",
                Description = "The value in the yacc field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "HighresImuUpdatedZacc",
                Description = "The value in the zacc field has been updated since",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "HighresImuUpdatedXgyro",
                Description = "The value in the xgyro field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "HighresImuUpdatedYgyro",
                Description = "The value in the ygyro field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "HighresImuUpdatedZgyro",
                Description = "The value in the zgyro field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "HighresImuUpdatedXmag",
                Description = "The value in the xmag field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "HighresImuUpdatedYmag",
                Description = "The value in the ymag field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "HighresImuUpdatedZmag",
                Description = "The value in the zmag field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "HighresImuUpdatedAbsPressure",
                Description = "The value in the abs_pressure field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "HighresImuUpdatedDiffPressure",
                Description = "The value in the diff_pressure field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "HighresImuUpdatedPressureAlt",
                Description = "The value in the pressure_alt field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "HighresImuUpdatedTemperature",
                Description = "The value in the temperature field has been updated",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 65535,
                Name = "HighresImuUpdatedAll",
                Description = "All fields in HIGHRES_IMU have been updated.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
        }
    }

}
